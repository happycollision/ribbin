package cli

import (
	"os"
	"path/filepath"
	"strings"
	"testing"
)

func TestGenerateRedirectScript(t *testing.T) {
	// Create temporary directory for tests
	tmpDir := t.TempDir()

	t.Run("successful script generation", func(t *testing.T) {
		scriptPath := filepath.Join(tmpDir, "test-script.sh")
		command := "npm"

		err := GenerateRedirectScript(scriptPath, command)
		if err != nil {
			t.Fatalf("expected no error, got: %v", err)
		}

		// Verify file exists
		if _, err := os.Stat(scriptPath); os.IsNotExist(err) {
			t.Fatal("script file was not created")
		}
	})

	t.Run("directory creation", func(t *testing.T) {
		scriptPath := filepath.Join(tmpDir, "nested", "dir", "script.sh")
		command := "tsc"

		err := GenerateRedirectScript(scriptPath, command)
		if err != nil {
			t.Fatalf("expected no error, got: %v", err)
		}

		// Verify parent directories were created
		if _, err := os.Stat(filepath.Dir(scriptPath)); os.IsNotExist(err) {
			t.Fatal("parent directories were not created")
		}

		// Verify file exists
		if _, err := os.Stat(scriptPath); os.IsNotExist(err) {
			t.Fatal("script file was not created")
		}
	})

	t.Run("file already exists error", func(t *testing.T) {
		scriptPath := filepath.Join(tmpDir, "existing-script.sh")
		command := "yarn"

		// Create file first
		err := os.WriteFile(scriptPath, []byte("existing content"), 0644)
		if err != nil {
			t.Fatalf("failed to create test file: %v", err)
		}

		// Try to generate script
		err = GenerateRedirectScript(scriptPath, command)
		if err == nil {
			t.Fatal("expected error for existing file, got none")
		}

		if !strings.Contains(err.Error(), "already exists") {
			t.Errorf("expected 'already exists' error, got: %v", err)
		}

		if !strings.Contains(err.Error(), "will not overwrite") {
			t.Errorf("expected 'will not overwrite' in error, got: %v", err)
		}
	})

	t.Run("permissions are set correctly", func(t *testing.T) {
		scriptPath := filepath.Join(tmpDir, "permissions-test.sh")
		command := "pnpm"

		err := GenerateRedirectScript(scriptPath, command)
		if err != nil {
			t.Fatalf("expected no error, got: %v", err)
		}

		// Check file permissions
		info, err := os.Stat(scriptPath)
		if err != nil {
			t.Fatalf("failed to stat file: %v", err)
		}

		mode := info.Mode()
		if mode.Perm() != 0755 {
			t.Errorf("expected permissions 0755, got: %o", mode.Perm())
		}

		// Verify executable bit is set
		if mode&0111 == 0 {
			t.Error("expected executable bit to be set")
		}
	})

	t.Run("template has correct content", func(t *testing.T) {
		scriptPath := filepath.Join(tmpDir, "content-test.sh")
		command := "node"

		err := GenerateRedirectScript(scriptPath, command)
		if err != nil {
			t.Fatalf("expected no error, got: %v", err)
		}

		// Read generated content
		content, err := os.ReadFile(scriptPath)
		if err != nil {
			t.Fatalf("failed to read script: %v", err)
		}

		contentStr := string(content)

		// Verify shebang
		if !strings.HasPrefix(contentStr, "#!/bin/bash\n") {
			t.Error("script should start with #!/bin/bash")
		}

		// Verify command name appears in comments
		expectedStrings := []string{
			"# Redirect script for: " + command,
			"# Generated by ribbin",
			"RIBBIN_ORIGINAL_BIN",
			"RIBBIN_COMMAND",
			"RIBBIN_CONFIG",
			"RIBBIN_ACTION",
			"# Example 1: Call original command with all arguments",
			"# Example 2: Add custom flags or modify behavior",
			"# Example 3: Add environment variables",
			"# Example 4: Conditional logic",
			"# TODO: Customize this script for your needs",
			`exec "$RIBBIN_ORIGINAL_BIN" "$@"`,
		}

		for _, expected := range expectedStrings {
			if !strings.Contains(contentStr, expected) {
				t.Errorf("expected content to contain %q", expected)
			}
		}

		// Verify command appears in specific places
		if !strings.Contains(contentStr, "# Redirect script for: "+command) {
			t.Errorf("expected header to reference command %q", command)
		}

		if !strings.Contains(contentStr, "original "+command+" binary") {
			t.Errorf("expected description to reference command %q", command)
		}

		if !strings.Contains(contentStr, "/usr/bin/"+command+".ribbin-original") {
			t.Errorf("expected example path with command %q", command)
		}

		if !strings.Contains(contentStr, `RIBBIN_COMMAND      - Command name (e.g., "`+command+`")`) {
			t.Errorf("expected RIBBIN_COMMAND example with command %q", command)
		}
	})

	t.Run("multiple commands have unique content", func(t *testing.T) {
		commands := []string{"npm", "yarn", "pnpm"}

		for _, cmd := range commands {
			scriptPath := filepath.Join(tmpDir, "unique-"+cmd+".sh")

			err := GenerateRedirectScript(scriptPath, cmd)
			if err != nil {
				t.Fatalf("failed to generate script for %s: %v", cmd, err)
			}

			content, err := os.ReadFile(scriptPath)
			if err != nil {
				t.Fatalf("failed to read script for %s: %v", cmd, err)
			}

			contentStr := string(content)

			// Verify command appears in the script
			if !strings.Contains(contentStr, "# Redirect script for: "+cmd) {
				t.Errorf("script for %s should contain command name in header", cmd)
			}

			if !strings.Contains(contentStr, "/usr/bin/"+cmd+".ribbin-original") {
				t.Errorf("script for %s should contain command name in example path", cmd)
			}
		}
	})
}

func TestGenerateScriptTemplate(t *testing.T) {
	t.Run("generates valid bash script", func(t *testing.T) {
		command := "test-cmd"
		template := generateScriptTemplate(command)

		// Should have shebang
		if !strings.HasPrefix(template, "#!/bin/bash\n") {
			t.Error("template should start with bash shebang")
		}

		// Should contain command name
		if !strings.Contains(template, command) {
			t.Errorf("template should contain command name %q", command)
		}

		// Should end with newline
		if !strings.HasSuffix(template, "\n") {
			t.Error("template should end with newline")
		}
	})
}
