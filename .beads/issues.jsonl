{"id":"ribbin-0d3","title":"Add LICENSE file","description":"# Add LICENSE file\n\nCreate an MIT License file for the ribbin project.\n\n## File: LICENSE\n\n```\nMIT License\n\nCopyright (c) 2026 Don Denton\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n```\n\n## Acceptance Criteria\n- LICENSE file exists at repo root\n- Uses MIT license\n- Copyright holder: Don Denton\n- Year: 2026","status":"closed","priority":3,"issue_type":"task","owner":"don@happycollision.com","created_at":"2026-01-17T23:36:10.714209-05:00","created_by":"Don Denton","updated_at":"2026-01-17T23:46:18.404826-05:00","closed_at":"2026-01-17T23:46:18.404826-05:00","close_reason":"Implemented all release infrastructure files"}
{"id":"ribbin-0m8","title":"Add GitHub Actions release workflow","description":"# Add GitHub Actions release workflow\n\nCreate CI/CD workflows using GoReleaser for automated releases.\n\n## Files to create\n\n### .github/workflows/release.yml\n\nTriggered on version tags (v*). Uses GoReleaser for cross-compilation.\n\n```yaml\nname: Release\non:\n  push:\n    tags: ['v*']\n\npermissions:\n  contents: write\n\njobs:\n  release:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n        with:\n          fetch-depth: 0\n      - uses: actions/setup-go@v5\n        with:\n          go-version: '1.23'\n      - uses: goreleaser/goreleaser-action@v6\n        with:\n          args: release --clean\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n```\n\n### .goreleaser.yaml\n\n```yaml\nversion: 2\n\nbuilds:\n  - main: ./cmd/ribbin\n    binary: ribbin\n    goos: [linux, darwin]\n    goarch: [amd64, arm64]\n    ldflags:\n      - -s -w\n\narchives:\n  - format: tar.gz\n    name_template: \"{{ .ProjectName }}_{{ .Version }}_{{ .Os }}_{{ .Arch }}\"\n\nchecksum:\n  name_template: 'checksums.txt'\n  algorithm: sha256\n\nrelease:\n  github:\n    owner: happycollision\n    name: ribbin\n```\n\n### .github/workflows/ci.yml\n\nPR checks - run tests on push/PR.\n\n```yaml\nname: CI\non: [push, pull_request]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-go@v5\n        with:\n          go-version: '1.23'\n      - run: make test\n```\n\n## Platforms\n- linux/amd64\n- linux/arm64\n- darwin/amd64\n- darwin/arm64\n\n## Acceptance Criteria\n- .github/workflows/release.yml exists\n- .github/workflows/ci.yml exists\n- .goreleaser.yaml exists\n- CI runs on push/PR\n- Release triggers on v* tags\n- Builds for all 4 platform combinations\n- Generates SHA256 checksums\n- Creates GitHub release with assets","status":"closed","priority":2,"issue_type":"task","owner":"don@happycollision.com","created_at":"2026-01-17T23:36:13.781512-05:00","created_by":"Don Denton","updated_at":"2026-01-17T23:46:18.407898-05:00","closed_at":"2026-01-17T23:46:18.407898-05:00","close_reason":"Implemented all release infrastructure files"}
{"id":"ribbin-1ar","title":"Add bash installer script","description":"# Add bash installer script\n\nCreate an install.sh script for easy installation of ribbin.\n\n## File: install.sh\n\nFeatures:\n- Detect OS (darwin/linux)\n- Detect architecture (amd64/arm64)\n- Download pre-built binary from GitHub releases (happycollision/ribbin)\n- Verify SHA256 checksum for security\n- Install to ~/.local/bin (no sudo required)\n- Add PATH hint if ~/.local/bin not in PATH\n\n## Usage\n\n```bash\ncurl -fsSL https://raw.githubusercontent.com/happycollision/ribbin/main/install.sh | bash\n```\n\n## Script outline\n\n```bash\n#\\!/bin/bash\nset -euo pipefail\n\nREPO=\"happycollision/ribbin\"\nINSTALL_DIR=\"${HOME}/.local/bin\"\n\n# Detect OS\nOS=$(uname -s | tr '[:upper:]' '[:lower:]')\n\n# Detect arch\nARCH=$(uname -m)\ncase $ARCH in\n  x86_64) ARCH=\"amd64\" ;;\n  aarch64|arm64) ARCH=\"arm64\" ;;\nesac\n\n# Get latest version\nVERSION=$(curl -sL \"https://api.github.com/repos/${REPO}/releases/latest\" | grep tag_name | cut -d'\"' -f4)\n\n# Download and verify\n# Install to INSTALL_DIR\n# Check PATH\n```\n\n## Acceptance Criteria\n- install.sh exists at repo root\n- Detects OS (darwin, linux)\n- Detects architecture (amd64, arm64)\n- Downloads from GitHub releases\n- Verifies SHA256 checksum\n- Installs to ~/.local/bin\n- Prints PATH warning if needed\n- Script is executable (chmod +x)","status":"closed","priority":2,"issue_type":"task","owner":"don@happycollision.com","created_at":"2026-01-17T23:36:12.092185-05:00","created_by":"Don Denton","updated_at":"2026-01-17T23:46:18.408994-05:00","closed_at":"2026-01-17T23:46:18.408994-05:00","close_reason":"Implemented all release infrastructure files"}
{"id":"ribbin-1jy","title":"Add tests for all components","description":"# Test Suite Implementation\n\nComprehensive tests for all ribbin components.\n\n## ⚠️ IMPORTANT: Docker-based Testing\n\n**All tests MUST run inside a Docker container** to prevent any risk of damaging the developer's machine. The shim installer modifies binaries and creates symlinks - running tests directly on the host could corrupt system binaries.\n\n### Docker Test Setup\n\n```dockerfile\n# Dockerfile.test\nFROM golang:1.21-alpine\n\nRUN apk add --no-cache bash coreutils\n\nWORKDIR /app\nCOPY . .\n\nRUN go mod download\nCMD [\"go\", \"test\", \"-v\", \"./...\"]\n```\n\n### Running Tests\n\n```bash\n# Build test container\ndocker build -f Dockerfile.test -t ribbin-test .\n\n# Run unit tests\ndocker run --rm ribbin-test\n\n# Run with coverage\ndocker run --rm ribbin-test go test -cover ./...\n\n# Run integration tests\ndocker run --rm ribbin-test go test -tags=integration ./...\n\n# Interactive debugging\ndocker run --rm -it ribbin-test sh\n```\n\n### Makefile Targets\n\n```makefile\ntest:\n\tdocker build -f Dockerfile.test -t ribbin-test .\n\tdocker run --rm ribbin-test\n\ntest-coverage:\n\tdocker run --rm ribbin-test go test -cover ./...\n\ntest-integration:\n\tdocker run --rm ribbin-test go test -tags=integration -v ./...\n```\n\n## Test Files to Create\n\n### internal/config/project_test.go\n\n```go\nfunc TestFindProjectConfig(t *testing.T) {\n    // Test walking up directories\n    // Test config not found (reaches root)\n    // Test malformed JSON\n}\n\nfunc TestLoadProjectConfig(t *testing.T) {\n    // Test valid config\n    // Test missing file\n    // Test invalid JSON\n    // Test missing required fields\n}\n```\n\n### internal/config/registry_test.go\n\n```go\nfunc TestLoadRegistry(t *testing.T) {\n    // Test new registry creation\n    // Test existing registry load\n    // Test corrupt registry handling\n}\n\nfunc TestSaveRegistry(t *testing.T) {\n    // Test creates directory if missing\n    // Test overwrites existing\n}\n\nfunc TestPruneDeadActivations(t *testing.T) {\n    // Test removes dead PIDs\n    // Test keeps live PIDs\n}\n```\n\n### internal/shim/resolver_test.go\n\n```go\nfunc TestResolveCommand(t *testing.T) {\n    // Test common commands (ls, echo)\n    // Test command not found\n}\n\nfunc TestIsAlreadyShimmed(t *testing.T) {\n    // Test regular binary → false\n    // Test symlink to ribbin → true\n    // Test symlink to other → false\n}\n```\n\n### internal/shim/installer_test.go\n\n```go\nfunc TestInstall(t *testing.T) {\n    // Test creates symlink\n    // Test renames original\n    // Test updates registry\n    // Test rollback on failure\n}\n\nfunc TestUninstall(t *testing.T) {\n    // Test removes symlink\n    // Test restores original\n    // Test updates registry\n}\n\nfunc TestFindSidecars(t *testing.T) {\n    // Test finds sidecars in directory\n    // Test handles missing directory\n}\n```\n\n### internal/shim/runner_test.go\n\n```go\nfunc TestRun(t *testing.T) {\n    // These are tricky because Run calls syscall.Exec\n    // May need to test individual functions instead\n}\n\nfunc TestIsActive(t *testing.T) {\n    // Test global on\n    // Test activation match\n    // Test no match\n}\n```\n\n### internal/process/ancestry_test.go\n\n```go\nfunc TestIsDescendantOf(t *testing.T) {\n    // Test self PID\n    // Test parent PID\n    // Test unrelated PID\n}\n\nfunc TestProcessExists(t *testing.T) {\n    // Test current process → true\n    // Test PID 1 → true\n    // Test non-existent PID → false\n}\n```\n\n## Integration Tests\n\n### internal/integration_test.go\n\n```go\n//go:build integration\n\nfunc TestFullShimCycle(t *testing.T) {\n    // 1. Create temp directory with test binary\n    // 2. Create ribbin.json\n    // 3. Run shim command\n    // 4. Verify symlink created\n    // 5. Run shimmed command (should passthrough - not active)\n    // 6. Run 'ribbin on'\n    // 7. Run shimmed command (should block)\n    // 8. Run with RIBBIN_BYPASS=1 (should work)\n    // 9. Run unshim\n    // 10. Verify original restored\n}\n```\n\n## Test Utilities\n\n### internal/testutil/testutil.go\n\n```go\npackage testutil\n\n// CreateTempBinary creates a simple executable script for testing\nfunc CreateTempBinary(t *testing.T, name string) string\n\n// CreateTempConfig creates a ribbin.json in a temp directory\nfunc CreateTempConfig(t *testing.T, cfg *config.ProjectConfig) string\n\n// CleanupTempDir removes temp directory after test\nfunc CleanupTempDir(t *testing.T, dir string)\n```\n\n## Test Fixtures\n\n```\ntestdata/\n├── configs/\n│   ├── valid.json\n│   ├── invalid.json\n│   └── minimal.json\n└── projects/\n    ├── basic/\n    │   └── ribbin.json\n    └── nested/\n        ├── ribbin.json\n        └── subdir/\n```\n\n## Acceptance Criteria\n\n- All packages have tests\n- **All tests run in Docker container** (never on host machine)\n- Tests pass on Linux (Docker container)\n- Code coverage \u003e 70%\n- Integration test covers full workflow\n- `make test` runs everything safely in Docker","status":"closed","priority":2,"issue_type":"task","owner":"don@happycollision.com","created_at":"2026-01-17T22:09:33.238988-05:00","created_by":"Don Denton","updated_at":"2026-01-17T23:31:16.932901-05:00","closed_at":"2026-01-17T23:31:16.932901-05:00","close_reason":"Implemented comprehensive test suite with Docker-based testing. All tests pass. Coverage: config 86%, process 83%, shim 66%, cli 23%. Integration tests verify full shim cycle.","dependencies":[{"issue_id":"ribbin-1jy","depends_on_id":"ribbin-skj","type":"parent-child","created_at":"2026-01-17T22:11:35.675979-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-1jy","depends_on_id":"ribbin-jf8","type":"blocks","created_at":"2026-01-17T22:13:28.249372-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-1jy","depends_on_id":"ribbin-5tf","type":"blocks","created_at":"2026-01-17T22:13:33.466402-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-1jy","depends_on_id":"ribbin-1n6","type":"blocks","created_at":"2026-01-17T22:13:38.685713-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-1jy","depends_on_id":"ribbin-9pw","type":"blocks","created_at":"2026-01-17T22:13:43.892205-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-1jy","depends_on_id":"ribbin-85g","type":"blocks","created_at":"2026-01-17T22:13:49.106936-05:00","created_by":"Don Denton"}]}
{"id":"ribbin-1n6","title":"Implement shim runner (core blocking logic)","description":"# Shim Runner Implementation\n\nThe core logic that runs when a shimmed command is invoked.\n\n## File to Create\n\n### internal/shim/runner.go\n\n```go\npackage shim\n\nimport (\n    \"fmt\"\n    \"os\"\n    \"path/filepath\"\n    \"syscall\"\n    \n    \"github.com/user/ribbin/internal/config\"\n    \"github.com/user/ribbin/internal/process\"\n)\n\n// Run executes when ribbin is invoked as a shimmed command\nfunc Run(argv0 string, args []string) {\n    originalPath := argv0 + \".ribbin-original\"\n    \n    // 1. Verify sidecar exists\n    if _, err := os.Stat(originalPath); os.IsNotExist(err) {\n        fatal(\"Sidecar not found: %s\\nRun 'ribbin unshim --all --search' to repair\", originalPath)\n    }\n    \n    // 2. Check bypass environment variable\n    if os.Getenv(\"RIBBIN_BYPASS\") == \"1\" {\n        execOriginal(originalPath, args)\n        return\n    }\n    \n    // 3. Load registry and check activation state\n    registry, err := config.LoadRegistry()\n    if err != nil || registry == nil {\n        // Registry missing/corrupt - passthrough for safety\n        execOriginal(originalPath, args)\n        return\n    }\n    \n    // 4. Check if shims are active\n    if !isActive(registry) {\n        execOriginal(originalPath, args)\n        return\n    }\n    \n    // 5. Find project config\n    cfg, _, err := config.FindProjectConfig()\n    if err != nil {\n        // No config in directory tree - passthrough\n        execOriginal(originalPath, args)\n        return\n    }\n    \n    // 6. Check if this command is configured\n    cmdName := filepath.Base(argv0)\n    shimCfg, found := cfg.Shims[cmdName]\n    if !found {\n        execOriginal(originalPath, args)\n        return\n    }\n    \n    // 7. Apply action\n    switch shimCfg.Action {\n    case \"block\":\n        printBlockMessage(cmdName, shimCfg.Message)\n        os.Exit(1)\n    default:\n        // Unknown action - passthrough\n        execOriginal(originalPath, args)\n    }\n}\n\nfunc isActive(registry *config.Registry) bool {\n    // Global on?\n    if registry.GlobalOn {\n        return true\n    }\n    \n    // Check for activation ancestry (is current process a child of an activated shell?)\n    for _, entry := range registry.Activations {\n        if isDescendant, _ := process.IsDescendantOf(entry.PID); isDescendant {\n            return true\n        }\n    }\n    \n    // Prune dead activations while we're here\n    registry.PruneDeadActivations()\n    \n    return false\n}\n\nfunc execOriginal(path string, args []string) {\n    argv := append([]string{path}, args...)\n    env := os.Environ()\n    \n    if err := syscall.Exec(path, argv, env); err != nil {\n        fatal(\"Failed to exec %s: %v\", path, err)\n    }\n}\n\nfunc printBlockMessage(cmd, message string) {\n    fmt.Fprintf(os.Stderr, \"\\n\")\n    fmt.Fprintf(os.Stderr, \"┌─────────────────────────────────────────────────────────┐\\n\")\n    fmt.Fprintf(os.Stderr, \"│  ERROR: Direct use of '%s' is blocked.%s│\\n\", cmd, padding(cmd))\n    fmt.Fprintf(os.Stderr, \"│                                                         │\\n\")\n    fmt.Fprintf(os.Stderr, \"│  %s%s│\\n\", message, padding(message))\n    fmt.Fprintf(os.Stderr, \"│                                                         │\\n\")\n    fmt.Fprintf(os.Stderr, \"│  Bypass: RIBBIN_BYPASS=1 %s ...%s│\\n\", cmd, padding(cmd))\n    fmt.Fprintf(os.Stderr, \"└─────────────────────────────────────────────────────────┘\\n\")\n    fmt.Fprintf(os.Stderr, \"\\n\")\n}\n\nfunc padding(s string) string {\n    // Pad to fit in 55-char box\n    pad := 55 - len(s) - 2\n    if pad \u003c 1 {\n        pad = 1\n    }\n    return strings.Repeat(\" \", pad)\n}\n\nfunc fatal(format string, args ...interface{}) {\n    fmt.Fprintf(os.Stderr, \"ribbin: \"+format+\"\\n\", args...)\n    os.Exit(1)\n}\n```\n\n## Flow Summary\n\n```\nargv[0] = /usr/bin/cat\n       ↓\nsidecar exists? (/usr/bin/cat.ribbin-original)\n       ↓ yes\nRIBBIN_BYPASS=1? → passthrough\n       ↓ no\nload registry\n       ↓\nis active? (global_on OR ancestor PID in activations)\n       ↓ no → passthrough\n       ↓ yes\nfind ribbin.json (walk up from PWD)\n       ↓ not found → passthrough\n       ↓ found\ncommand in config? (\"cat\" in shims)\n       ↓ no → passthrough\n       ↓ yes\naction = \"block\" → print message, exit 1\n```\n\n## Performance Considerations\n\n- Fast path for inactive state (just check registry.GlobalOn and activations length)\n- Only load project config if active\n- syscall.Exec replaces process (no subprocess overhead)\n\n## Tests\n\n- Test passthrough when inactive\n- Test blocking when active\n- Test bypass environment variable\n- Test missing sidecar error\n- Test no config in tree → passthrough\n- Test command not in config → passthrough\n\n## Acceptance Criteria\n\n- Blocks commands when active and configured\n- Passes through when inactive\n- Passes through when no config found\n- RIBBIN_BYPASS=1 always passes through\n- Error message is clear and helpful","status":"closed","priority":1,"issue_type":"task","owner":"don@happycollision.com","created_at":"2026-01-17T22:05:12.707848-05:00","created_by":"Don Denton","updated_at":"2026-01-17T23:00:55.395978-05:00","closed_at":"2026-01-17T23:00:55.395978-05:00","close_reason":"Closed","dependencies":[{"issue_id":"ribbin-1n6","depends_on_id":"ribbin-skj","type":"parent-child","created_at":"2026-01-17T22:11:14.717471-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-1n6","depends_on_id":"ribbin-g2x","type":"blocks","created_at":"2026-01-17T22:12:51.594972-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-1n6","depends_on_id":"ribbin-w7k","type":"blocks","created_at":"2026-01-17T22:12:56.837226-05:00","created_by":"Don Denton"}]}
{"id":"ribbin-1of","title":"Implement CLI framework with Cobra","description":"# CLI Framework Implementation\n\nSet up the CLI structure using Cobra.\n\n## Files to Create\n\n### internal/cli/cli.go\n\n```go\npackage cli\n\nimport (\n    \"github.com/spf13/cobra\"\n)\n\nvar rootCmd = \u0026cobra.Command{\n    Use:   \"ribbin\",\n    Short: \"Command shimming tool\",\n    Long:  \"Ribbin replaces binaries with shims that can block or redirect commands based on project configuration.\",\n}\n\nfunc Execute() error {\n    return rootCmd.Execute()\n}\n\nfunc init() {\n    rootCmd.AddCommand(shimCmd)\n    rootCmd.AddCommand(unshimCmd)\n    rootCmd.AddCommand(activateCmd)\n    rootCmd.AddCommand(onCmd)\n    rootCmd.AddCommand(offCmd)\n}\n```\n\n### cmd/ribbin/main.go\n\n```go\npackage main\n\nimport (\n    \"os\"\n    \"path/filepath\"\n    \n    \"github.com/user/ribbin/internal/cli\"\n    \"github.com/user/ribbin/internal/shim\"\n)\n\nfunc main() {\n    invoked := filepath.Base(os.Args[0])\n    \n    // If invoked as \"ribbin\", run CLI mode\n    if invoked == \"ribbin\" {\n        if err := cli.Execute(); err != nil {\n            os.Exit(1)\n        }\n        return\n    }\n    \n    // Otherwise, we're being invoked as a shimmed command\n    shim.Run(os.Args[0], os.Args[1:])\n}\n```\n\n## Command Stubs\n\nCreate stub files for each command (implementation in separate tasks):\n\n### internal/cli/shim.go\n```go\nvar shimCmd = \u0026cobra.Command{\n    Use:   \"shim\",\n    Short: \"Install shims for commands in ribbin.json\",\n    RunE:  runShim,\n}\n\nfunc runShim(cmd *cobra.Command, args []string) error {\n    // TODO: implement\n    return nil\n}\n```\n\n### internal/cli/unshim.go\n```go\nvar unshimCmd = \u0026cobra.Command{\n    Use:   \"unshim\",\n    Short: \"Remove shims and restore original binaries\",\n    RunE:  runUnshim,\n}\n\nvar unshimAll bool\nvar unshimSearch bool\n\nfunc init() {\n    unshimCmd.Flags().BoolVar(\u0026unshimAll, \"all\", false, \"Restore all shimmed commands from registry\")\n    unshimCmd.Flags().BoolVar(\u0026unshimSearch, \"search\", false, \"Search filesystem for sidecars (use with --all)\")\n}\n\nfunc runUnshim(cmd *cobra.Command, args []string) error {\n    // TODO: implement\n    return nil\n}\n```\n\n### internal/cli/activate.go\n```go\nvar activateCmd = \u0026cobra.Command{\n    Use:   \"activate\",\n    Short: \"Enable shims for this terminal session\",\n    RunE:  runActivate,\n}\n\nfunc runActivate(cmd *cobra.Command, args []string) error {\n    // TODO: implement\n    return nil\n}\n```\n\n### internal/cli/on.go\n```go\nvar onCmd = \u0026cobra.Command{\n    Use:   \"on\",\n    Short: \"Enable shims globally\",\n    RunE:  runOn,\n}\n\nfunc runOn(cmd *cobra.Command, args []string) error {\n    // TODO: implement\n    return nil\n}\n```\n\n### internal/cli/off.go\n```go\nvar offCmd = \u0026cobra.Command{\n    Use:   \"off\",\n    Short: \"Disable shims globally\",\n    RunE:  runOff,\n}\n\nfunc runOff(cmd *cobra.Command, args []string) error {\n    // TODO: implement\n    return nil\n}\n```\n\n## Acceptance Criteria\n\n- `ribbin --help` shows all commands\n- `ribbin shim --help` shows shim help\n- Mode detection works (ribbin vs shimmed command)\n- All command stubs compile","status":"closed","priority":1,"issue_type":"task","owner":"don@happycollision.com","created_at":"2026-01-17T22:03:49.513518-05:00","created_by":"Don Denton","updated_at":"2026-01-17T22:56:39.466549-05:00","closed_at":"2026-01-17T22:56:39.466549-05:00","close_reason":"Closed","dependencies":[{"issue_id":"ribbin-1of","depends_on_id":"ribbin-skj","type":"parent-child","created_at":"2026-01-17T22:10:59.051091-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-1of","depends_on_id":"ribbin-8n3","type":"blocks","created_at":"2026-01-17T22:12:09.697265-05:00","created_by":"Don Denton"}]}
{"id":"ribbin-48m","title":"Polish: colored output, error messages, and UX","description":"# Polish and UX Improvements\n\nFinal polish for user experience.\n\n## Colored Output\n\n### internal/output/output.go\n\n```go\npackage output\n\nimport (\n    \"fmt\"\n    \"os\"\n    \n    \"github.com/fatih/color\"\n)\n\nvar (\n    successColor = color.New(color.FgGreen)\n    errorColor   = color.New(color.FgRed)\n    warnColor    = color.New(color.FgYellow)\n    infoColor    = color.New(color.FgCyan)\n)\n\nfunc Success(format string, args ...interface{}) {\n    successColor.Fprintf(os.Stderr, \"✓ \"+format+\"\\n\", args...)\n}\n\nfunc Error(format string, args ...interface{}) {\n    errorColor.Fprintf(os.Stderr, \"✗ \"+format+\"\\n\", args...)\n}\n\nfunc Warn(format string, args ...interface{}) {\n    warnColor.Fprintf(os.Stderr, \"⚠ \"+format+\"\\n\", args...)\n}\n\nfunc Info(format string, args ...interface{}) {\n    infoColor.Fprintf(os.Stderr, format+\"\\n\", args...)\n}\n```\n\n## Improved Error Messages\n\n### Permission Denied\n```\n✗ Cannot shim /usr/bin/cat: permission denied\n\n  System binaries require elevated privileges.\n  Run: sudo ribbin shim\n```\n\n### No Config Found\n```\n✗ No ribbin.json found in directory tree\n\n  Create one with:\n    echo '{\"shims\":{\"tsc\":{\"action\":\"block\",\"message\":\"Use pnpm typecheck\"}}}' \u003e ribbin.json\n```\n\n### Command Not Found\n```\n⚠ Skipping 'foo': command not found in PATH\n\n  If this is a node_modules binary, add explicit path:\n    \"paths\": [\"node_modules/.bin/foo\"]\n```\n\n## Block Message Box\n\nUpdate the block message to be clearer:\n\n```\n┌──────────────────────────────────────────────────────────────┐\n│  ⛔ BLOCKED: tsc                                             │\n├──────────────────────────────────────────────────────────────┤\n│                                                              │\n│  Use 'pnpm run typecheck' instead                            │\n│                                                              │\n│  Bypass: RIBBIN_BYPASS=1 tsc [args...]                       │\n│                                                              │\n└──────────────────────────────────────────────────────────────┘\n```\n\n## Version Command\n\n```go\nvar versionCmd = \u0026cobra.Command{\n    Use:   \"version\",\n    Short: \"Print version information\",\n    Run: func(cmd *cobra.Command, args []string) {\n        fmt.Printf(\"ribbin version %s\\n\", version)\n    },\n}\n```\n\nBuild with version:\n```makefile\nVERSION := $(shell git describe --tags --always --dirty)\nLDFLAGS := -ldflags \"-X main.version=$(VERSION)\"\n```\n\n## Status Command\n\nShow current state:\n\n```\n$ ribbin status\n\nGlobal: OFF\nShimmed binaries: 3\n  /usr/bin/cat\n  /usr/local/bin/tsc\n  /opt/homebrew/bin/npm\n\nActive sessions: 1\n  PID 12345 (activated 5m ago)\n```\n\n## Help Text Improvements\n\nEnsure all commands have:\n- Short description (one line)\n- Long description (paragraph with examples)\n- Flag descriptions\n\n## Acceptance Criteria\n\n- Colored output for success/error/warning\n- Clear error messages with solutions\n- Version command works\n- Status command shows useful info\n- Help text is comprehensive","status":"open","priority":3,"issue_type":"task","owner":"don@happycollision.com","created_at":"2026-01-17T22:09:57.60253-05:00","created_by":"Don Denton","updated_at":"2026-01-17T22:19:24.077905-05:00","dependencies":[{"issue_id":"ribbin-48m","depends_on_id":"ribbin-skj","type":"parent-child","created_at":"2026-01-17T22:11:40.908435-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-48m","depends_on_id":"ribbin-1jy","type":"blocks","created_at":"2026-01-17T22:13:54.316425-05:00","created_by":"Don Denton"}]}
{"id":"ribbin-5f2","title":"Add CHANGELOG.md","description":"# Add CHANGELOG.md\n\nCreate a changelog following the Keep a Changelog format (https://keepachangelog.com).\n\n## File: CHANGELOG.md\n\n```markdown\n# Changelog\n\nAll notable changes to this project will be documented in this file.\n\nThe format is based on [Keep a Changelog](https://keepachangelog.com/en/1.1.0/),\nand this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).\n\n## [Unreleased]\n\n### Added\n- Initial implementation of ribbin CLI\n- Commands: shim, unshim, on, off, activate\n- TOML-based project configuration (ribbin.toml)\n- Docker-based test suite for safe testing\n- Process ancestry checking for shell-scoped activation\n```\n\n## Sections to use\n- **Added** - new features\n- **Changed** - changes in existing functionality\n- **Deprecated** - soon-to-be removed features\n- **Removed** - now removed features\n- **Fixed** - bug fixes\n- **Security** - vulnerability fixes\n\n## Acceptance Criteria\n- CHANGELOG.md exists at repo root\n- Follows Keep a Changelog format\n- Uses Semantic Versioning\n- Has [Unreleased] section with current features","status":"closed","priority":3,"issue_type":"task","owner":"don@happycollision.com","created_at":"2026-01-17T23:36:11.069759-05:00","created_by":"Don Denton","updated_at":"2026-01-17T23:46:18.406694-05:00","closed_at":"2026-01-17T23:46:18.406694-05:00","close_reason":"Implemented all release infrastructure files"}
{"id":"ribbin-5tf","title":"Implement 'ribbin unshim' command","description":"# ribbin unshim Command Implementation\n\nImplement the unshim command with --all and --search flags.\n\n## File to Modify\n\n### internal/cli/unshim.go\n\n```go\nvar unshimCmd = \u0026cobra.Command{\n    Use:   \"unshim\",\n    Short: \"Remove shims and restore original binaries\",\n    RunE:  runUnshim,\n}\n\nvar unshimAll bool\nvar unshimSearch bool\n\nfunc init() {\n    unshimCmd.Flags().BoolVar(\u0026unshimAll, \"all\", false, \"Restore all shimmed commands from registry\")\n    unshimCmd.Flags().BoolVar(\u0026unshimSearch, \"search\", false, \"Search filesystem for sidecars (use with --all)\")\n}\n\nfunc runUnshim(cmd *cobra.Command, args []string) error {\n    registry, err := config.LoadRegistry()\n    if err != nil {\n        return fmt.Errorf(\"failed to load registry: %w\", err)\n    }\n    \n    var pathsToUnshim []string\n    \n    if unshimAll {\n        if unshimSearch {\n            // Search filesystem for all sidecars\n            pathsToUnshim, err = shim.FindSidecars(commonBinDirs())\n            if err != nil {\n                return fmt.Errorf(\"search failed: %w\", err)\n            }\n        } else {\n            // Use registry\n            for path := range registry.Shims {\n                pathsToUnshim = append(pathsToUnshim, path)\n            }\n        }\n    } else {\n        // Use nearest ribbin.json\n        cfg, _, err := config.FindProjectConfig()\n        if err != nil {\n            return fmt.Errorf(\"no ribbin.json found (use --all to unshim from registry): %w\", err)\n        }\n        \n        for name, shimCfg := range cfg.Shims {\n            paths := shimCfg.Paths\n            if len(paths) == 0 {\n                resolved, err := shim.ResolveCommand(name)\n                if err != nil {\n                    continue\n                }\n                paths = []string{resolved}\n            }\n            pathsToUnshim = append(pathsToUnshim, paths...)\n        }\n    }\n    \n    var restored, skipped, failed int\n    \n    for _, p := range pathsToUnshim {\n        if err := shim.Uninstall(p, registry); err != nil {\n            if os.IsNotExist(err) {\n                skipped++\n            } else {\n                fmt.Printf(\"✗ %s: %v\\n\", p, err)\n                failed++\n            }\n        } else {\n            fmt.Printf(\"✓ %s: restored\\n\", p)\n            restored++\n        }\n    }\n    \n    if err := config.SaveRegistry(registry); err != nil {\n        return fmt.Errorf(\"failed to save registry: %w\", err)\n    }\n    \n    fmt.Printf(\"\\nRestored: %d, Skipped: %d, Failed: %d\\n\", restored, skipped, failed)\n    \n    return nil\n}\n\nfunc commonBinDirs() []string {\n    return []string{\n        \"/usr/bin\",\n        \"/usr/local/bin\",\n        \"/opt/homebrew/bin\",\n        os.Getenv(\"HOME\") + \"/.local/bin\",\n        os.Getenv(\"HOME\") + \"/go/bin\",\n    }\n}\n```\n\n## Modes\n\n### Default (no flags)\n- Find nearest ribbin.json\n- Unshim only commands listed in that config\n- Update registry\n\n### --all\n- Read global registry\n- Unshim everything in registry\n- Clear registry\n\n### --all --search\n- Search common binary directories for *.ribbin-original files\n- Unshim all found sidecars\n- Update registry based on what was found\n\n## FindSidecars Implementation\n\n```go\nfunc FindSidecars(searchPaths []string) ([]string, error) {\n    var sidecars []string\n    \n    for _, dir := range searchPaths {\n        pattern := filepath.Join(dir, \"*.ribbin-original\")\n        matches, err := filepath.Glob(pattern)\n        if err != nil {\n            continue // Skip inaccessible directories\n        }\n        \n        for _, match := range matches {\n            // Convert sidecar path to original binary path\n            original := strings.TrimSuffix(match, \".ribbin-original\")\n            sidecars = append(sidecars, original)\n        }\n    }\n    \n    return sidecars, nil\n}\n```\n\n## Acceptance Criteria\n\n- Default mode uses nearest config\n- --all mode uses registry\n- --all --search finds sidecars on filesystem\n- Registry is updated after unshim\n- Clear error messages","status":"closed","priority":1,"issue_type":"task","owner":"don@happycollision.com","created_at":"2026-01-17T22:04:32.794605-05:00","created_by":"Don Denton","updated_at":"2026-01-17T23:06:51.994991-05:00","closed_at":"2026-01-17T23:06:51.994991-05:00","close_reason":"Closed","dependencies":[{"issue_id":"ribbin-5tf","depends_on_id":"ribbin-skj","type":"parent-child","created_at":"2026-01-17T22:11:09.468507-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-5tf","depends_on_id":"ribbin-1of","type":"blocks","created_at":"2026-01-17T22:12:35.905556-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-5tf","depends_on_id":"ribbin-d9y","type":"blocks","created_at":"2026-01-17T22:12:41.142308-05:00","created_by":"Don Denton"}]}
{"id":"ribbin-85g","title":"Implement 'ribbin on' and 'ribbin off' commands","description":"# ribbin on/off Commands Implementation\n\nSimple global toggle for shim activation.\n\n## Files to Modify\n\n### internal/cli/on.go\n\n```go\npackage cli\n\nimport (\n    \"fmt\"\n    \n    \"github.com/spf13/cobra\"\n    \"github.com/user/ribbin/internal/config\"\n)\n\nvar onCmd = \u0026cobra.Command{\n    Use:   \"on\",\n    Short: \"Enable shims globally\",\n    Long: `Enables shims globally (for all shells, persists across sessions).\n    \nWhen globally on, shimmed commands will check ribbin.json in the \ncurrent directory tree and block according to configuration.\n\nUse 'ribbin activate' for per-session activation instead.`,\n    RunE: runOn,\n}\n\nfunc runOn(cmd *cobra.Command, args []string) error {\n    registry, err := config.LoadRegistry()\n    if err != nil {\n        return fmt.Errorf(\"failed to load registry: %w\", err)\n    }\n    \n    if registry.GlobalOn {\n        fmt.Println(\"Shims are already globally enabled\")\n        return nil\n    }\n    \n    registry.GlobalOn = true\n    \n    if err := config.SaveRegistry(registry); err != nil {\n        return fmt.Errorf(\"failed to save registry: %w\", err)\n    }\n    \n    fmt.Println(\"✓ Shims are now globally enabled\")\n    return nil\n}\n```\n\n### internal/cli/off.go\n\n```go\npackage cli\n\nimport (\n    \"fmt\"\n    \n    \"github.com/spf13/cobra\"\n    \"github.com/user/ribbin/internal/config\"\n)\n\nvar offCmd = \u0026cobra.Command{\n    Use:   \"off\",\n    Short: \"Disable shims globally\",\n    Long: `Disables shims globally.\n    \nWhen off, shimmed commands will pass through to the original binary\nregardless of ribbin.json configuration.\n\nNote: Per-session activations (via 'ribbin activate') are also ignored\nwhen globally off.`,\n    RunE: runOff,\n}\n\nfunc runOff(cmd *cobra.Command, args []string) error {\n    registry, err := config.LoadRegistry()\n    if err != nil {\n        return fmt.Errorf(\"failed to load registry: %w\", err)\n    }\n    \n    if !registry.GlobalOn {\n        fmt.Println(\"Shims are already globally disabled\")\n        return nil\n    }\n    \n    registry.GlobalOn = false\n    \n    if err := config.SaveRegistry(registry); err != nil {\n        return fmt.Errorf(\"failed to save registry: %w\", err)\n    }\n    \n    fmt.Println(\"✓ Shims are now globally disabled\")\n    return nil\n}\n```\n\n## Behavior\n\n### ribbin on\n- Sets `global_on: true` in registry\n- All shims become active (check config, potentially block)\n- Persists across terminal sessions\n\n### ribbin off\n- Sets `global_on: false` in registry\n- All shims passthrough (even if `activate` was called)\n- Persists across terminal sessions\n\n## Priority\n\nWhen checking if shims are active:\n1. If `global_on == true` → active\n2. Else if current process descends from an activated PID → active\n3. Else → inactive (passthrough)\n\nNote: `ribbin off` disables everything. If global is off, even per-session activations don't apply. This is intentional - it's the \"emergency off switch\".\n\n## Status Command (Optional Enhancement)\n\nCould add a status command to show current state:\n\n```go\nvar statusCmd = \u0026cobra.Command{\n    Use:   \"status\",\n    Short: \"Show current shim status\",\n    RunE: func(cmd *cobra.Command, args []string) error {\n        registry, _ := config.LoadRegistry()\n        \n        fmt.Printf(\"Global: %v\\n\", registry.GlobalOn)\n        fmt.Printf(\"Shimmed binaries: %d\\n\", len(registry.Shims))\n        fmt.Printf(\"Active sessions: %d\\n\", len(registry.Activations))\n        \n        return nil\n    },\n}\n```\n\n## Tests\n\n- Test on sets GlobalOn to true\n- Test off sets GlobalOn to false\n- Test idempotent (on when already on, off when already off)\n- Test shim respects global state\n\n## Acceptance Criteria\n\n- `ribbin on` enables globally\n- `ribbin off` disables globally\n- State persists in registry\n- Shim runner respects global state","status":"closed","priority":2,"issue_type":"task","owner":"don@happycollision.com","created_at":"2026-01-17T22:08:25.81097-05:00","created_by":"Don Denton","updated_at":"2026-01-17T23:00:55.398206-05:00","closed_at":"2026-01-17T23:00:55.398206-05:00","close_reason":"Closed","dependencies":[{"issue_id":"ribbin-85g","depends_on_id":"ribbin-skj","type":"parent-child","created_at":"2026-01-17T22:11:30.444208-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-85g","depends_on_id":"ribbin-1of","type":"blocks","created_at":"2026-01-17T22:13:17.776763-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-85g","depends_on_id":"ribbin-g2x","type":"blocks","created_at":"2026-01-17T22:13:23.016693-05:00","created_by":"Don Denton"}]}
{"id":"ribbin-8n3","title":"Restructure repo: Remove Bun/TS, initialize Go module","description":"# Restructure Repository for Go\n\nRemove the existing Bun/TypeScript setup and initialize a Go project.\n\n## Tasks\n\n1. Remove Bun/TS files:\n   - `src/` directory\n   - `bin/shim`\n   - `package.json`\n   - `bun.lock`\n   - `tsconfig.json`\n   \n2. Keep for reference:\n   - `INSTRUCTIONS.md` (documents the mise approach we're replacing)\n   - `bin-overrides/` (example shim scripts)\n   - `Plan.md` (original design notes)\n\n3. Initialize Go:\n   - `go mod init github.com/user/ribbin`\n   - Create directory structure:\n     ```\n     cmd/ribbin/main.go\n     internal/cli/\n     internal/config/\n     internal/shim/\n     internal/process/\n     ```\n\n4. Create Makefile with targets:\n   - `build` - compile binary\n   - `install` - install to GOPATH/bin\n   - `test` - run tests\n   - `clean` - remove build artifacts\n\n5. Update CLAUDE.md with new build commands\n\n## Acceptance Criteria\n\n- `go build ./cmd/ribbin` succeeds\n- `make build` produces `bin/ribbin`\n- Directory structure matches plan","status":"closed","priority":1,"issue_type":"task","owner":"don@happycollision.com","created_at":"2026-01-17T22:01:55.565394-05:00","created_by":"Don Denton","updated_at":"2026-01-17T22:52:24.955057-05:00","closed_at":"2026-01-17T22:52:24.955057-05:00","close_reason":"Closed","dependencies":[{"issue_id":"ribbin-8n3","depends_on_id":"ribbin-skj","type":"parent-child","created_at":"2026-01-17T22:10:38.116432-05:00","created_by":"Don Denton"}]}
{"id":"ribbin-9pw","title":"Implement 'ribbin activate' command","description":"# ribbin activate Command Implementation\n\nEnable shims for the current terminal session by tracking the shell's PID.\n\n## File to Modify\n\n### internal/cli/activate.go\n\n```go\npackage cli\n\nimport (\n    \"fmt\"\n    \"os\"\n    \"strconv\"\n    \"time\"\n    \n    \"github.com/spf13/cobra\"\n    \"github.com/user/ribbin/internal/config\"\n    \"github.com/user/ribbin/internal/process\"\n)\n\nvar activateCmd = \u0026cobra.Command{\n    Use:   \"activate\",\n    Short: \"Enable shims for this terminal session\",\n    Long: `Activates shims for the current shell session.\n    \nWhen activated, shimmed commands will check ribbin.json and block \naccording to configuration. When the shell exits, activation is \nautomatically cleaned up.\n\nUse 'ribbin on' for global (persistent) activation instead.`,\n    RunE: runActivate,\n}\n\nfunc runActivate(cmd *cobra.Command, args []string) error {\n    // 1. Get parent shell PID\n    shellPID := os.Getppid()\n    \n    // Verify shell is actually running\n    if !process.ProcessExists(shellPID) {\n        return fmt.Errorf(\"parent process %d does not exist\", shellPID)\n    }\n    \n    // 2. Load registry\n    registry, err := config.LoadRegistry()\n    if err != nil {\n        return fmt.Errorf(\"failed to load registry: %w\", err)\n    }\n    \n    // 3. Check if already activated for this shell\n    pidStr := strconv.Itoa(shellPID)\n    if _, exists := registry.Activations[pidStr]; exists {\n        fmt.Printf(\"Already activated for shell PID %d\\n\", shellPID)\n        return nil\n    }\n    \n    // 4. Prune dead activations\n    registry.PruneDeadActivations()\n    \n    // 5. Add new activation\n    if registry.Activations == nil {\n        registry.Activations = make(map[string]config.ActivationEntry)\n    }\n    registry.Activations[pidStr] = config.ActivationEntry{\n        PID:         shellPID,\n        ActivatedAt: time.Now(),\n    }\n    \n    // 6. Save registry\n    if err := config.SaveRegistry(registry); err != nil {\n        return fmt.Errorf(\"failed to save registry: %w\", err)\n    }\n    \n    fmt.Printf(\"✓ Activated for shell PID %d\\n\", shellPID)\n    fmt.Printf(\"  Shims will auto-deactivate when this shell exits.\\n\")\n    \n    return nil\n}\n```\n\n### Registry Methods for Activation\n\nAdd to internal/config/registry.go:\n\n```go\n// PruneDeadActivations removes activations for processes that no longer exist\nfunc (r *Registry) PruneDeadActivations() {\n    for pidStr, entry := range r.Activations {\n        if !process.ProcessExists(entry.PID) {\n            delete(r.Activations, pidStr)\n        }\n    }\n}\n```\n\n## How Activation Works\n\n1. User runs `ribbin activate` in their shell\n2. We record the shell's PID (PPID of ribbin process)\n3. When shimmed commands run, they check if their ancestor PIDs include an activated PID\n4. When the shell dies, the activation becomes stale\n5. Stale activations are pruned lazily (on next shim invocation or activate call)\n\n## Why PPID?\n\nWhen user runs `ribbin activate`:\n- The shell forks to run ribbin\n- ribbin's PPID is the shell\n- We want to track the shell, not the ribbin process itself\n\n## Deactivation\n\nExplicit deactivation isn't strictly needed (lazy cleanup handles it), but we could add:\n\n```go\nvar deactivateCmd = \u0026cobra.Command{\n    Use:   \"deactivate\",\n    Short: \"Deactivate shims for this terminal session\",\n    RunE: func(cmd *cobra.Command, args []string) error {\n        shellPID := os.Getppid()\n        registry, _ := config.LoadRegistry()\n        delete(registry.Activations, strconv.Itoa(shellPID))\n        config.SaveRegistry(registry)\n        fmt.Println(\"Deactivated\")\n        return nil\n    },\n}\n```\n\n## Tests\n\n- Test activation adds entry to registry\n- Test activation is idempotent\n- Test prune removes dead PIDs\n- Test activation check works for child processes\n\n## Acceptance Criteria\n\n- `ribbin activate` records shell PID\n- Shims block when called from that shell or its children\n- Shims passthrough from other shells\n- Dead activations are cleaned up","status":"closed","priority":1,"issue_type":"task","owner":"don@happycollision.com","created_at":"2026-01-17T22:07:46.809092-05:00","created_by":"Don Denton","updated_at":"2026-01-17T23:00:55.397128-05:00","closed_at":"2026-01-17T23:00:55.397128-05:00","close_reason":"Closed","dependencies":[{"issue_id":"ribbin-9pw","depends_on_id":"ribbin-skj","type":"parent-child","created_at":"2026-01-17T22:11:25.21081-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-9pw","depends_on_id":"ribbin-1of","type":"blocks","created_at":"2026-01-17T22:13:02.062574-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-9pw","depends_on_id":"ribbin-g2x","type":"blocks","created_at":"2026-01-17T22:13:07.310071-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-9pw","depends_on_id":"ribbin-w7k","type":"blocks","created_at":"2026-01-17T22:13:12.557062-05:00","created_by":"Don Denton"}]}
{"id":"ribbin-d9y","title":"Implement shim installer (symlink and sidecar management)","description":"# Shim Installer Implementation\n\nCreate and remove symlinks, manage sidecar files.\n\n## File to Create\n\n### internal/shim/installer.go\n\n```go\n// Install creates a shim for a binary:\n// 1. Rename original to {path}.ribbin-original\n// 2. Create symlink {path} -\u003e ribbinPath\n// 3. Update registry\nfunc Install(binaryPath, ribbinPath string, registry *Registry, configPath string) error\n\n// Uninstall removes a shim:\n// 1. Remove symlink at {path}\n// 2. Rename {path}.ribbin-original back to {path}\n// 3. Remove from registry\nfunc Uninstall(binaryPath string, registry *Registry) error\n\n// FindSidecars searches directories for .ribbin-original files\nfunc FindSidecars(searchPaths []string) ([]string, error)\n\n// SidecarPath returns the sidecar path for a binary\nfunc SidecarPath(binaryPath string) string {\n    return binaryPath + \".ribbin-original\"\n}\n```\n\n## Implementation Details\n\n### Install Flow\n```go\nfunc Install(binaryPath, ribbinPath string, registry *Registry, configPath string) error {\n    sidecar := SidecarPath(binaryPath)\n    \n    // Check if already shimmed\n    if _, err := os.Stat(sidecar); err == nil {\n        return fmt.Errorf(\"%s is already shimmed\", binaryPath)\n    }\n    \n    // Check original exists\n    if _, err := os.Stat(binaryPath); os.IsNotExist(err) {\n        return fmt.Errorf(\"%s does not exist\", binaryPath)\n    }\n    \n    // Rename original to sidecar\n    if err := os.Rename(binaryPath, sidecar); err != nil {\n        return fmt.Errorf(\"failed to rename %s: %w\", binaryPath, err)\n    }\n    \n    // Create symlink\n    if err := os.Symlink(ribbinPath, binaryPath); err != nil {\n        // Rollback: restore original\n        os.Rename(sidecar, binaryPath)\n        return fmt.Errorf(\"failed to create symlink: %w\", err)\n    }\n    \n    // Update registry\n    registry.Shims[binaryPath] = ShimEntry{\n        Original: sidecar,\n        Config:   configPath,\n    }\n    \n    return nil\n}\n```\n\n### Uninstall Flow\n```go\nfunc Uninstall(binaryPath string, registry *Registry) error {\n    sidecar := SidecarPath(binaryPath)\n    \n    // Verify sidecar exists\n    if _, err := os.Stat(sidecar); os.IsNotExist(err) {\n        return fmt.Errorf(\"sidecar not found: %s\", sidecar)\n    }\n    \n    // Remove symlink\n    if err := os.Remove(binaryPath); err != nil {\n        return fmt.Errorf(\"failed to remove symlink: %w\", err)\n    }\n    \n    // Restore original\n    if err := os.Rename(sidecar, binaryPath); err != nil {\n        return fmt.Errorf(\"failed to restore original: %w\", err)\n    }\n    \n    // Update registry\n    delete(registry.Shims, binaryPath)\n    \n    return nil\n}\n```\n\n### FindSidecars\n- Search common binary directories: /usr/bin, /usr/local/bin, /opt/homebrew/bin, etc.\n- Use filepath.Glob with pattern `*.ribbin-original`\n- Return list of original binary paths (strip .ribbin-original suffix)\n\n## Permission Handling\n\n- Check write permission before attempting operations\n- Return clear error message if permission denied\n- Suggest `sudo ribbin shim` in error message\n\n## Tests\n\n- Test install creates symlink and sidecar\n- Test uninstall restores original\n- Test install rollback on symlink failure\n- Test permission denied handling\n- Test already-shimmed detection\n\n## Acceptance Criteria\n\n- Can shim and unshim a test binary\n- Registry is updated correctly\n- Rollback works if symlink creation fails\n- Clear error messages for permission issues","status":"closed","priority":1,"issue_type":"task","owner":"don@happycollision.com","created_at":"2026-01-17T22:03:29.139095-05:00","created_by":"Don Denton","updated_at":"2026-01-17T23:00:55.394422-05:00","closed_at":"2026-01-17T23:00:55.394422-05:00","close_reason":"Closed","dependencies":[{"issue_id":"ribbin-d9y","depends_on_id":"ribbin-skj","type":"parent-child","created_at":"2026-01-17T22:10:53.812426-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-d9y","depends_on_id":"ribbin-g2x","type":"blocks","created_at":"2026-01-17T22:12:14.937198-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-d9y","depends_on_id":"ribbin-pmw","type":"blocks","created_at":"2026-01-17T22:12:20.175342-05:00","created_by":"Don Denton"}]}
{"id":"ribbin-g2x","title":"Implement config layer: ribbin.json and registry parsing","description":"# Config Layer Implementation\n\nImplement parsing and discovery for project config and global registry.\n\n## Files to Create\n\n### internal/config/project.go\n\n```go\ntype ProjectConfig struct {\n    Shims map[string]ShimConfig `json:\"shims\"`\n}\n\ntype ShimConfig struct {\n    Action  string   `json:\"action\"`           // \"block\" for v1\n    Message string   `json:\"message\"`          // Error message to display\n    Paths   []string `json:\"paths,omitempty\"`  // Optional explicit paths\n}\n\n// FindProjectConfig walks up from PWD looking for ribbin.json\nfunc FindProjectConfig() (*ProjectConfig, string, error)\n\n// LoadProjectConfig loads config from a specific path\nfunc LoadProjectConfig(path string) (*ProjectConfig, error)\n```\n\n### internal/config/registry.go\n\n```go\ntype Registry struct {\n    Shims       map[string]ShimEntry       `json:\"shims\"`\n    Activations map[string]ActivationEntry `json:\"activations\"`\n    GlobalOn    bool                       `json:\"global_on\"`\n}\n\ntype ShimEntry struct {\n    Original string `json:\"original\"`  // Path to .ribbin-original sidecar\n    Config   string `json:\"config\"`    // Path to ribbin.json that created it\n}\n\ntype ActivationEntry struct {\n    PID         int       `json:\"pid\"`\n    ActivatedAt time.Time `json:\"activated_at\"`\n}\n\n// RegistryPath returns ~/.config/ribbin/registry.json\nfunc RegistryPath() string\n\n// LoadRegistry loads or creates empty registry\nfunc LoadRegistry() (*Registry, error)\n\n// SaveRegistry writes registry to disk\nfunc SaveRegistry(r *Registry) error\n```\n\n## Behavior\n\n### FindProjectConfig\n- Start at current working directory\n- Walk up parent directories\n- Look for `ribbin.json` at each level\n- Return config, config path, and error\n- Return error if not found (reaching root)\n\n### Registry Location\n- `~/.config/ribbin/registry.json`\n- Create directory if doesn't exist\n- Return empty registry if file doesn't exist\n\n## Tests\n\n- Test walking up directories to find config\n- Test missing config error\n- Test malformed JSON handling\n- Test registry creation when missing\n- Test registry persistence\n\n## Acceptance Criteria\n\n- Can discover ribbin.json from nested directories\n- Registry persists between runs\n- Graceful handling of missing/corrupt files","status":"closed","priority":1,"issue_type":"task","owner":"don@happycollision.com","created_at":"2026-01-17T22:02:41.288143-05:00","created_by":"Don Denton","updated_at":"2026-01-17T22:56:39.468271-05:00","closed_at":"2026-01-17T22:56:39.468271-05:00","close_reason":"Closed","dependencies":[{"issue_id":"ribbin-g2x","depends_on_id":"ribbin-skj","type":"parent-child","created_at":"2026-01-17T22:10:43.346535-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-g2x","depends_on_id":"ribbin-8n3","type":"blocks","created_at":"2026-01-17T22:11:59.223115-05:00","created_by":"Don Denton"}]}
{"id":"ribbin-jf8","title":"Implement 'ribbin shim' command","description":"# ribbin shim Command Implementation\n\nImplement the shim command that installs shims based on project config.\n\n## File to Modify\n\n### internal/cli/shim.go\n\n```go\nfunc runShim(cmd *cobra.Command, args []string) error {\n    // 1. Find nearest ribbin.json\n    cfg, configPath, err := config.FindProjectConfig()\n    if err != nil {\n        return fmt.Errorf(\"no ribbin.json found: %w\", err)\n    }\n    \n    fmt.Printf(\"Using config: %s\\n\", configPath)\n    \n    // 2. Load registry\n    registry, err := config.LoadRegistry()\n    if err != nil {\n        return fmt.Errorf(\"failed to load registry: %w\", err)\n    }\n    \n    // 3. Get ribbin binary path\n    ribbinPath, err := os.Executable()\n    if err != nil {\n        return fmt.Errorf(\"failed to get ribbin path: %w\", err)\n    }\n    // Resolve symlinks to get actual binary\n    ribbinPath, err = filepath.EvalSymlinks(ribbinPath)\n    if err != nil {\n        return fmt.Errorf(\"failed to resolve ribbin path: %w\", err)\n    }\n    \n    // 4. Process each shim in config\n    var shimmed, skipped, failed int\n    \n    for name, shimCfg := range cfg.Shims {\n        paths := shimCfg.Paths\n        if len(paths) == 0 {\n            // Resolve via which\n            resolved, err := shim.ResolveCommand(name)\n            if err != nil {\n                fmt.Printf(\"⚠ %s: command not found, skipping\\n\", name)\n                skipped++\n                continue\n            }\n            paths = []string{resolved}\n        }\n        \n        for _, p := range paths {\n            // Check if already shimmed\n            if shim.IsAlreadyShimmed(p) {\n                fmt.Printf(\"○ %s: already shimmed\\n\", p)\n                skipped++\n                continue\n            }\n            \n            // Install shim\n            if err := shim.Install(p, ribbinPath, registry, configPath); err != nil {\n                fmt.Printf(\"✗ %s: %v\\n\", p, err)\n                failed++\n            } else {\n                fmt.Printf(\"✓ %s: shimmed\\n\", p)\n                shimmed++\n            }\n        }\n    }\n    \n    // 5. Save registry\n    if err := config.SaveRegistry(registry); err != nil {\n        return fmt.Errorf(\"failed to save registry: %w\", err)\n    }\n    \n    // 6. Summary\n    fmt.Printf(\"\\nShimmed: %d, Skipped: %d, Failed: %d\\n\", shimmed, skipped, failed)\n    \n    if failed \u003e 0 {\n        return fmt.Errorf(\"%d shim(s) failed\", failed)\n    }\n    \n    return nil\n}\n```\n\n## Behavior\n\n1. Find nearest `ribbin.json` by walking up from PWD\n2. For each command in config:\n   - Use explicit `paths` if provided\n   - Otherwise resolve via `which`\n   - Skip if already shimmed\n   - Skip if command not found (with warning)\n   - Install shim (rename original, create symlink)\n3. Update global registry\n4. Print summary\n\n## Error Handling\n\n- No config found → clear error with hint to create ribbin.json\n- Permission denied → suggest running with sudo\n- Command not found → warning, continue with others\n- Already shimmed → skip silently or with note\n\n## Acceptance Criteria\n\n- Creates symlinks for all commands in config\n- Updates registry correctly\n- Handles missing commands gracefully\n- Reports clear summary\n- Works with explicit paths in config","status":"closed","priority":1,"issue_type":"task","owner":"don@happycollision.com","created_at":"2026-01-17T22:04:10.93236-05:00","created_by":"Don Denton","updated_at":"2026-01-17T23:06:51.993125-05:00","closed_at":"2026-01-17T23:06:51.993125-05:00","close_reason":"Closed","dependencies":[{"issue_id":"ribbin-jf8","depends_on_id":"ribbin-skj","type":"parent-child","created_at":"2026-01-17T22:11:04.300605-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-jf8","depends_on_id":"ribbin-1of","type":"blocks","created_at":"2026-01-17T22:12:25.428377-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-jf8","depends_on_id":"ribbin-d9y","type":"blocks","created_at":"2026-01-17T22:12:30.682229-05:00","created_by":"Don Denton"}]}
{"id":"ribbin-pmw","title":"Implement command resolver (which lookup)","description":"# Command Resolver Implementation\n\nResolve command names to their binary paths.\n\n## File to Create\n\n### internal/shim/resolver.go\n\n```go\n// ResolveCommand finds the path to a command using the system PATH\n// Similar to running `which \u003ccommand\u003e`\nfunc ResolveCommand(name string) (string, error)\n\n// ResolveCommands resolves multiple commands, returning map of name-\u003epath\n// Skips commands that can't be found (logs warning)\nfunc ResolveCommands(names []string) map[string]string\n```\n\n## Implementation Notes\n\n- Use `exec.LookPath(name)` from `os/exec` package\n- This finds the command the same way the shell would\n- Must handle case where command doesn't exist (return error)\n- Must handle case where command is already a symlink to ribbin (skip it)\n\n## Edge Cases\n\n- Command not found → return descriptive error\n- Command is already shimmed (symlink to ribbin) → detect and skip\n- Multiple commands with same name in PATH → returns first match (correct behavior)\n\n## Detection of Already-Shimmed\n\n```go\nfunc IsAlreadyShimmed(path string) (bool, error) {\n    // Check if path is a symlink\n    info, err := os.Lstat(path)\n    if err != nil {\n        return false, err\n    }\n    if info.Mode()\u0026os.ModeSymlink == 0 {\n        return false, nil // Not a symlink\n    }\n    \n    // Check if symlink points to ribbin\n    target, err := os.Readlink(path)\n    if err != nil {\n        return false, err\n    }\n    return filepath.Base(target) == \"ribbin\", nil\n}\n```\n\n## Tests\n\n- Test resolving common commands (ls, cat, echo)\n- Test command not found error\n- Test detecting already-shimmed binary\n\n## Acceptance Criteria\n\n- `ResolveCommand(\"cat\")` returns `/bin/cat` or similar\n- `ResolveCommand(\"nonexistent\")` returns error\n- Can detect if a binary is already a ribbin symlink","status":"closed","priority":2,"issue_type":"task","owner":"don@happycollision.com","created_at":"2026-01-17T22:03:02.035042-05:00","created_by":"Don Denton","updated_at":"2026-01-17T22:56:39.47062-05:00","closed_at":"2026-01-17T22:56:39.47062-05:00","close_reason":"Closed","dependencies":[{"issue_id":"ribbin-pmw","depends_on_id":"ribbin-skj","type":"parent-child","created_at":"2026-01-17T22:10:48.57734-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-pmw","depends_on_id":"ribbin-8n3","type":"blocks","created_at":"2026-01-17T22:12:04.452226-05:00","created_by":"Don Denton"}]}
{"id":"ribbin-skj","title":"Implement Ribbin - Go-based command shimming tool","description":"# Ribbin\n\nCommand shimming tool that replaces binaries with symlinks to a single Go binary.\n\n## How It Works\n\n1. **Single Go binary** (`ribbin`) handles both CLI commands and shim invocations\n2. **Symlinks replace target binaries**: `/usr/bin/cat` → `/usr/local/bin/ribbin`\n3. **Originals renamed to sidecars**: `/usr/bin/cat.ribbin-original`\n4. **Mode detection via `argv[0]`**: If invoked as \"ribbin\" → CLI mode, otherwise → shim mode\n5. **Shim checks PWD** for nearest `ribbin.json`, applies configured action or passes through\n\n## Commands\n\n| Command | Description |\n|---------|-------------|\n| `ribbin shim` | Replace binaries with symlinks based on nearest `ribbin.json` |\n| `ribbin unshim` | Restore originals from nearest config |\n| `ribbin unshim --all` | Restore all from global registry |\n| `ribbin unshim --all --search` | Find all sidecars system-wide, restore |\n| `ribbin activate` | Enable shims for this terminal session (tracks shell PID) |\n| `ribbin on` | Enable shims globally |\n| `ribbin off` | Disable shims globally |\n\n## Config Format (ribbin.json)\n\n```json\n{\n  \"shims\": {\n    \"tsc\": {\n      \"action\": \"block\",\n      \"message\": \"Use pnpm run typecheck instead\"\n    },\n    \"cat\": {\n      \"action\": \"block\",\n      \"message\": \"Use bat instead\",\n      \"paths\": [\"/usr/bin/cat\", \"/bin/cat\"]\n    }\n  }\n}\n```\n\n- Command names resolve via `which` by default\n- Optional `paths` array for explicit locations\n\n## Global Registry (~/.config/ribbin/registry.json)\n\n```json\n{\n  \"shims\": {\n    \"/usr/bin/cat\": {\n      \"original\": \"/usr/bin/cat.ribbin-original\",\n      \"config\": \"/path/to/project/ribbin.json\"\n    }\n  },\n  \"activations\": {\n    \"12345\": { \"pid\": 12345, \"activated_at\": \"...\" }\n  },\n  \"global_on\": false\n}\n```\n\n## Project Structure\n\n```\nribbin/\n├── cmd/ribbin/main.go           # Entry point, mode detection\n├── internal/\n│   ├── cli/                     # CLI commands (shim, unshim, activate, on, off)\n│   ├── config/                  # ribbin.json and registry parsing\n│   ├── shim/                    # Shim logic, installer, resolver\n│   └── process/                 # PID ancestry (darwin/linux)\n├── go.mod\n├── Makefile\n└── .goreleaser.yaml\n```\n\n## Shim Logic (when invoked as shimmed command)\n\n1. Get original path: argv[0] + \".ribbin-original\"\n2. Check RIBBIN_BYPASS=1 → passthrough\n3. Load registry, check if active:\n   - global_on=true → active\n   - ancestor PID in activations → active\n   - otherwise → passthrough\n4. If active, find nearest ribbin.json\n5. If command listed with action=block → show message, exit 1\n6. Otherwise → exec original\n\n## Dependencies\n\n- spf13/cobra - CLI framework\n- mitchellh/go-ps - Cross-platform process inspection (optional)\n\n## Performance Target\n\n\u003c3ms overhead per shimmed command invocation","status":"open","priority":1,"issue_type":"epic","owner":"don@happycollision.com","created_at":"2026-01-17T22:00:19.657078-05:00","created_by":"Don Denton","updated_at":"2026-01-17T22:19:24.076036-05:00"}
{"id":"ribbin-v8p","title":"Test issue for sync","status":"tombstone","priority":4,"issue_type":"task","owner":"don@happycollision.com","created_at":"2026-01-17T22:31:43.486738-05:00","created_by":"Don Denton","updated_at":"2026-01-17T22:32:49.349419-05:00","deleted_at":"2026-01-17T22:32:49.349419-05:00","deleted_by":"Don Denton","delete_reason":"delete","original_type":"task"}
{"id":"ribbin-w7k","title":"Implement PID ancestry checking (macOS and Linux)","description":"# PID Ancestry Implementation\n\nCheck if the current process is a descendant of a given PID.\n\n## Files to Create\n\n### internal/process/ancestry.go\n\n```go\npackage process\n\n// IsDescendantOf checks if the current process is a descendant of targetPID\n// by walking up the process tree via parent PIDs.\nfunc IsDescendantOf(targetPID int) (bool, error)\n\n// ProcessExists checks if a process with the given PID exists\nfunc ProcessExists(pid int) bool\n```\n\n### internal/process/ancestry_darwin.go\n\n```go\n//go:build darwin\n\npackage process\n\nimport (\n    \"os\"\n    \"syscall\"\n    \"unsafe\"\n)\n\nfunc IsDescendantOf(targetPID int) (bool, error) {\n    currentPID := os.Getpid()\n    \n    for currentPID \u003e 1 {\n        if currentPID == targetPID {\n            return true, nil\n        }\n        ppid, err := getParentPID(currentPID)\n        if err != nil {\n            return false, err\n        }\n        currentPID = ppid\n    }\n    return false, nil\n}\n\nfunc getParentPID(pid int) (int, error) {\n    // Use sysctl to get process info on macOS\n    // CTL_KERN, KERN_PROC, KERN_PROC_PID, pid\n    var info struct {\n        // kinfo_proc structure (simplified)\n        // We only need kp_eproc.e_ppid\n        _ [unsafe.Sizeof(syscall.Timeval{})*2]byte // kp_proc padding\n        // ... more fields\n        PPID int32\n        // ... rest of structure\n    }\n    \n    // Alternatively, use external package or exec \"ps -o ppid= -p \u003cpid\u003e\"\n    // For simplicity, let's use exec approach first:\n    \n    out, err := exec.Command(\"ps\", \"-o\", \"ppid=\", \"-p\", strconv.Itoa(pid)).Output()\n    if err != nil {\n        return 0, err\n    }\n    ppid, err := strconv.Atoi(strings.TrimSpace(string(out)))\n    if err != nil {\n        return 0, err\n    }\n    return ppid, nil\n}\n\nfunc ProcessExists(pid int) bool {\n    // On Unix, sending signal 0 checks if process exists\n    err := syscall.Kill(pid, 0)\n    return err == nil\n}\n```\n\n### internal/process/ancestry_linux.go\n\n```go\n//go:build linux\n\npackage process\n\nimport (\n    \"os\"\n    \"strconv\"\n    \"strings\"\n    \"syscall\"\n)\n\nfunc IsDescendantOf(targetPID int) (bool, error) {\n    currentPID := os.Getpid()\n    \n    for currentPID \u003e 1 {\n        if currentPID == targetPID {\n            return true, nil\n        }\n        ppid, err := getParentPID(currentPID)\n        if err != nil {\n            return false, err\n        }\n        currentPID = ppid\n    }\n    return false, nil\n}\n\nfunc getParentPID(pid int) (int, error) {\n    // Read /proc/\u003cpid\u003e/stat\n    data, err := os.ReadFile(fmt.Sprintf(\"/proc/%d/stat\", pid))\n    if err != nil {\n        return 0, err\n    }\n    \n    // Format: pid (comm) state ppid ...\n    // Find the closing paren (comm can contain spaces/parens)\n    s := string(data)\n    end := strings.LastIndex(s, \")\")\n    if end == -1 {\n        return 0, fmt.Errorf(\"invalid /proc/%d/stat format\", pid)\n    }\n    \n    fields := strings.Fields(s[end+2:]) // Skip \") \"\n    if len(fields) \u003c 2 {\n        return 0, fmt.Errorf(\"invalid /proc/%d/stat format\", pid)\n    }\n    \n    // fields[0] is state, fields[1] is ppid\n    ppid, err := strconv.Atoi(fields[1])\n    if err != nil {\n        return 0, err\n    }\n    \n    return ppid, nil\n}\n\nfunc ProcessExists(pid int) bool {\n    err := syscall.Kill(pid, 0)\n    return err == nil\n}\n```\n\n## Alternative: Use go-ps library\n\nIf implementing from scratch is too complex, use mitchellh/go-ps:\n\n```go\nimport \"github.com/mitchellh/go-ps\"\n\nfunc IsDescendantOf(targetPID int) (bool, error) {\n    currentPID := os.Getpid()\n    \n    for currentPID \u003e 1 {\n        if currentPID == targetPID {\n            return true, nil\n        }\n        proc, err := ps.FindProcess(currentPID)\n        if err != nil || proc == nil {\n            return false, err\n        }\n        currentPID = proc.PPid()\n    }\n    return false, nil\n}\n```\n\n## Tests\n\n- Test self-PID returns true (process is descendant of itself? Depends on definition)\n- Test PPID returns true\n- Test unrelated PID returns false\n- Test PID 1 (init) handling\n- Test non-existent PID\n\n## Acceptance Criteria\n\n- Works on macOS\n- Works on Linux\n- Handles process not found gracefully\n- Performance: \u003c1ms for typical tree depth (~5-10 levels)","status":"closed","priority":1,"issue_type":"task","owner":"don@happycollision.com","created_at":"2026-01-17T22:06:59.791425-05:00","created_by":"Don Denton","updated_at":"2026-01-17T22:56:39.469486-05:00","closed_at":"2026-01-17T22:56:39.469486-05:00","close_reason":"Closed","dependencies":[{"issue_id":"ribbin-w7k","depends_on_id":"ribbin-skj","type":"parent-child","created_at":"2026-01-17T22:11:19.96242-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-w7k","depends_on_id":"ribbin-8n3","type":"blocks","created_at":"2026-01-17T22:12:46.350086-05:00","created_by":"Don Denton"}]}
