{"id":"ribbin-0ct","title":"Implement extends reference parsing","description":"**Read epic ribbin-3gj for full context.**\n\nCreate new file internal/config/extends.go:\n\n```go\ntype ExtendsRef struct {\n    FilePath  string  // empty for same-file refs\n    Fragment  string  // \"root\" or \"root.scope-name\"\n    IsLocal   bool    // true for \"root\" / \"root.x\" references\n}\n\nfunc ParseExtendsRef(ref string, configDir string) (*ExtendsRef, error)\n```\n\nParse extends reference strings:\n- `\"root\"` → local, fragment=\"root\"\n- `\"root.backend\"` → local, fragment=\"root.backend\"\n- `\"../other.toml\"` → file path resolved relative to configDir, fragment=\"\" (entire file)\n- `\"./file.toml#root.x\"` → file path resolved, fragment=\"root.x\"\n- `\"/abs/path/ribbin.toml\"` → absolute path, fragment=\"\"\n\nRelative paths (starting with \"./\" or \"../\") resolve from the TOML file containing the extends.\n\nTests: Create internal/config/extends_test.go with parsing tests for all patterns.","status":"closed","priority":2,"issue_type":"task","owner":"don@happycollision.com","created_at":"2026-01-19T13:38:01.047663-05:00","created_by":"Don Denton","updated_at":"2026-01-19T14:14:59.801935-05:00","closed_at":"2026-01-19T14:14:59.801935-05:00","close_reason":"Implemented ExtendsRef struct and ParseExtendsRef function with comprehensive tests","dependencies":[{"issue_id":"ribbin-0ct","depends_on_id":"ribbin-3gj","type":"parent-child","created_at":"2026-01-19T13:38:47.155077-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-0ct","depends_on_id":"ribbin-6o5","type":"blocks","created_at":"2026-01-19T13:39:17.47374-05:00","created_by":"Don Denton"}]}
{"id":"ribbin-0d3","title":"Add LICENSE file","description":"# Add LICENSE file\n\nCreate an MIT License file for the ribbin project.\n\n## File: LICENSE\n\n```\nMIT License\n\nCopyright (c) 2026 Don Denton\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n```\n\n## Acceptance Criteria\n- LICENSE file exists at repo root\n- Uses MIT license\n- Copyright holder: Don Denton\n- Year: 2026","status":"closed","priority":3,"issue_type":"task","owner":"don@happycollision.com","created_at":"2026-01-17T23:36:10.714209-05:00","created_by":"Don Denton","updated_at":"2026-01-17T23:46:18.404826-05:00","closed_at":"2026-01-17T23:46:18.404826-05:00","close_reason":"Implemented all release infrastructure files"}
{"id":"ribbin-0m8","title":"Add GitHub Actions release workflow","description":"# Add GitHub Actions release workflow\n\nCreate CI/CD workflows using GoReleaser for automated releases.\n\n## Files to create\n\n### .github/workflows/release.yml\n\nTriggered on version tags (v*). Uses GoReleaser for cross-compilation.\n\n```yaml\nname: Release\non:\n  push:\n    tags: ['v*']\n\npermissions:\n  contents: write\n\njobs:\n  release:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n        with:\n          fetch-depth: 0\n      - uses: actions/setup-go@v5\n        with:\n          go-version: '1.23'\n      - uses: goreleaser/goreleaser-action@v6\n        with:\n          args: release --clean\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n```\n\n### .goreleaser.yaml\n\n```yaml\nversion: 2\n\nbuilds:\n  - main: ./cmd/ribbin\n    binary: ribbin\n    goos: [linux, darwin]\n    goarch: [amd64, arm64]\n    ldflags:\n      - -s -w\n\narchives:\n  - format: tar.gz\n    name_template: \"{{ .ProjectName }}_{{ .Version }}_{{ .Os }}_{{ .Arch }}\"\n\nchecksum:\n  name_template: 'checksums.txt'\n  algorithm: sha256\n\nrelease:\n  github:\n    owner: happycollision\n    name: ribbin\n```\n\n### .github/workflows/ci.yml\n\nPR checks - run tests on push/PR.\n\n```yaml\nname: CI\non: [push, pull_request]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-go@v5\n        with:\n          go-version: '1.23'\n      - run: make test\n```\n\n## Platforms\n- linux/amd64\n- linux/arm64\n- darwin/amd64\n- darwin/arm64\n\n## Acceptance Criteria\n- .github/workflows/release.yml exists\n- .github/workflows/ci.yml exists\n- .goreleaser.yaml exists\n- CI runs on push/PR\n- Release triggers on v* tags\n- Builds for all 4 platform combinations\n- Generates SHA256 checksums\n- Creates GitHub release with assets","status":"closed","priority":2,"issue_type":"task","owner":"don@happycollision.com","created_at":"2026-01-17T23:36:13.781512-05:00","created_by":"Don Denton","updated_at":"2026-01-17T23:46:18.407898-05:00","closed_at":"2026-01-17T23:46:18.407898-05:00","close_reason":"Implemented all release infrastructure files"}
{"id":"ribbin-1ar","title":"Add bash installer script","description":"# Add bash installer script\n\nCreate an install.sh script for easy installation of ribbin.\n\n## File: install.sh\n\nFeatures:\n- Detect OS (darwin/linux)\n- Detect architecture (amd64/arm64)\n- Download pre-built binary from GitHub releases (happycollision/ribbin)\n- Verify SHA256 checksum for security\n- Install to ~/.local/bin (no sudo required)\n- Add PATH hint if ~/.local/bin not in PATH\n\n## Usage\n\n```bash\ncurl -fsSL https://raw.githubusercontent.com/happycollision/ribbin/main/install.sh | bash\n```\n\n## Script outline\n\n```bash\n#\\!/bin/bash\nset -euo pipefail\n\nREPO=\"happycollision/ribbin\"\nINSTALL_DIR=\"${HOME}/.local/bin\"\n\n# Detect OS\nOS=$(uname -s | tr '[:upper:]' '[:lower:]')\n\n# Detect arch\nARCH=$(uname -m)\ncase $ARCH in\n  x86_64) ARCH=\"amd64\" ;;\n  aarch64|arm64) ARCH=\"arm64\" ;;\nesac\n\n# Get latest version\nVERSION=$(curl -sL \"https://api.github.com/repos/${REPO}/releases/latest\" | grep tag_name | cut -d'\"' -f4)\n\n# Download and verify\n# Install to INSTALL_DIR\n# Check PATH\n```\n\n## Acceptance Criteria\n- install.sh exists at repo root\n- Detects OS (darwin, linux)\n- Detects architecture (amd64, arm64)\n- Downloads from GitHub releases\n- Verifies SHA256 checksum\n- Installs to ~/.local/bin\n- Prints PATH warning if needed\n- Script is executable (chmod +x)","status":"closed","priority":2,"issue_type":"task","owner":"don@happycollision.com","created_at":"2026-01-17T23:36:12.092185-05:00","created_by":"Don Denton","updated_at":"2026-01-17T23:46:18.408994-05:00","closed_at":"2026-01-17T23:46:18.408994-05:00","close_reason":"Implemented all release infrastructure files"}
{"id":"ribbin-1jy","title":"Add tests for all components","description":"# Test Suite Implementation\n\nComprehensive tests for all ribbin components.\n\n## ⚠️ IMPORTANT: Docker-based Testing\n\n**All tests MUST run inside a Docker container** to prevent any risk of damaging the developer's machine. The shim installer modifies binaries and creates symlinks - running tests directly on the host could corrupt system binaries.\n\n### Docker Test Setup\n\n```dockerfile\n# Dockerfile.test\nFROM golang:1.21-alpine\n\nRUN apk add --no-cache bash coreutils\n\nWORKDIR /app\nCOPY . .\n\nRUN go mod download\nCMD [\"go\", \"test\", \"-v\", \"./...\"]\n```\n\n### Running Tests\n\n```bash\n# Build test container\ndocker build -f Dockerfile.test -t ribbin-test .\n\n# Run unit tests\ndocker run --rm ribbin-test\n\n# Run with coverage\ndocker run --rm ribbin-test go test -cover ./...\n\n# Run integration tests\ndocker run --rm ribbin-test go test -tags=integration ./...\n\n# Interactive debugging\ndocker run --rm -it ribbin-test sh\n```\n\n### Makefile Targets\n\n```makefile\ntest:\n\tdocker build -f Dockerfile.test -t ribbin-test .\n\tdocker run --rm ribbin-test\n\ntest-coverage:\n\tdocker run --rm ribbin-test go test -cover ./...\n\ntest-integration:\n\tdocker run --rm ribbin-test go test -tags=integration -v ./...\n```\n\n## Test Files to Create\n\n### internal/config/project_test.go\n\n```go\nfunc TestFindProjectConfig(t *testing.T) {\n    // Test walking up directories\n    // Test config not found (reaches root)\n    // Test malformed JSON\n}\n\nfunc TestLoadProjectConfig(t *testing.T) {\n    // Test valid config\n    // Test missing file\n    // Test invalid JSON\n    // Test missing required fields\n}\n```\n\n### internal/config/registry_test.go\n\n```go\nfunc TestLoadRegistry(t *testing.T) {\n    // Test new registry creation\n    // Test existing registry load\n    // Test corrupt registry handling\n}\n\nfunc TestSaveRegistry(t *testing.T) {\n    // Test creates directory if missing\n    // Test overwrites existing\n}\n\nfunc TestPruneDeadActivations(t *testing.T) {\n    // Test removes dead PIDs\n    // Test keeps live PIDs\n}\n```\n\n### internal/shim/resolver_test.go\n\n```go\nfunc TestResolveCommand(t *testing.T) {\n    // Test common commands (ls, echo)\n    // Test command not found\n}\n\nfunc TestIsAlreadyShimmed(t *testing.T) {\n    // Test regular binary → false\n    // Test symlink to ribbin → true\n    // Test symlink to other → false\n}\n```\n\n### internal/shim/installer_test.go\n\n```go\nfunc TestInstall(t *testing.T) {\n    // Test creates symlink\n    // Test renames original\n    // Test updates registry\n    // Test rollback on failure\n}\n\nfunc TestUninstall(t *testing.T) {\n    // Test removes symlink\n    // Test restores original\n    // Test updates registry\n}\n\nfunc TestFindSidecars(t *testing.T) {\n    // Test finds sidecars in directory\n    // Test handles missing directory\n}\n```\n\n### internal/shim/runner_test.go\n\n```go\nfunc TestRun(t *testing.T) {\n    // These are tricky because Run calls syscall.Exec\n    // May need to test individual functions instead\n}\n\nfunc TestIsActive(t *testing.T) {\n    // Test global on\n    // Test activation match\n    // Test no match\n}\n```\n\n### internal/process/ancestry_test.go\n\n```go\nfunc TestIsDescendantOf(t *testing.T) {\n    // Test self PID\n    // Test parent PID\n    // Test unrelated PID\n}\n\nfunc TestProcessExists(t *testing.T) {\n    // Test current process → true\n    // Test PID 1 → true\n    // Test non-existent PID → false\n}\n```\n\n## Integration Tests\n\n### internal/integration_test.go\n\n```go\n//go:build integration\n\nfunc TestFullShimCycle(t *testing.T) {\n    // 1. Create temp directory with test binary\n    // 2. Create ribbin.json\n    // 3. Run shim command\n    // 4. Verify symlink created\n    // 5. Run shimmed command (should passthrough - not active)\n    // 6. Run 'ribbin on'\n    // 7. Run shimmed command (should block)\n    // 8. Run with RIBBIN_BYPASS=1 (should work)\n    // 9. Run unshim\n    // 10. Verify original restored\n}\n```\n\n## Test Utilities\n\n### internal/testutil/testutil.go\n\n```go\npackage testutil\n\n// CreateTempBinary creates a simple executable script for testing\nfunc CreateTempBinary(t *testing.T, name string) string\n\n// CreateTempConfig creates a ribbin.json in a temp directory\nfunc CreateTempConfig(t *testing.T, cfg *config.ProjectConfig) string\n\n// CleanupTempDir removes temp directory after test\nfunc CleanupTempDir(t *testing.T, dir string)\n```\n\n## Test Fixtures\n\n```\ntestdata/\n├── configs/\n│   ├── valid.json\n│   ├── invalid.json\n│   └── minimal.json\n└── projects/\n    ├── basic/\n    │   └── ribbin.json\n    └── nested/\n        ├── ribbin.json\n        └── subdir/\n```\n\n## Acceptance Criteria\n\n- All packages have tests\n- **All tests run in Docker container** (never on host machine)\n- Tests pass on Linux (Docker container)\n- Code coverage \u003e 70%\n- Integration test covers full workflow\n- `make test` runs everything safely in Docker","status":"closed","priority":2,"issue_type":"task","owner":"don@happycollision.com","created_at":"2026-01-17T22:09:33.238988-05:00","created_by":"Don Denton","updated_at":"2026-01-17T23:31:16.932901-05:00","closed_at":"2026-01-17T23:31:16.932901-05:00","close_reason":"Implemented comprehensive test suite with Docker-based testing. All tests pass. Coverage: config 86%, process 83%, shim 66%, cli 23%. Integration tests verify full shim cycle.","dependencies":[{"issue_id":"ribbin-1jy","depends_on_id":"ribbin-skj","type":"parent-child","created_at":"2026-01-17T22:11:35.675979-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-1jy","depends_on_id":"ribbin-jf8","type":"blocks","created_at":"2026-01-17T22:13:28.249372-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-1jy","depends_on_id":"ribbin-5tf","type":"blocks","created_at":"2026-01-17T22:13:33.466402-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-1jy","depends_on_id":"ribbin-1n6","type":"blocks","created_at":"2026-01-17T22:13:38.685713-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-1jy","depends_on_id":"ribbin-9pw","type":"blocks","created_at":"2026-01-17T22:13:43.892205-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-1jy","depends_on_id":"ribbin-85g","type":"blocks","created_at":"2026-01-17T22:13:49.106936-05:00","created_by":"Don Denton"}]}
{"id":"ribbin-1n6","title":"Implement shim runner (core blocking logic)","description":"# Shim Runner Implementation\n\nThe core logic that runs when a shimmed command is invoked.\n\n## File to Create\n\n### internal/shim/runner.go\n\n```go\npackage shim\n\nimport (\n    \"fmt\"\n    \"os\"\n    \"path/filepath\"\n    \"syscall\"\n    \n    \"github.com/user/ribbin/internal/config\"\n    \"github.com/user/ribbin/internal/process\"\n)\n\n// Run executes when ribbin is invoked as a shimmed command\nfunc Run(argv0 string, args []string) {\n    originalPath := argv0 + \".ribbin-original\"\n    \n    // 1. Verify sidecar exists\n    if _, err := os.Stat(originalPath); os.IsNotExist(err) {\n        fatal(\"Sidecar not found: %s\\nRun 'ribbin unshim --all --search' to repair\", originalPath)\n    }\n    \n    // 2. Check bypass environment variable\n    if os.Getenv(\"RIBBIN_BYPASS\") == \"1\" {\n        execOriginal(originalPath, args)\n        return\n    }\n    \n    // 3. Load registry and check activation state\n    registry, err := config.LoadRegistry()\n    if err != nil || registry == nil {\n        // Registry missing/corrupt - passthrough for safety\n        execOriginal(originalPath, args)\n        return\n    }\n    \n    // 4. Check if shims are active\n    if !isActive(registry) {\n        execOriginal(originalPath, args)\n        return\n    }\n    \n    // 5. Find project config\n    cfg, _, err := config.FindProjectConfig()\n    if err != nil {\n        // No config in directory tree - passthrough\n        execOriginal(originalPath, args)\n        return\n    }\n    \n    // 6. Check if this command is configured\n    cmdName := filepath.Base(argv0)\n    shimCfg, found := cfg.Shims[cmdName]\n    if !found {\n        execOriginal(originalPath, args)\n        return\n    }\n    \n    // 7. Apply action\n    switch shimCfg.Action {\n    case \"block\":\n        printBlockMessage(cmdName, shimCfg.Message)\n        os.Exit(1)\n    default:\n        // Unknown action - passthrough\n        execOriginal(originalPath, args)\n    }\n}\n\nfunc isActive(registry *config.Registry) bool {\n    // Global on?\n    if registry.GlobalOn {\n        return true\n    }\n    \n    // Check for activation ancestry (is current process a child of an activated shell?)\n    for _, entry := range registry.Activations {\n        if isDescendant, _ := process.IsDescendantOf(entry.PID); isDescendant {\n            return true\n        }\n    }\n    \n    // Prune dead activations while we're here\n    registry.PruneDeadActivations()\n    \n    return false\n}\n\nfunc execOriginal(path string, args []string) {\n    argv := append([]string{path}, args...)\n    env := os.Environ()\n    \n    if err := syscall.Exec(path, argv, env); err != nil {\n        fatal(\"Failed to exec %s: %v\", path, err)\n    }\n}\n\nfunc printBlockMessage(cmd, message string) {\n    fmt.Fprintf(os.Stderr, \"\\n\")\n    fmt.Fprintf(os.Stderr, \"┌─────────────────────────────────────────────────────────┐\\n\")\n    fmt.Fprintf(os.Stderr, \"│  ERROR: Direct use of '%s' is blocked.%s│\\n\", cmd, padding(cmd))\n    fmt.Fprintf(os.Stderr, \"│                                                         │\\n\")\n    fmt.Fprintf(os.Stderr, \"│  %s%s│\\n\", message, padding(message))\n    fmt.Fprintf(os.Stderr, \"│                                                         │\\n\")\n    fmt.Fprintf(os.Stderr, \"│  Bypass: RIBBIN_BYPASS=1 %s ...%s│\\n\", cmd, padding(cmd))\n    fmt.Fprintf(os.Stderr, \"└─────────────────────────────────────────────────────────┘\\n\")\n    fmt.Fprintf(os.Stderr, \"\\n\")\n}\n\nfunc padding(s string) string {\n    // Pad to fit in 55-char box\n    pad := 55 - len(s) - 2\n    if pad \u003c 1 {\n        pad = 1\n    }\n    return strings.Repeat(\" \", pad)\n}\n\nfunc fatal(format string, args ...interface{}) {\n    fmt.Fprintf(os.Stderr, \"ribbin: \"+format+\"\\n\", args...)\n    os.Exit(1)\n}\n```\n\n## Flow Summary\n\n```\nargv[0] = /usr/bin/cat\n       ↓\nsidecar exists? (/usr/bin/cat.ribbin-original)\n       ↓ yes\nRIBBIN_BYPASS=1? → passthrough\n       ↓ no\nload registry\n       ↓\nis active? (global_on OR ancestor PID in activations)\n       ↓ no → passthrough\n       ↓ yes\nfind ribbin.json (walk up from PWD)\n       ↓ not found → passthrough\n       ↓ found\ncommand in config? (\"cat\" in shims)\n       ↓ no → passthrough\n       ↓ yes\naction = \"block\" → print message, exit 1\n```\n\n## Performance Considerations\n\n- Fast path for inactive state (just check registry.GlobalOn and activations length)\n- Only load project config if active\n- syscall.Exec replaces process (no subprocess overhead)\n\n## Tests\n\n- Test passthrough when inactive\n- Test blocking when active\n- Test bypass environment variable\n- Test missing sidecar error\n- Test no config in tree → passthrough\n- Test command not in config → passthrough\n\n## Acceptance Criteria\n\n- Blocks commands when active and configured\n- Passes through when inactive\n- Passes through when no config found\n- RIBBIN_BYPASS=1 always passes through\n- Error message is clear and helpful","status":"closed","priority":1,"issue_type":"task","owner":"don@happycollision.com","created_at":"2026-01-17T22:05:12.707848-05:00","created_by":"Don Denton","updated_at":"2026-01-17T23:00:55.395978-05:00","closed_at":"2026-01-17T23:00:55.395978-05:00","close_reason":"Closed","dependencies":[{"issue_id":"ribbin-1n6","depends_on_id":"ribbin-skj","type":"parent-child","created_at":"2026-01-17T22:11:14.717471-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-1n6","depends_on_id":"ribbin-g2x","type":"blocks","created_at":"2026-01-17T22:12:51.594972-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-1n6","depends_on_id":"ribbin-w7k","type":"blocks","created_at":"2026-01-17T22:12:56.837226-05:00","created_by":"Don Denton"}]}
{"id":"ribbin-1of","title":"Implement CLI framework with Cobra","description":"# CLI Framework Implementation\n\nSet up the CLI structure using Cobra.\n\n## Files to Create\n\n### internal/cli/cli.go\n\n```go\npackage cli\n\nimport (\n    \"github.com/spf13/cobra\"\n)\n\nvar rootCmd = \u0026cobra.Command{\n    Use:   \"ribbin\",\n    Short: \"Command shimming tool\",\n    Long:  \"Ribbin replaces binaries with shims that can block or redirect commands based on project configuration.\",\n}\n\nfunc Execute() error {\n    return rootCmd.Execute()\n}\n\nfunc init() {\n    rootCmd.AddCommand(shimCmd)\n    rootCmd.AddCommand(unshimCmd)\n    rootCmd.AddCommand(activateCmd)\n    rootCmd.AddCommand(onCmd)\n    rootCmd.AddCommand(offCmd)\n}\n```\n\n### cmd/ribbin/main.go\n\n```go\npackage main\n\nimport (\n    \"os\"\n    \"path/filepath\"\n    \n    \"github.com/user/ribbin/internal/cli\"\n    \"github.com/user/ribbin/internal/shim\"\n)\n\nfunc main() {\n    invoked := filepath.Base(os.Args[0])\n    \n    // If invoked as \"ribbin\", run CLI mode\n    if invoked == \"ribbin\" {\n        if err := cli.Execute(); err != nil {\n            os.Exit(1)\n        }\n        return\n    }\n    \n    // Otherwise, we're being invoked as a shimmed command\n    shim.Run(os.Args[0], os.Args[1:])\n}\n```\n\n## Command Stubs\n\nCreate stub files for each command (implementation in separate tasks):\n\n### internal/cli/shim.go\n```go\nvar shimCmd = \u0026cobra.Command{\n    Use:   \"shim\",\n    Short: \"Install shims for commands in ribbin.json\",\n    RunE:  runShim,\n}\n\nfunc runShim(cmd *cobra.Command, args []string) error {\n    // TODO: implement\n    return nil\n}\n```\n\n### internal/cli/unshim.go\n```go\nvar unshimCmd = \u0026cobra.Command{\n    Use:   \"unshim\",\n    Short: \"Remove shims and restore original binaries\",\n    RunE:  runUnshim,\n}\n\nvar unshimAll bool\nvar unshimSearch bool\n\nfunc init() {\n    unshimCmd.Flags().BoolVar(\u0026unshimAll, \"all\", false, \"Restore all shimmed commands from registry\")\n    unshimCmd.Flags().BoolVar(\u0026unshimSearch, \"search\", false, \"Search filesystem for sidecars (use with --all)\")\n}\n\nfunc runUnshim(cmd *cobra.Command, args []string) error {\n    // TODO: implement\n    return nil\n}\n```\n\n### internal/cli/activate.go\n```go\nvar activateCmd = \u0026cobra.Command{\n    Use:   \"activate\",\n    Short: \"Enable shims for this terminal session\",\n    RunE:  runActivate,\n}\n\nfunc runActivate(cmd *cobra.Command, args []string) error {\n    // TODO: implement\n    return nil\n}\n```\n\n### internal/cli/on.go\n```go\nvar onCmd = \u0026cobra.Command{\n    Use:   \"on\",\n    Short: \"Enable shims globally\",\n    RunE:  runOn,\n}\n\nfunc runOn(cmd *cobra.Command, args []string) error {\n    // TODO: implement\n    return nil\n}\n```\n\n### internal/cli/off.go\n```go\nvar offCmd = \u0026cobra.Command{\n    Use:   \"off\",\n    Short: \"Disable shims globally\",\n    RunE:  runOff,\n}\n\nfunc runOff(cmd *cobra.Command, args []string) error {\n    // TODO: implement\n    return nil\n}\n```\n\n## Acceptance Criteria\n\n- `ribbin --help` shows all commands\n- `ribbin shim --help` shows shim help\n- Mode detection works (ribbin vs shimmed command)\n- All command stubs compile","status":"closed","priority":1,"issue_type":"task","owner":"don@happycollision.com","created_at":"2026-01-17T22:03:49.513518-05:00","created_by":"Don Denton","updated_at":"2026-01-17T22:56:39.466549-05:00","closed_at":"2026-01-17T22:56:39.466549-05:00","close_reason":"Closed","dependencies":[{"issue_id":"ribbin-1of","depends_on_id":"ribbin-skj","type":"parent-child","created_at":"2026-01-17T22:10:59.051091-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-1of","depends_on_id":"ribbin-8n3","type":"blocks","created_at":"2026-01-17T22:12:09.697265-05:00","created_by":"Don Denton"}]}
{"id":"ribbin-2h9","title":"Local Development Mode for safe package distribution","description":"# Local Development Mode\n\nAdd automatic \"Local Development Mode\" that restricts shimming to repo-local binaries only. When ribbin detects it is installed inside a git repository (typical for npm/pip/bundler dev dependencies), it automatically limits shimming to binaries within that same repo.\n\n**Threat model**: A malicious or misconfigured package could use ribbin to shim system binaries when installed as a dev dependency. Local Development Mode prevents this by scoping shims to the project.\n\n## Detection Logic\n\n```\nIs ribbin's own executable inside a git repository?\n├─ YES → Local Development Mode (can only shim binaries in same repo)\n└─ NO  → Normal mode (existing security rules apply)\n```\n\n**Why this works across ecosystems:**\n- npm local: `/project/node_modules/.bin/ribbin` → inside `/project/.git` ✅\n- npm global: `/usr/local/lib/node_modules/.bin/ribbin` → no .git nearby ❌\n- pip venv: `/project/.venv/bin/ribbin` → inside `/project/.git` ✅\n- pip global: `/usr/local/bin/ribbin` → no .git nearby ❌\n- bundler local: `/project/vendor/bundle/bin/ribbin` → inside `/project/.git` ✅\n\n## Design Decisions\n\n| Decision | Choice |\n|----------|--------|\n| Detection | Walk up from `os.Executable()` looking for `.git` directory |\n| Scope limit | Binaries must be within the detected git repo root |\n| Override | **None** - if detected as dev dep, restriction is mandatory |\n| Config | No config option to disable (intentional for security) |\n\n## Implementation\n\n### 1. New file: `internal/security/localdev.go`\n\n```go\n// LocalDevContext represents the local development mode state\ntype LocalDevContext struct {\n    IsLocalDev bool      // true if ribbin is inside a git repo\n    RepoRoot   string    // absolute path to git repo root\n    RibbinPath string    // resolved path to ribbin executable\n}\n\nfunc DetectLocalDevMode() (*LocalDevContext, error)\nfunc (ctx *LocalDevContext) ValidateBinaryPath(binaryPath string) error\nfunc findGitRoot(startPath string) string\n```\n\n### 2. Modify: `internal/cli/shim.go`\n\nAdd local dev mode check before shimming each binary:\n- Detect mode early in command execution\n- Before `ValidateBinaryForShim()`, check `localDevCtx.ValidateBinaryPath()`\n- On violation, skip with clear error message\n\n### 3. Error message format\n\n```\nLocal Development Mode active\n  ribbin location: /project/node_modules/.bin/ribbin\n  repository root: /project\n\nCannot shim '/usr/local/bin/tsc': path is outside repository\n  Use a repo-local binary instead (e.g., ./node_modules/.bin/tsc)\n```\n\n## Files to Modify\n\n| File | Change |\n|------|--------|\n| `internal/security/localdev.go` | NEW - detection/validation |\n| `internal/security/localdev_test.go` | NEW - tests |\n| `internal/cli/shim.go` | Integrate validation |\n| `CLAUDE.md` | Document feature |\n\n## Non-Goals (Intentionally Excluded)\n\n- **Config override**: No `[security].local_dev_mode = false`\n- **CLI flag**: No `--disable-local-dev`\n- **Allowed external paths**: Cannot allowlist paths outside the repo\n\nThese are excluded because the whole point is protecting developers from malicious packages. Any escape hatch defeats the purpose.\n\n## Verification\n\n1. Build: `make build`\n2. Test local dev detection with mock dev dependency install\n3. Test repo-local binary works\n4. Test global install has no restriction\n5. Run tests: `make test`","status":"closed","priority":3,"issue_type":"feature","owner":"don@happycollision.com","created_at":"2026-01-19T00:27:57.637065-05:00","created_by":"Don Denton","updated_at":"2026-01-20T00:04:07.650326-05:00","closed_at":"2026-01-20T00:04:07.650326-05:00","close_reason":"Implemented Local Development Mode with 4 commits: test safety infrastructure, localdev.go, CLI integration, and documentation"}
{"id":"ribbin-2y7","title":"Add integration tests for scopes and extends","description":"**Read epic ribbin-3gj for full context.**\n\nCreate test fixtures in testdata/projects/scoped/:\n\n1. Basic scoped config (isolated scope with path)\n2. Scope extending root\n3. Scope extending another scope\n4. External extends (separate ribbin.toml file)\n5. Fragment extends (./file.toml#root.scope)\n6. Passthrough override\n\nIntegration test scenarios:\n- Isolated scope blocks command\n- Extended scope inherits + overrides\n- External extends loads and merges\n- Passthrough overrides block\n- `ribbin config show` displays correct provenance\n\nEnsure `make test-integration` passes.","status":"closed","priority":2,"issue_type":"task","owner":"don@happycollision.com","created_at":"2026-01-19T13:38:22.45646-05:00","created_by":"Don Denton","updated_at":"2026-01-19T22:30:38.861564-05:00","closed_at":"2026-01-19T22:30:38.861564-05:00","close_reason":"Added integration test fixtures and comprehensive tests for scopes, extends, provenance, and end-to-end scoped blocking","dependencies":[{"issue_id":"ribbin-2y7","depends_on_id":"ribbin-3gj","type":"parent-child","created_at":"2026-01-19T13:39:08.147981-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-2y7","depends_on_id":"ribbin-8hb","type":"blocks","created_at":"2026-01-19T13:39:38.464607-05:00","created_by":"Don Denton"}]}
{"id":"ribbin-3gj","title":"Scopes and Extends for ribbin.toml","description":"Add scoped shim configurations with explicit inheritance via `extends`. Scopes are isolated by default. Extension is opt-in and fully explicit.\n\n## TOML Syntax\n\n```toml\n# Root-level shims\n[shims.cat]\naction = \"block\"\nmessage = \"Use bat\"\n\n# Scope with path (applies when CWD is within apps/frontend)\n[scopes.frontend]\npath = \"apps/frontend\"\n\n[scopes.frontend.shims.npm]\naction = \"block\"\nmessage = \"Use pnpm\"\n\n# Scope without path (defaults to \".\", same as config dir)\n# Can be used as a mixin via extends\n[scopes.strict-mode]\n\n[scopes.strict-mode.shims.rm]\naction = \"block\"\nmessage = \"Use trash instead\"\n\n# Scope that extends root + another scope\n[scopes.backend]\npath = \"apps/backend\"\nextends = [\"root\", \"root.strict-mode\"]\n\n[scopes.backend.shims.yarn]\naction = \"block\"\nmessage = \"Use npm in backend\"\n\n# Scope extending external file\n[scopes.shared]\npath = \"libs/shared\"\nextends = [\"../team-standards/ribbin.toml\"]\n\n# Scope extending specific scope from external file\n[scopes.react-app]\npath = \"apps/web\"\nextends = [\"./ribbin.fe.toml#root.react\"]\n```\n\n## Extends Syntax\n\n| Pattern | Meaning |\n|---------|---------|\n| `\"root\"` | Root shims from same file |\n| `\"root.scope-name\"` | Specific scope from same file |\n| `\"/abs/path/ribbin.toml\"` | Entire external file (root + all scopes) |\n| `\"../rel/path/ribbin.toml\"` | Entire external file (relative) |\n| `\"./file.toml#root\"` | Only root shims from external file |\n| `\"./file.toml#root.scope\"` | Specific scope from external file |\n\n**Relative paths:** Always resolve from the TOML file containing the `extends`.\n\n**Merge order:** Earlier entries are base, later entries override. Own shims override all extends.\n\n## Core Rules\n\n1. **Isolation by default:** Scopes have no implicit inheritance\n2. **Explicit extends:** Use `extends = [...]` to pull in shims\n3. **Path defaults to \".\":** Scopes without `path` apply to config directory\n4. **Merge order:** `extends[0]` \u003c `extends[1]` \u003c ... \u003c own shims (last wins)\n5. **Full inheritance:** Extended scopes bring their own extends recursively\n\n## Resolution Algorithm\n\n1. Walk up from CWD to find nearest ribbin.toml\n2. Load config\n3. Find matching scope (CWD within scope.path, deepest wins)\n4. If no scope matches, use root shims\n5. Resolve effective shims:\n   a. Start with empty map\n   b. For each entry in extends (in order):\n      - Resolve the reference (may load external file)\n      - Recursively resolve that target's extends\n      - Merge shims (later overrides earlier)\n   c. Merge scope's own shims (overrides all)\n6. Look up command in effective shims","status":"closed","priority":1,"issue_type":"epic","owner":"don@happycollision.com","created_at":"2026-01-19T13:35:26.762421-05:00","created_by":"Don Denton","updated_at":"2026-01-19T22:31:06.44751-05:00","closed_at":"2026-01-19T22:31:06.44751-05:00","close_reason":"All subtasks complete: ScopeConfig, extends parsing, resolver, runner integration, config show command, and integration tests"}
{"id":"ribbin-48m","title":"Polish: colored output, error messages, and UX","description":"# Polish and UX Improvements\n\nFinal polish for user experience.\n\n## Colored Output\n\n### internal/output/output.go\n\n```go\npackage output\n\nimport (\n    \"fmt\"\n    \"os\"\n    \n    \"github.com/fatih/color\"\n)\n\nvar (\n    successColor = color.New(color.FgGreen)\n    errorColor   = color.New(color.FgRed)\n    warnColor    = color.New(color.FgYellow)\n    infoColor    = color.New(color.FgCyan)\n)\n\nfunc Success(format string, args ...interface{}) {\n    successColor.Fprintf(os.Stderr, \"✓ \"+format+\"\\n\", args...)\n}\n\nfunc Error(format string, args ...interface{}) {\n    errorColor.Fprintf(os.Stderr, \"✗ \"+format+\"\\n\", args...)\n}\n\nfunc Warn(format string, args ...interface{}) {\n    warnColor.Fprintf(os.Stderr, \"⚠ \"+format+\"\\n\", args...)\n}\n\nfunc Info(format string, args ...interface{}) {\n    infoColor.Fprintf(os.Stderr, format+\"\\n\", args...)\n}\n```\n\n## Improved Error Messages\n\n### Permission Denied\n```\n✗ Cannot shim /usr/bin/cat: permission denied\n\n  System binaries require elevated privileges.\n  Run: sudo ribbin shim\n```\n\n### No Config Found\n```\n✗ No ribbin.json found in directory tree\n\n  Create one with:\n    echo '{\"shims\":{\"tsc\":{\"action\":\"block\",\"message\":\"Use pnpm typecheck\"}}}' \u003e ribbin.json\n```\n\n### Command Not Found\n```\n⚠ Skipping 'foo': command not found in PATH\n\n  If this is a node_modules binary, add explicit path:\n    \"paths\": [\"node_modules/.bin/foo\"]\n```\n\n## Block Message Box\n\nUpdate the block message to be clearer:\n\n```\n┌──────────────────────────────────────────────────────────────┐\n│  ⛔ BLOCKED: tsc                                             │\n├──────────────────────────────────────────────────────────────┤\n│                                                              │\n│  Use 'pnpm run typecheck' instead                            │\n│                                                              │\n│  Bypass: RIBBIN_BYPASS=1 tsc [args...]                       │\n│                                                              │\n└──────────────────────────────────────────────────────────────┘\n```\n\n## Version Command\n\n```go\nvar versionCmd = \u0026cobra.Command{\n    Use:   \"version\",\n    Short: \"Print version information\",\n    Run: func(cmd *cobra.Command, args []string) {\n        fmt.Printf(\"ribbin version %s\\n\", version)\n    },\n}\n```\n\nBuild with version:\n```makefile\nVERSION := $(shell git describe --tags --always --dirty)\nLDFLAGS := -ldflags \"-X main.version=$(VERSION)\"\n```\n\n## Status Command\n\nShow current state:\n\n```\n$ ribbin status\n\nGlobal: OFF\nShimmed binaries: 3\n  /usr/bin/cat\n  /usr/local/bin/tsc\n  /opt/homebrew/bin/npm\n\nActive sessions: 1\n  PID 12345 (activated 5m ago)\n```\n\n## Help Text Improvements\n\nEnsure all commands have:\n- Short description (one line)\n- Long description (paragraph with examples)\n- Flag descriptions\n\n## Acceptance Criteria\n\n- Colored output for success/error/warning\n- Clear error messages with solutions\n- Version command works\n- Status command shows useful info\n- Help text is comprehensive","status":"open","priority":3,"issue_type":"task","owner":"don@happycollision.com","created_at":"2026-01-17T22:09:57.60253-05:00","created_by":"Don Denton","updated_at":"2026-01-17T22:19:24.077905-05:00","dependencies":[{"issue_id":"ribbin-48m","depends_on_id":"ribbin-skj","type":"parent-child","created_at":"2026-01-17T22:11:40.908435-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-48m","depends_on_id":"ribbin-1jy","type":"blocks","created_at":"2026-01-17T22:13:54.316425-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-48m","depends_on_id":"ribbin-6g0","type":"blocks","created_at":"2026-01-18T14:12:03.724112-05:00","created_by":"Don Denton"}]}
{"id":"ribbin-4ao","title":"Phase 1: Registry changes for three-tier activation","description":"# Phase 1: Registry changes for three-tier activation\n\nUpdate the registry structure to support the new three-tier activation model.\n\n## Files to Modify\n\n- `internal/config/registry.go`\n\n## Changes Required\n\n### 1. Rename existing fields\n\n```go\n// Old\ntype Registry struct {\n    Shims       map[string]ShimEntry      `json:\"shims\"`\n    Activations map[int]ActivationEntry   `json:\"activations\"`\n    GlobalOn    bool                      `json:\"global_on\"`\n}\n\n// New\ntype Registry struct {\n    Wrappers          map[string]WrapperEntry         `json:\"wrappers\"`\n    ShellActivations  map[int]ShellActivationEntry    `json:\"shell_activations\"`\n    ConfigActivations map[string]ConfigActivationEntry `json:\"config_activations\"`\n    GlobalActive      bool                            `json:\"global_active\"`\n}\n```\n\n### 2. Add new types\n\n```go\ntype WrapperEntry struct {\n    Original string `json:\"original\"`\n    Config   string `json:\"config\"`\n}\n\ntype ShellActivationEntry struct {\n    PID         int       `json:\"pid\"`\n    ActivatedAt time.Time `json:\"activated_at\"`\n}\n\ntype ConfigActivationEntry struct {\n    ActivatedAt time.Time `json:\"activated_at\"`\n}\n```\n\n### 3. Add helper methods\n\n- `ClearShellActivations()` - Clear all shell activations\n- `ClearConfigActivations()` - Clear all config activations\n- `AddConfigActivation(configPath string)` - Add a config to activations\n- `RemoveConfigActivation(configPath string)` - Remove a config from activations\n\n## Tests \u0026 Documentation\n\nUpdate or add tests for:\n- Registry JSON serialization with new structure\n- Helper method behavior\n- Update any documentation that references registry structure\n\n## Verification\n\n- Unit tests pass with new registry structure\n- Registry JSON serialization works correctly","status":"closed","priority":2,"issue_type":"task","owner":"don@happycollision.com","created_at":"2026-01-20T11:21:09.425519-05:00","created_by":"Don Denton","updated_at":"2026-01-20T12:19:47.309439-05:00","closed_at":"2026-01-20T12:19:47.309439-05:00","close_reason":"Registry structure updated with three-tier activation model","dependencies":[{"issue_id":"ribbin-4ao","depends_on_id":"ribbin-is0","type":"blocks","created_at":"2026-01-20T11:23:16.050642-05:00","created_by":"Don Denton"}]}
{"id":"ribbin-4rc","title":"Implement audit logging for security events","description":"# Security Audit Logging (MEDIUM PRIORITY)\n\nCreate `internal/security/audit.go` to provide comprehensive logging of security-relevant operations.\n\n## Purpose\n\nLog all security-critical operations to enable:\n- Security incident detection and investigation\n- Compliance auditing\n- Debugging security issues\n- Detecting abuse patterns\n\n## Current State\n\n**No Logging**: The tool performs privileged operations (shimming binaries, modifying system directories) with zero audit trail.\n\n## Implementation Requirements\n\n### Audit Log Structure\n\n```go\npackage security\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"os\"\n    \"path/filepath\"\n    \"time\"\n)\n\n// AuditEvent represents a security-relevant event\ntype AuditEvent struct {\n    Timestamp   time.Time         `json:\"timestamp\"`\n    Event       string            `json:\"event\"`        // Event type\n    User        string            `json:\"user\"`         // Username\n    UID         int               `json:\"uid\"`          // User ID\n    Elevated    bool              `json:\"elevated\"`     // Running as root?\n    Binary      string            `json:\"binary,omitempty\"`\n    Path        string            `json:\"path,omitempty\"`\n    Success     bool              `json:\"success\"`\n    Error       string            `json:\"error,omitempty\"`\n    Details     map[string]string `json:\"details,omitempty\"`\n}\n\n// Event types\nconst (\n    EventShimInstall      = \"shim.install\"\n    EventShimUninstall    = \"shim.uninstall\"\n    EventBypassUsed       = \"bypass.used\"\n    EventSecurityViolation= \"security.violation\"\n    EventPrivilegedOp     = \"privileged.operation\"\n    EventConfigLoad       = \"config.load\"\n    EventRegistryUpdate   = \"registry.update\"\n)\n```\n\n### Core Logging Functions\n\n```go\n// GetAuditLogPath returns the path to the audit log\nfunc GetAuditLogPath() (string, error) {\n    // Use XDG Base Directory spec\n    stateDir := os.Getenv(\"XDG_STATE_HOME\")\n    if stateDir == \"\" {\n        home, err := os.UserHomeDir()\n        if err != nil {\n            return \"\", err\n        }\n        stateDir = filepath.Join(home, \".local\", \"state\")\n    }\n    \n    auditDir := filepath.Join(stateDir, \"ribbin\")\n    if err := os.MkdirAll(auditDir, 0700); err != nil {\n        return \"\", fmt.Errorf(\"cannot create audit directory: %w\", err)\n    }\n    \n    return filepath.Join(auditDir, \"audit.log\"), nil\n}\n\n// LogEvent writes an audit event to the log\nfunc LogEvent(event *AuditEvent) error {\n    // Get log path\n    logPath, err := GetAuditLogPath()\n    if err != nil {\n        // Don't fail the operation if we can't log\n        fmt.Fprintf(os.Stderr, \"Warning: cannot get audit log path: %v\\n\", err)\n        return nil\n    }\n    \n    // Fill in automatic fields\n    if event.Timestamp.IsZero() {\n        event.Timestamp = time.Now()\n    }\n    if event.User == \"\" {\n        event.User = os.Getenv(\"USER\")\n    }\n    event.UID = os.Getuid()\n    event.Elevated = os.Getuid() == 0\n    \n    // Marshal to JSON\n    data, err := json.Marshal(event)\n    if err != nil {\n        fmt.Fprintf(os.Stderr, \"Warning: cannot marshal audit event: %v\\n\", err)\n        return nil\n    }\n    \n    // Append to log file (create if doesn't exist)\n    f, err := os.OpenFile(logPath, os.O_CREATE|os.O_APPEND|os.O_WRONLY, 0600)\n    if err != nil {\n        fmt.Fprintf(os.Stderr, \"Warning: cannot open audit log: %v\\n\", err)\n        return nil\n    }\n    defer f.Close()\n    \n    // Write event (newline-delimited JSON)\n    if _, err := f.Write(append(data, '\\n')); err != nil {\n        fmt.Fprintf(os.Stderr, \"Warning: cannot write audit log: %v\\n\", err)\n        return nil\n    }\n    \n    return nil\n}\n\n// Convenience functions for common events\n\nfunc LogShimInstall(binary string, success bool, err error) {\n    event := \u0026AuditEvent{\n        Event:   EventShimInstall,\n        Binary:  binary,\n        Path:    binary,\n        Success: success,\n    }\n    if err != nil {\n        event.Error = err.Error()\n    }\n    LogEvent(event)\n}\n\nfunc LogShimUninstall(binary string, success bool, err error) {\n    event := \u0026AuditEvent{\n        Event:   EventShimUninstall,\n        Binary:  binary,\n        Path:    binary,\n        Success: success,\n    }\n    if err != nil {\n        event.Error = err.Error()\n    }\n    LogEvent(event)\n}\n\nfunc LogBypassUsage(command string, pid int) {\n    event := \u0026AuditEvent{\n        Event:   EventBypassUsed,\n        Binary:  command,\n        Success: true,\n        Details: map[string]string{\n            \"pid\": fmt.Sprintf(\"%d\", pid),\n        },\n    }\n    LogEvent(event)\n}\n\nfunc LogSecurityViolation(violation, path string, details map[string]string) {\n    event := \u0026AuditEvent{\n        Event:   EventSecurityViolation,\n        Path:    path,\n        Success: false,\n        Error:   violation,\n        Details: details,\n    }\n    LogEvent(event)\n}\n\nfunc LogPrivilegedOperation(operation, path string, success bool, err error) {\n    event := \u0026AuditEvent{\n        Event:   EventPrivilegedOp,\n        Path:    path,\n        Success: success,\n        Details: map[string]string{\n            \"operation\": operation,\n        },\n    }\n    if err != nil {\n        event.Error = err.Error()\n    }\n    LogEvent(event)\n}\n\nfunc LogConfigLoad(configPath string, success bool, err error) {\n    event := \u0026AuditEvent{\n        Event:   EventConfigLoad,\n        Path:    configPath,\n        Success: success,\n    }\n    if err != nil {\n        event.Error = err.Error()\n    }\n    LogEvent(event)\n}\n\nfunc LogRegistryUpdate(operation string, success bool, err error) {\n    event := \u0026AuditEvent{\n        Event:   EventRegistryUpdate,\n        Success: success,\n        Details: map[string]string{\n            \"operation\": operation,\n        },\n    }\n    if err != nil {\n        event.Error = err.Error()\n    }\n    LogEvent(event)\n}\n```\n\n### Query and Analysis Functions\n\n```go\n// QueryAuditLog reads and filters audit events\ntype AuditQuery struct {\n    StartTime *time.Time\n    EndTime   *time.Time\n    EventType string\n    User      string\n    Binary    string\n    Elevated  *bool\n    Success   *bool\n}\n\nfunc QueryAuditLog(query *AuditQuery) ([]*AuditEvent, error) {\n    logPath, err := GetAuditLogPath()\n    if err != nil {\n        return nil, err\n    }\n    \n    data, err := os.ReadFile(logPath)\n    if err != nil {\n        if os.IsNotExist(err) {\n            return []*AuditEvent{}, nil\n        }\n        return nil, err\n    }\n    \n    var events []*AuditEvent\n    for _, line := range strings.Split(string(data), \"\\n\") {\n        if line == \"\" {\n            continue\n        }\n        \n        var event AuditEvent\n        if err := json.Unmarshal([]byte(line), \u0026event); err != nil {\n            continue  // Skip malformed lines\n        }\n        \n        // Apply filters\n        if query.StartTime != nil \u0026\u0026 event.Timestamp.Before(*query.StartTime) {\n            continue\n        }\n        if query.EndTime != nil \u0026\u0026 event.Timestamp.After(*query.EndTime) {\n            continue\n        }\n        if query.EventType != \"\" \u0026\u0026 event.Event != query.EventType {\n            continue\n        }\n        if query.User != \"\" \u0026\u0026 event.User != query.User {\n            continue\n        }\n        if query.Binary != \"\" \u0026\u0026 event.Binary != query.Binary {\n            continue\n        }\n        if query.Elevated != nil \u0026\u0026 event.Elevated != *query.Elevated {\n            continue\n        }\n        if query.Success != nil \u0026\u0026 event.Success != *query.Success {\n            continue\n        }\n        \n        events = append(events, \u0026event)\n    }\n    \n    return events, nil\n}\n\n// GetAuditSummary provides statistics about audit events\ntype AuditSummary struct {\n    TotalEvents       int\n    SuccessfulOps     int\n    FailedOps         int\n    ElevatedOps       int\n    SecurityViolations int\n    BypassUsages      int\n}\n\nfunc GetAuditSummary(since *time.Time) (*AuditSummary, error) {\n    query := \u0026AuditQuery{StartTime: since}\n    events, err := QueryAuditLog(query)\n    if err != nil {\n        return nil, err\n    }\n    \n    summary := \u0026AuditSummary{}\n    for _, event := range events {\n        summary.TotalEvents++\n        if event.Success {\n            summary.SuccessfulOps++\n        } else {\n            summary.FailedOps++\n        }\n        if event.Elevated {\n            summary.ElevatedOps++\n        }\n        if event.Event == EventSecurityViolation {\n            summary.SecurityViolations++\n        }\n        if event.Event == EventBypassUsed {\n            summary.BypassUsages++\n        }\n    }\n    \n    return summary, nil\n}\n```\n\n## Integration Points\n\n### installer.go\n\n```go\nfunc Install(binaryPath, ribbinPath string, allowSystemDir bool) error {\n    // Log attempt\n    defer func() {\n        if r := recover(); r != nil {\n            security.LogShimInstall(binaryPath, false, fmt.Errorf(\"panic: %v\", r))\n            panic(r)\n        }\n    }()\n    \n    // ... installation logic ...\n    \n    // Log success\n    security.LogShimInstall(binaryPath, true, nil)\n    return nil\n}\n```\n\n### runner.go (bypass detection)\n\n```go\nfunc Run(originalPath string, args []string) error {\n    if os.Getenv(\"RIBBIN_BYPASS\") == \"1\" {\n        // Log bypass usage\n        security.LogBypassUsage(originalPath, os.Getpid())\n        return execOriginal(originalPath, args)\n    }\n    // ...\n}\n```\n\n### Path validation failures\n\n```go\nfunc ValidateBinaryPath(path string) error {\n    if strings.Contains(path, \"..\") {\n        security.LogSecurityViolation(\"path_traversal\", path, map[string]string{\n            \"reason\": \"path contains traversal sequence\",\n        })\n        return fmt.Errorf(\"path traversal detected\")\n    }\n    // ...\n}\n```\n\n### Privileged operations\n\n```go\nfunc Install(binaryPath, ribbinPath string, allowSystemDir bool) error {\n    if os.Getuid() == 0 {\n        security.LogPrivilegedOperation(\"shim_install\", binaryPath, true, nil)\n    }\n    // ...\n}\n```\n\n## CLI Command for Audit Log Access\n\nCreate `internal/cli/audit.go`:\n\n```go\nvar auditCmd = \u0026cobra.Command{\n    Use:   \"audit\",\n    Short: \"View audit log\",\n    Long:  \"View and query the security audit log\",\n}\n\nvar auditShowCmd = \u0026cobra.Command{\n    Use:   \"show\",\n    Short: \"Show recent audit events\",\n    RunE:  runAuditShow,\n}\n\nvar auditSummaryCmd = \u0026cobra.Command{\n    Use:   \"summary\",\n    Short: \"Show audit summary statistics\",\n    RunE:  runAuditSummary,\n}\n\nvar (\n    auditSince    string\n    auditEventType string\n    auditLimit    int\n)\n\nfunc init() {\n    auditShowCmd.Flags().StringVar(\u0026auditSince, \"since\", \"24h\", \"Show events since duration (e.g., 24h, 7d)\")\n    auditShowCmd.Flags().StringVar(\u0026auditEventType, \"type\", \"\", \"Filter by event type\")\n    auditShowCmd.Flags().IntVar(\u0026auditLimit, \"limit\", 50, \"Limit number of events\")\n    \n    auditCmd.AddCommand(auditShowCmd)\n    auditCmd.AddCommand(auditSummaryCmd)\n    rootCmd.AddCommand(auditCmd)\n}\n\nfunc runAuditShow(cmd *cobra.Command, args []string) error {\n    // Parse since duration\n    duration, err := time.ParseDuration(auditSince)\n    if err != nil {\n        return fmt.Errorf(\"invalid duration: %w\", err)\n    }\n    startTime := time.Now().Add(-duration)\n    \n    // Query events\n    query := \u0026security.AuditQuery{\n        StartTime: \u0026startTime,\n        EventType: auditEventType,\n    }\n    events, err := security.QueryAuditLog(query)\n    if err != nil {\n        return err\n    }\n    \n    // Limit results\n    if len(events) \u003e auditLimit {\n        events = events[len(events)-auditLimit:]\n    }\n    \n    // Display events\n    for _, event := range events {\n        fmt.Printf(\"[%s] %s: %s\", \n            event.Timestamp.Format(time.RFC3339),\n            event.Event,\n            event.Path)\n        if !event.Success {\n            fmt.Printf(\" FAILED: %s\", event.Error)\n        }\n        if event.Elevated {\n            fmt.Printf(\" [ROOT]\")\n        }\n        fmt.Println()\n    }\n    \n    return nil\n}\n\nfunc runAuditSummary(cmd *cobra.Command, args []string) error {\n    // Get summary for last 30 days\n    since := time.Now().AddDate(0, 0, -30)\n    summary, err := security.GetAuditSummary(\u0026since)\n    if err != nil {\n        return err\n    }\n    \n    fmt.Printf(\"Audit Summary (last 30 days):\\n\")\n    fmt.Printf(\"  Total Events:        %d\\n\", summary.TotalEvents)\n    fmt.Printf(\"  Successful Ops:      %d\\n\", summary.SuccessfulOps)\n    fmt.Printf(\"  Failed Ops:          %d\\n\", summary.FailedOps)\n    fmt.Printf(\"  Elevated Ops:        %d\\n\", summary.ElevatedOps)\n    fmt.Printf(\"  Security Violations: %d\\n\", summary.SecurityViolations)\n    fmt.Printf(\"  Bypass Usages:       %d\\n\", summary.BypassUsages)\n    \n    return nil\n}\n```\n\n## Test Cases\n\n```go\nfunc TestLogEvent(t *testing.T) {\n    // Set test log path\n    tmpDir := t.TempDir()\n    logPath := filepath.Join(tmpDir, \"audit.log\")\n    os.Setenv(\"XDG_STATE_HOME\", tmpDir)\n    defer os.Unsetenv(\"XDG_STATE_HOME\")\n    \n    // Log an event\n    event := \u0026AuditEvent{\n        Event:   EventShimInstall,\n        Binary:  \"/usr/local/bin/test\",\n        Success: true,\n    }\n    err := LogEvent(event)\n    assert.NoError(t, err)\n    \n    // Verify event was written\n    data, err := os.ReadFile(logPath)\n    assert.NoError(t, err)\n    assert.Contains(t, string(data), EventShimInstall)\n}\n\nfunc TestQueryAuditLog(t *testing.T) {\n    // Setup test log\n    tmpDir := t.TempDir()\n    os.Setenv(\"XDG_STATE_HOME\", tmpDir)\n    defer os.Unsetenv(\"XDG_STATE_HOME\")\n    \n    // Log several events\n    LogShimInstall(\"/bin/test1\", true, nil)\n    LogShimUninstall(\"/bin/test2\", true, nil)\n    LogBypassUsage(\"/bin/test3\", 1234)\n    \n    // Query all events\n    events, err := QueryAuditLog(\u0026AuditQuery{})\n    assert.NoError(t, err)\n    assert.Len(t, events, 3)\n    \n    // Query by event type\n    query := \u0026AuditQuery{EventType: EventShimInstall}\n    events, err = QueryAuditLog(query)\n    assert.NoError(t, err)\n    assert.Len(t, events, 1)\n    assert.Equal(t, \"/bin/test1\", events[0].Binary)\n}\n```\n\n## Success Criteria\n\n- [ ] Audit logging implemented with JSONL format\n- [ ] All security-relevant events logged (install, uninstall, bypass, violations)\n- [ ] Elevated privilege operations clearly marked\n- [ ] Audit log stored in XDG-compliant location (~/.local/state/ribbin)\n- [ ] Query and analysis functions working\n- [ ] CLI commands for viewing audit log\n- [ ] Logging failures don't block operations\n- [ ] Test coverage \u003e85%\n\n## Dependencies\n\n- None (standalone functionality)\n- Used by: All other security modules\n\n## Estimated Complexity\n\nMedium - JSONL logging, query functionality, CLI integration","status":"closed","priority":2,"issue_type":"task","owner":"don@happycollision.com","created_at":"2026-01-18T13:36:52.405596-05:00","created_by":"Don Denton","updated_at":"2026-01-18T16:40:52.046319-05:00","closed_at":"2026-01-18T16:40:52.046319-05:00","close_reason":"Closed","dependencies":[{"issue_id":"ribbin-4rc","depends_on_id":"ribbin-rx1","type":"parent-child","created_at":"2026-01-18T13:39:50.630097-05:00","created_by":"Don Denton"}]}
{"id":"ribbin-5cs","title":"Add GetAncestorCommands() to process package","description":"## Context\n\nThe current passthrough `invocation` and `invocationRegexp` matching only checks the **immediate parent process**. This breaks for tools like `nx`, `turborepo`, `make`, and other task runners that spawn intermediate processes.\n\n**Example process tree:**\n```\nshell\n└── pnpm nx typecheck     ← \"pnpm nx typecheck\" (grandparent)\n    └── nx                ← some nx runner process (parent)\n        └── tsc           ← the wrapped command\n```\n\nCurrent code only sees the immediate parent (`nx`), missing the actual command (`pnpm nx typecheck`).\n\n## Task\n\nAdd a new function `GetAncestorCommands()` to both `internal/process/ancestry_darwin.go` and `internal/process/ancestry_linux.go` that walks up the process tree and returns command strings for each ancestor.\n\n## Implementation\n\n### Darwin (`internal/process/ancestry_darwin.go`)\n\n```go\n// GetAncestorCommands walks up the process tree and returns command strings.\n// maxDepth of 0 means unlimited. Returns commands from nearest (parent) to farthest.\nfunc GetAncestorCommands(maxDepth int) ([]string, error) {\n    var commands []string\n    currentPID := os.Getpid()\n    depth := 0\n\n    for currentPID \u003e 1 {\n        parentPID, err := getParentPID(currentPID)\n        if err != nil {\n            break // Can't continue up the tree\n        }\n\n        cmd, err := getCommandForPID(parentPID)\n        if err == nil \u0026\u0026 cmd != \"\" {\n            commands = append(commands, cmd)\n        }\n\n        depth++\n        if maxDepth \u003e 0 \u0026\u0026 depth \u003e= maxDepth {\n            break\n        }\n\n        currentPID = parentPID\n    }\n\n    return commands, nil\n}\n\n// getCommandForPID returns the command line for a given PID using ps\nfunc getCommandForPID(pid int) (string, error) {\n    cmd := exec.Command(\"ps\", \"-o\", \"command=\", \"-p\", strconv.Itoa(pid))\n    output, err := cmd.Output()\n    if err != nil {\n        return \"\", err\n    }\n    return strings.TrimSpace(string(output)), nil\n}\n```\n\n### Linux (`internal/process/ancestry_linux.go`)\n\nSame structure but `getCommandForPID` reads from `/proc/\u003cpid\u003e/cmdline`:\n\n```go\nfunc getCommandForPID(pid int) (string, error) {\n    cmdlinePath := \"/proc/\" + strconv.Itoa(pid) + \"/cmdline\"\n    data, err := os.ReadFile(cmdlinePath)\n    if err != nil {\n        return \"\", err\n    }\n    cmdline := strings.ReplaceAll(string(data), \"\\x00\", \" \")\n    return strings.TrimSpace(cmdline), nil\n}\n```\n\n## Tests to Add\n\n**File: `internal/process/ancestry_test.go`**\n\n- `TestGetAncestorCommands` - verify returns multiple levels (at minimum, the test runner and shell)\n- `TestGetAncestorCommandsWithDepthLimit` - verify stops at specified depth\n- `TestGetCommandForPID` - verify command retrieval for known PID\n\n## Acceptance Criteria\n\n- [ ] `GetAncestorCommands(0)` returns all ancestors up to PID 1\n- [ ] `GetAncestorCommands(1)` returns only immediate parent\n- [ ] `GetAncestorCommands(N)` returns up to N ancestors\n- [ ] Gracefully handles errors (process died, permission denied)\n- [ ] Tests pass on both Darwin and Linux","status":"closed","priority":2,"issue_type":"task","owner":"don.denton@trillianthealth.com","created_at":"2026-01-22T00:32:56.824581-05:00","created_by":"Don Denton","updated_at":"2026-01-22T09:40:49.984243-05:00","closed_at":"2026-01-22T09:40:49.984243-05:00","close_reason":"Closed","dependencies":[{"issue_id":"ribbin-5cs","depends_on_id":"ribbin-9r5","type":"parent-child","created_at":"2026-01-22T09:35:40.823887-05:00","created_by":"Don Denton"}]}
{"id":"ribbin-5f2","title":"Add CHANGELOG.md","description":"# Add CHANGELOG.md\n\nCreate a changelog following the Keep a Changelog format (https://keepachangelog.com).\n\n## File: CHANGELOG.md\n\n```markdown\n# Changelog\n\nAll notable changes to this project will be documented in this file.\n\nThe format is based on [Keep a Changelog](https://keepachangelog.com/en/1.1.0/),\nand this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).\n\n## [Unreleased]\n\n### Added\n- Initial implementation of ribbin CLI\n- Commands: shim, unshim, on, off, activate\n- TOML-based project configuration (ribbin.toml)\n- Docker-based test suite for safe testing\n- Process ancestry checking for shell-scoped activation\n```\n\n## Sections to use\n- **Added** - new features\n- **Changed** - changes in existing functionality\n- **Deprecated** - soon-to-be removed features\n- **Removed** - now removed features\n- **Fixed** - bug fixes\n- **Security** - vulnerability fixes\n\n## Acceptance Criteria\n- CHANGELOG.md exists at repo root\n- Follows Keep a Changelog format\n- Uses Semantic Versioning\n- Has [Unreleased] section with current features","status":"closed","priority":3,"issue_type":"task","owner":"don@happycollision.com","created_at":"2026-01-17T23:36:11.069759-05:00","created_by":"Don Denton","updated_at":"2026-01-17T23:46:18.406694-05:00","closed_at":"2026-01-17T23:46:18.406694-05:00","close_reason":"Implemented all release infrastructure files"}
{"id":"ribbin-5tf","title":"Implement 'ribbin unshim' command","description":"# ribbin unshim Command Implementation\n\nImplement the unshim command with --all and --search flags.\n\n## File to Modify\n\n### internal/cli/unshim.go\n\n```go\nvar unshimCmd = \u0026cobra.Command{\n    Use:   \"unshim\",\n    Short: \"Remove shims and restore original binaries\",\n    RunE:  runUnshim,\n}\n\nvar unshimAll bool\nvar unshimSearch bool\n\nfunc init() {\n    unshimCmd.Flags().BoolVar(\u0026unshimAll, \"all\", false, \"Restore all shimmed commands from registry\")\n    unshimCmd.Flags().BoolVar(\u0026unshimSearch, \"search\", false, \"Search filesystem for sidecars (use with --all)\")\n}\n\nfunc runUnshim(cmd *cobra.Command, args []string) error {\n    registry, err := config.LoadRegistry()\n    if err != nil {\n        return fmt.Errorf(\"failed to load registry: %w\", err)\n    }\n    \n    var pathsToUnshim []string\n    \n    if unshimAll {\n        if unshimSearch {\n            // Search filesystem for all sidecars\n            pathsToUnshim, err = shim.FindSidecars(commonBinDirs())\n            if err != nil {\n                return fmt.Errorf(\"search failed: %w\", err)\n            }\n        } else {\n            // Use registry\n            for path := range registry.Shims {\n                pathsToUnshim = append(pathsToUnshim, path)\n            }\n        }\n    } else {\n        // Use nearest ribbin.json\n        cfg, _, err := config.FindProjectConfig()\n        if err != nil {\n            return fmt.Errorf(\"no ribbin.json found (use --all to unshim from registry): %w\", err)\n        }\n        \n        for name, shimCfg := range cfg.Shims {\n            paths := shimCfg.Paths\n            if len(paths) == 0 {\n                resolved, err := shim.ResolveCommand(name)\n                if err != nil {\n                    continue\n                }\n                paths = []string{resolved}\n            }\n            pathsToUnshim = append(pathsToUnshim, paths...)\n        }\n    }\n    \n    var restored, skipped, failed int\n    \n    for _, p := range pathsToUnshim {\n        if err := shim.Uninstall(p, registry); err != nil {\n            if os.IsNotExist(err) {\n                skipped++\n            } else {\n                fmt.Printf(\"✗ %s: %v\\n\", p, err)\n                failed++\n            }\n        } else {\n            fmt.Printf(\"✓ %s: restored\\n\", p)\n            restored++\n        }\n    }\n    \n    if err := config.SaveRegistry(registry); err != nil {\n        return fmt.Errorf(\"failed to save registry: %w\", err)\n    }\n    \n    fmt.Printf(\"\\nRestored: %d, Skipped: %d, Failed: %d\\n\", restored, skipped, failed)\n    \n    return nil\n}\n\nfunc commonBinDirs() []string {\n    return []string{\n        \"/usr/bin\",\n        \"/usr/local/bin\",\n        \"/opt/homebrew/bin\",\n        os.Getenv(\"HOME\") + \"/.local/bin\",\n        os.Getenv(\"HOME\") + \"/go/bin\",\n    }\n}\n```\n\n## Modes\n\n### Default (no flags)\n- Find nearest ribbin.json\n- Unshim only commands listed in that config\n- Update registry\n\n### --all\n- Read global registry\n- Unshim everything in registry\n- Clear registry\n\n### --all --search\n- Search common binary directories for *.ribbin-original files\n- Unshim all found sidecars\n- Update registry based on what was found\n\n## FindSidecars Implementation\n\n```go\nfunc FindSidecars(searchPaths []string) ([]string, error) {\n    var sidecars []string\n    \n    for _, dir := range searchPaths {\n        pattern := filepath.Join(dir, \"*.ribbin-original\")\n        matches, err := filepath.Glob(pattern)\n        if err != nil {\n            continue // Skip inaccessible directories\n        }\n        \n        for _, match := range matches {\n            // Convert sidecar path to original binary path\n            original := strings.TrimSuffix(match, \".ribbin-original\")\n            sidecars = append(sidecars, original)\n        }\n    }\n    \n    return sidecars, nil\n}\n```\n\n## Acceptance Criteria\n\n- Default mode uses nearest config\n- --all mode uses registry\n- --all --search finds sidecars on filesystem\n- Registry is updated after unshim\n- Clear error messages","status":"closed","priority":1,"issue_type":"task","owner":"don@happycollision.com","created_at":"2026-01-17T22:04:32.794605-05:00","created_by":"Don Denton","updated_at":"2026-01-17T23:06:51.994991-05:00","closed_at":"2026-01-17T23:06:51.994991-05:00","close_reason":"Closed","dependencies":[{"issue_id":"ribbin-5tf","depends_on_id":"ribbin-skj","type":"parent-child","created_at":"2026-01-17T22:11:09.468507-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-5tf","depends_on_id":"ribbin-1of","type":"blocks","created_at":"2026-01-17T22:12:35.905556-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-5tf","depends_on_id":"ribbin-d9y","type":"blocks","created_at":"2026-01-17T22:12:41.142308-05:00","created_by":"Don Denton"}]}
{"id":"ribbin-6g0","title":"Polish and UX improvements","description":"User experience improvements including colored output, better error messages, and overall polish for ribbin CLI","status":"closed","priority":3,"issue_type":"epic","owner":"don@happycollision.com","created_at":"2026-01-18T14:11:54.018111-05:00","created_by":"Don Denton","updated_at":"2026-01-21T01:03:52.4427-05:00","closed_at":"2026-01-21T01:03:52.4427-05:00","close_reason":"All children completed: docs, CLI help, command design review, Claude Code testing, and article"}
{"id":"ribbin-6g0.1","title":"Documentation updates (configs and extends)","status":"closed","priority":3,"issue_type":"task","owner":"don@happycollision.com","created_at":"2026-01-20T00:11:20.124787-05:00","created_by":"Don Denton","updated_at":"2026-01-20T23:49:16.076812-05:00","closed_at":"2026-01-20T23:49:16.076812-05:00","close_reason":"Streamlined README to quick start guide, moved detailed config/extends/scopes docs to docs/README.md","dependencies":[{"issue_id":"ribbin-6g0.1","depends_on_id":"ribbin-6g0","type":"parent-child","created_at":"2026-01-20T00:11:20.126755-05:00","created_by":"Don Denton"}]}
{"id":"ribbin-6g0.2","title":"CLI self-documentation updates","status":"closed","priority":3,"issue_type":"task","owner":"don@happycollision.com","created_at":"2026-01-20T00:11:25.508304-05:00","created_by":"Don Denton","updated_at":"2026-01-20T23:54:35.570725-05:00","closed_at":"2026-01-20T23:54:35.570725-05:00","close_reason":"Updated CLI help text: .toml→.jsonc in examples, shim→wrapper in user-facing text","dependencies":[{"issue_id":"ribbin-6g0.2","depends_on_id":"ribbin-6g0","type":"parent-child","created_at":"2026-01-20T00:11:25.509806-05:00","created_by":"Don Denton"}]}
{"id":"ribbin-6g0.3","title":"Review command design: shim/unshim/activate/on/off - behavior and mechanism (symlinks?)","status":"closed","priority":3,"issue_type":"task","owner":"don@happycollision.com","created_at":"2026-01-20T00:11:30.899478-05:00","created_by":"Don Denton","updated_at":"2026-01-20T11:20:22.871875-05:00","closed_at":"2026-01-20T11:20:22.871875-05:00","close_reason":"UX design complete - see plan file and new epic for implementation","dependencies":[{"issue_id":"ribbin-6g0.3","depends_on_id":"ribbin-6g0","type":"parent-child","created_at":"2026-01-20T00:11:30.900824-05:00","created_by":"Don Denton"}]}
{"id":"ribbin-6g0.4","title":"Test with Claude Code - validate it actually works","status":"closed","priority":3,"issue_type":"task","owner":"don@happycollision.com","created_at":"2026-01-20T00:11:36.294703-05:00","created_by":"Don Denton","updated_at":"2026-01-21T00:26:22.201465-05:00","closed_at":"2026-01-21T00:26:22.201465-05:00","close_reason":"Validated Ribbin intercepts Claude Code bash commands. Test setup: created fake-tool in test-bin/, wrapped it with --confirm-system-dir, confirmed block message displays correctly.","dependencies":[{"issue_id":"ribbin-6g0.4","depends_on_id":"ribbin-6g0","type":"parent-child","created_at":"2026-01-20T00:11:36.296055-05:00","created_by":"Don Denton"}]}
{"id":"ribbin-6g0.5","title":"Write article about what problem ribbin solves","status":"closed","priority":3,"issue_type":"task","owner":"don@happycollision.com","created_at":"2026-01-20T00:11:41.693629-05:00","created_by":"Don Denton","updated_at":"2026-01-21T01:01:08.555288-05:00","closed_at":"2026-01-21T01:01:08.555288-05:00","close_reason":"Article written to docs/article-ai-agents-wrong-commands.md","dependencies":[{"issue_id":"ribbin-6g0.5","depends_on_id":"ribbin-6g0","type":"parent-child","created_at":"2026-01-20T00:11:41.694953-05:00","created_by":"Don Denton"}]}
{"id":"ribbin-6o5","title":"Add ScopeConfig struct and update ProjectConfig","description":"**Read epic ribbin-3gj for full context.**\n\nUpdate internal/config/project.go:\n\n```go\ntype ScopeConfig struct {\n    Path    string                  `toml:\"path,omitempty\"`   // defaults to \".\"\n    Extends []string                `toml:\"extends,omitempty\"`\n    Shims   map[string]ShimConfig   `toml:\"shims\"`\n}\n\ntype ProjectConfig struct {\n    Shims  map[string]ShimConfig   `toml:\"shims\"`\n    Scopes map[string]ScopeConfig  `toml:\"scopes\"`\n}\n```\n\nAdd path validation for scope paths:\n- Scope `path` must be descendant of config dir (reject `..`)\n- Path defaults to \".\" if not specified\n\nTests: Add tests in internal/config/project_test.go for:\n- Valid relative paths, absolute descendant paths\n- Reject `..` traversal, reject paths outside project\n- Path defaulting to \".\"","status":"closed","priority":2,"issue_type":"task","owner":"don@happycollision.com","created_at":"2026-01-19T13:37:45.046299-05:00","created_by":"Don Denton","updated_at":"2026-01-19T14:07:57.448006-05:00","closed_at":"2026-01-19T14:07:57.448006-05:00","close_reason":"Added ScopeConfig struct, updated ProjectConfig, added path validation with tests","dependencies":[{"issue_id":"ribbin-6o5","depends_on_id":"ribbin-3gj","type":"parent-child","created_at":"2026-01-19T13:38:41.902967-05:00","created_by":"Don Denton"}]}
{"id":"ribbin-85g","title":"Implement 'ribbin on' and 'ribbin off' commands","description":"# ribbin on/off Commands Implementation\n\nSimple global toggle for shim activation.\n\n## Files to Modify\n\n### internal/cli/on.go\n\n```go\npackage cli\n\nimport (\n    \"fmt\"\n    \n    \"github.com/spf13/cobra\"\n    \"github.com/user/ribbin/internal/config\"\n)\n\nvar onCmd = \u0026cobra.Command{\n    Use:   \"on\",\n    Short: \"Enable shims globally\",\n    Long: `Enables shims globally (for all shells, persists across sessions).\n    \nWhen globally on, shimmed commands will check ribbin.json in the \ncurrent directory tree and block according to configuration.\n\nUse 'ribbin activate' for per-session activation instead.`,\n    RunE: runOn,\n}\n\nfunc runOn(cmd *cobra.Command, args []string) error {\n    registry, err := config.LoadRegistry()\n    if err != nil {\n        return fmt.Errorf(\"failed to load registry: %w\", err)\n    }\n    \n    if registry.GlobalOn {\n        fmt.Println(\"Shims are already globally enabled\")\n        return nil\n    }\n    \n    registry.GlobalOn = true\n    \n    if err := config.SaveRegistry(registry); err != nil {\n        return fmt.Errorf(\"failed to save registry: %w\", err)\n    }\n    \n    fmt.Println(\"✓ Shims are now globally enabled\")\n    return nil\n}\n```\n\n### internal/cli/off.go\n\n```go\npackage cli\n\nimport (\n    \"fmt\"\n    \n    \"github.com/spf13/cobra\"\n    \"github.com/user/ribbin/internal/config\"\n)\n\nvar offCmd = \u0026cobra.Command{\n    Use:   \"off\",\n    Short: \"Disable shims globally\",\n    Long: `Disables shims globally.\n    \nWhen off, shimmed commands will pass through to the original binary\nregardless of ribbin.json configuration.\n\nNote: Per-session activations (via 'ribbin activate') are also ignored\nwhen globally off.`,\n    RunE: runOff,\n}\n\nfunc runOff(cmd *cobra.Command, args []string) error {\n    registry, err := config.LoadRegistry()\n    if err != nil {\n        return fmt.Errorf(\"failed to load registry: %w\", err)\n    }\n    \n    if !registry.GlobalOn {\n        fmt.Println(\"Shims are already globally disabled\")\n        return nil\n    }\n    \n    registry.GlobalOn = false\n    \n    if err := config.SaveRegistry(registry); err != nil {\n        return fmt.Errorf(\"failed to save registry: %w\", err)\n    }\n    \n    fmt.Println(\"✓ Shims are now globally disabled\")\n    return nil\n}\n```\n\n## Behavior\n\n### ribbin on\n- Sets `global_on: true` in registry\n- All shims become active (check config, potentially block)\n- Persists across terminal sessions\n\n### ribbin off\n- Sets `global_on: false` in registry\n- All shims passthrough (even if `activate` was called)\n- Persists across terminal sessions\n\n## Priority\n\nWhen checking if shims are active:\n1. If `global_on == true` → active\n2. Else if current process descends from an activated PID → active\n3. Else → inactive (passthrough)\n\nNote: `ribbin off` disables everything. If global is off, even per-session activations don't apply. This is intentional - it's the \"emergency off switch\".\n\n## Status Command (Optional Enhancement)\n\nCould add a status command to show current state:\n\n```go\nvar statusCmd = \u0026cobra.Command{\n    Use:   \"status\",\n    Short: \"Show current shim status\",\n    RunE: func(cmd *cobra.Command, args []string) error {\n        registry, _ := config.LoadRegistry()\n        \n        fmt.Printf(\"Global: %v\\n\", registry.GlobalOn)\n        fmt.Printf(\"Shimmed binaries: %d\\n\", len(registry.Shims))\n        fmt.Printf(\"Active sessions: %d\\n\", len(registry.Activations))\n        \n        return nil\n    },\n}\n```\n\n## Tests\n\n- Test on sets GlobalOn to true\n- Test off sets GlobalOn to false\n- Test idempotent (on when already on, off when already off)\n- Test shim respects global state\n\n## Acceptance Criteria\n\n- `ribbin on` enables globally\n- `ribbin off` disables globally\n- State persists in registry\n- Shim runner respects global state","status":"closed","priority":2,"issue_type":"task","owner":"don@happycollision.com","created_at":"2026-01-17T22:08:25.81097-05:00","created_by":"Don Denton","updated_at":"2026-01-17T23:00:55.398206-05:00","closed_at":"2026-01-17T23:00:55.398206-05:00","close_reason":"Closed","dependencies":[{"issue_id":"ribbin-85g","depends_on_id":"ribbin-skj","type":"parent-child","created_at":"2026-01-17T22:11:30.444208-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-85g","depends_on_id":"ribbin-1of","type":"blocks","created_at":"2026-01-17T22:13:17.776763-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-85g","depends_on_id":"ribbin-g2x","type":"blocks","created_at":"2026-01-17T22:13:23.016693-05:00","created_by":"Don Denton"}]}
{"id":"ribbin-8hb","title":"Update runner for scope matching and passthrough action","description":"**Read epic ribbin-3gj for full context.**\n\nUpdate internal/shim/runner.go:\n\n1. Add scope matching logic:\n   - Find all scopes where CWD is within scope.path\n   - Select deepest matching scope (most path segments wins)\n   - If no scope matches, use root shims\n\n2. Integrate with Resolver:\n   - Use Resolver.ResolveEffectiveShims to get merged shim map\n   - Look up command in effective shims\n\n3. Add `action = \"passthrough\"` handling:\n   - When action is \"passthrough\", execute the original binary\n   - This allows scopes to explicitly override blocks from extended sources\n\n```toml\n[scopes.dev]\nextends = [\"root\"]  # root blocks npm\n\n[scopes.dev.shims.npm]\naction = \"passthrough\"  # but dev allows it\n```\n\nTests: Update internal/shim/runner_test.go with:\n- CWD in scope path → scope applies\n- Multiple scopes match → deepest path wins\n- No scope matches → root shims used\n- Scope without path → path defaults to \".\"\n- Passthrough action → original executes","status":"closed","priority":2,"issue_type":"task","owner":"don@happycollision.com","created_at":"2026-01-19T13:38:11.741094-05:00","created_by":"Don Denton","updated_at":"2026-01-19T22:25:39.531264-05:00","closed_at":"2026-01-19T22:25:39.531264-05:00","close_reason":"Implemented scope matching, passthrough action, and config show command with provenance tracking","dependencies":[{"issue_id":"ribbin-8hb","depends_on_id":"ribbin-3gj","type":"parent-child","created_at":"2026-01-19T13:38:57.632797-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-8hb","depends_on_id":"ribbin-xot","type":"blocks","created_at":"2026-01-19T13:39:27.972355-05:00","created_by":"Don Denton"}]}
{"id":"ribbin-8kc","title":"Redirect action for custom script execution","description":"Add a 'redirect' action that allows shimmed commands to execute custom scripts instead of blocking. The custom script receives the original binary path via environment variables (RIBBIN_ORIGINAL_BIN, RIBBIN_COMMAND, RIBBIN_CONFIG, RIBBIN_ACTION), allowing it to call the original tool if needed. Relative script paths resolve from ribbin.toml directory. Fail-open philosophy: missing/invalid scripts warn and passthrough to original.","status":"closed","priority":2,"issue_type":"epic","owner":"don@happycollision.com","created_at":"2026-01-18T11:34:28.570376-05:00","created_by":"Don Denton","updated_at":"2026-01-18T12:06:37.310218-05:00","closed_at":"2026-01-18T12:06:37.310218-05:00","close_reason":"All redirect action implementation complete: core functionality, tests, and documentation added"}
{"id":"ribbin-8kc.1","title":"Add Redirect field to ShimConfig struct","description":"Update internal/config/project.go to add `Redirect string` field to ShimConfig struct with TOML tag `toml:\"redirect,omitempty\"`. Update struct comment (line 12) to document \"redirect\" action alongside \"block\" and \"warn\".","status":"closed","priority":2,"issue_type":"task","owner":"don@happycollision.com","created_at":"2026-01-18T11:34:38.985783-05:00","created_by":"Don Denton","updated_at":"2026-01-18T12:06:19.618452-05:00","closed_at":"2026-01-18T12:06:19.618452-05:00","close_reason":"Closed","dependencies":[{"issue_id":"ribbin-8kc.1","depends_on_id":"ribbin-8kc","type":"parent-child","created_at":"2026-01-18T11:34:38.986928-05:00","created_by":"Don Denton"}]}
{"id":"ribbin-8kc.2","title":"Create redirect.go with path resolution logic","description":"Create internal/shim/redirect.go with two functions: 1) resolveRedirectScript(scriptPath, configPath string) handles relative/absolute path resolution (relative paths resolve from filepath.Dir(configPath)); 2) validateExecutable(path string) checks file exists via os.Stat, verifies regular file (not directory), and checks executable permission (mode \u0026 0111 != 0). Return helpful error messages for missing scripts, non-executable files, and directories.","status":"closed","priority":2,"issue_type":"task","owner":"don@happycollision.com","created_at":"2026-01-18T11:34:49.394116-05:00","created_by":"Don Denton","updated_at":"2026-01-18T11:45:13.249351-05:00","closed_at":"2026-01-18T11:45:13.249351-05:00","close_reason":"Closed","dependencies":[{"issue_id":"ribbin-8kc.2","depends_on_id":"ribbin-8kc","type":"parent-child","created_at":"2026-01-18T11:34:49.395366-05:00","created_by":"Don Denton"}]}
{"id":"ribbin-8kc.3","title":"Update runner.go with redirect execution logic","description":"Update internal/shim/runner.go: 1) Replace if-block (lines 66-73) with switch statement handling \"block\", \"redirect\", and default cases; 2) Add case \"redirect\" with empty check, call to resolveRedirectScript(), and fail-open error handling (warn to stderr + passthrough); 3) Add execRedirect() function after execOriginal() that uses syscall.Exec to replace process, passing environment variables: RIBBIN_ORIGINAL_BIN, RIBBIN_COMMAND, RIBBIN_CONFIG, RIBBIN_ACTION=redirect.","status":"closed","priority":2,"issue_type":"task","owner":"don@happycollision.com","created_at":"2026-01-18T11:34:59.967515-05:00","created_by":"Don Denton","updated_at":"2026-01-18T12:06:19.620319-05:00","closed_at":"2026-01-18T12:06:19.620319-05:00","close_reason":"Closed","dependencies":[{"issue_id":"ribbin-8kc.3","depends_on_id":"ribbin-8kc","type":"parent-child","created_at":"2026-01-18T11:34:59.968702-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-8kc.3","depends_on_id":"ribbin-8kc.2","type":"blocks","created_at":"2026-01-18T11:36:16.4592-05:00","created_by":"Don Denton"}]}
{"id":"ribbin-8kc.4","title":"Create unit tests for redirect functionality","description":"Create internal/shim/redirect_test.go with unit tests: TestResolveRedirectScript (relative path resolution, absolute path resolution, missing script error, non-executable error, parent directory references), TestValidateExecutable (executable file success, directory rejection, non-executable rejection, file not found).","status":"closed","priority":2,"issue_type":"task","owner":"don@happycollision.com","created_at":"2026-01-18T11:35:09.485499-05:00","created_by":"Don Denton","updated_at":"2026-01-18T12:06:19.621377-05:00","closed_at":"2026-01-18T12:06:19.621377-05:00","close_reason":"Closed","dependencies":[{"issue_id":"ribbin-8kc.4","depends_on_id":"ribbin-8kc","type":"parent-child","created_at":"2026-01-18T11:35:09.486688-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-8kc.4","depends_on_id":"ribbin-8kc.2","type":"blocks","created_at":"2026-01-18T11:36:21.71635-05:00","created_by":"Don Denton"}]}
{"id":"ribbin-8kc.5","title":"Create test fixtures for redirect feature","description":"Create testdata/projects/redirect/ directory with: 1) ribbin.toml containing redirect action config (e.g., [shims.echo] action=\"redirect\" redirect=\"./scripts/test-redirect.sh\"); 2) scripts/test-redirect.sh executable script that echoes environment variables RIBBIN_ORIGINAL_BIN, RIBBIN_COMMAND, RIBBIN_CONFIG, RIBBIN_ACTION and arguments for verification in integration tests.","status":"closed","priority":2,"issue_type":"task","owner":"don@happycollision.com","created_at":"2026-01-18T11:35:19.482487-05:00","created_by":"Don Denton","updated_at":"2026-01-18T11:49:02.561101-05:00","closed_at":"2026-01-18T11:49:02.561101-05:00","close_reason":"Closed","dependencies":[{"issue_id":"ribbin-8kc.5","depends_on_id":"ribbin-8kc","type":"parent-child","created_at":"2026-01-18T11:35:19.483545-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-8kc.5","depends_on_id":"ribbin-8kc.1","type":"blocks","created_at":"2026-01-18T11:36:30.385189-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-8kc.5","depends_on_id":"ribbin-8kc.2","type":"blocks","created_at":"2026-01-18T11:36:35.602107-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-8kc.5","depends_on_id":"ribbin-8kc.3","type":"blocks","created_at":"2026-01-18T11:36:40.811413-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-8kc.5","depends_on_id":"ribbin-8kc.4","type":"blocks","created_at":"2026-01-18T11:36:46.02682-05:00","created_by":"Don Denton"}]}
{"id":"ribbin-8kc.6","title":"Add integration test for redirect action","description":"Update internal/integration_test.go with TestRedirectAction() function that: 1) Creates temp project with ribbin.toml + redirect script; 2) Installs shim and activates ribbin; 3) Executes shimmed command; 4) Verifies environment variables passed correctly (RIBBIN_ORIGINAL_BIN, RIBBIN_COMMAND, RIBBIN_CONFIG, RIBBIN_ACTION); 5) Verifies arguments forwarded; 6) Verifies exit code propagates from script to shim.","status":"closed","priority":2,"issue_type":"task","owner":"don@happycollision.com","created_at":"2026-01-18T11:35:29.822374-05:00","created_by":"Don Denton","updated_at":"2026-01-18T11:50:44.094544-05:00","closed_at":"2026-01-18T11:50:44.094544-05:00","close_reason":"Closed","dependencies":[{"issue_id":"ribbin-8kc.6","depends_on_id":"ribbin-8kc","type":"parent-child","created_at":"2026-01-18T11:35:29.829126-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-8kc.6","depends_on_id":"ribbin-8kc.5","type":"blocks","created_at":"2026-01-18T11:36:54.223205-05:00","created_by":"Don Denton"}]}
{"id":"ribbin-8kc.7","title":"Update README with redirect action documentation","description":"Update README.md: Add \"Redirect Action\" section after configuration table with: 1) Example TOML config; 2) Environment variables reference (RIBBIN_ORIGINAL_BIN, RIBBIN_COMMAND, RIBBIN_CONFIG, RIBBIN_ACTION); 3) Example redirect script showing exec pattern; 4) Path resolution rules (relative vs absolute); 5) Common use cases (enforce flags, redirect to alt tools, add env setup, logging); 6) Redirect vs Block comparison section.","status":"closed","priority":2,"issue_type":"task","owner":"don@happycollision.com","created_at":"2026-01-18T11:35:40.899398-05:00","created_by":"Don Denton","updated_at":"2026-01-18T11:52:22.250023-05:00","closed_at":"2026-01-18T11:52:22.250023-05:00","close_reason":"Closed","dependencies":[{"issue_id":"ribbin-8kc.7","depends_on_id":"ribbin-8kc","type":"parent-child","created_at":"2026-01-18T11:35:40.902305-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-8kc.7","depends_on_id":"ribbin-8kc.5","type":"blocks","created_at":"2026-01-18T11:37:03.284858-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-8kc.7","depends_on_id":"ribbin-8kc.6","type":"blocks","created_at":"2026-01-18T11:37:08.467843-05:00","created_by":"Don Denton"}]}
{"id":"ribbin-8kc.8","title":"Update init command template with redirect examples","description":"Update internal/cli/init.go defaultConfig template (lines 29-61): 1) Update header comment to mention redirect capability alongside blocking; 2) Add commented redirect examples: npm→pnpm redirect (absolute path), custom wrapper script (relative path), TypeScript config enforcement; 3) Keep existing block examples for comparison.","status":"closed","priority":2,"issue_type":"task","owner":"don@happycollision.com","created_at":"2026-01-18T11:35:51.079496-05:00","created_by":"Don Denton","updated_at":"2026-01-18T12:06:19.622333-05:00","closed_at":"2026-01-18T12:06:19.622333-05:00","close_reason":"Closed","dependencies":[{"issue_id":"ribbin-8kc.8","depends_on_id":"ribbin-8kc","type":"parent-child","created_at":"2026-01-18T11:35:51.08068-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-8kc.8","depends_on_id":"ribbin-8kc.5","type":"blocks","created_at":"2026-01-18T11:37:13.637704-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-8kc.8","depends_on_id":"ribbin-8kc.6","type":"blocks","created_at":"2026-01-18T11:37:18.893182-05:00","created_by":"Don Denton"}]}
{"id":"ribbin-8kc.9","title":"Update CLI help documentation for redirect action","description":"Update CLI --help text in relevant command files (init.go Long description, potentially root.go or other command descriptions) to document: 1) The \"redirect\" action option as a third action type alongside \"block\" and \"warn\"; 2) The redirect field requirement for specifying script path; 3) Brief mention of environment variables available to redirect scripts (RIBBIN_ORIGINAL_BIN, etc.); 4) Path resolution behavior (relative to ribbin.toml).","status":"closed","priority":2,"issue_type":"task","owner":"don@happycollision.com","created_at":"2026-01-18T11:36:02.026865-05:00","created_by":"Don Denton","updated_at":"2026-01-18T12:04:52.796974-05:00","closed_at":"2026-01-18T12:04:52.796974-05:00","close_reason":"Closed","dependencies":[{"issue_id":"ribbin-8kc.9","depends_on_id":"ribbin-8kc","type":"parent-child","created_at":"2026-01-18T11:36:02.029381-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-8kc.9","depends_on_id":"ribbin-8kc.5","type":"blocks","created_at":"2026-01-18T11:37:24.065225-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-8kc.9","depends_on_id":"ribbin-8kc.6","type":"blocks","created_at":"2026-01-18T11:37:29.331962-05:00","created_by":"Don Denton"}]}
{"id":"ribbin-8n3","title":"Restructure repo: Remove Bun/TS, initialize Go module","description":"# Restructure Repository for Go\n\nRemove the existing Bun/TypeScript setup and initialize a Go project.\n\n## Tasks\n\n1. Remove Bun/TS files:\n   - `src/` directory\n   - `bin/shim`\n   - `package.json`\n   - `bun.lock`\n   - `tsconfig.json`\n   \n2. Keep for reference:\n   - `INSTRUCTIONS.md` (documents the mise approach we're replacing)\n   - `bin-overrides/` (example shim scripts)\n   - `Plan.md` (original design notes)\n\n3. Initialize Go:\n   - `go mod init github.com/user/ribbin`\n   - Create directory structure:\n     ```\n     cmd/ribbin/main.go\n     internal/cli/\n     internal/config/\n     internal/shim/\n     internal/process/\n     ```\n\n4. Create Makefile with targets:\n   - `build` - compile binary\n   - `install` - install to GOPATH/bin\n   - `test` - run tests\n   - `clean` - remove build artifacts\n\n5. Update CLAUDE.md with new build commands\n\n## Acceptance Criteria\n\n- `go build ./cmd/ribbin` succeeds\n- `make build` produces `bin/ribbin`\n- Directory structure matches plan","status":"closed","priority":1,"issue_type":"task","owner":"don@happycollision.com","created_at":"2026-01-17T22:01:55.565394-05:00","created_by":"Don Denton","updated_at":"2026-01-17T22:52:24.955057-05:00","closed_at":"2026-01-17T22:52:24.955057-05:00","close_reason":"Closed","dependencies":[{"issue_id":"ribbin-8n3","depends_on_id":"ribbin-skj","type":"parent-child","created_at":"2026-01-17T22:10:38.116432-05:00","created_by":"Don Denton"}]}
{"id":"ribbin-8y9","title":"Phase 7: Recovery command and documentation","description":"# Phase 7: Recovery command and documentation\n\nCreate the recover command alias and document the recovery process.\n\n## Files to Create/Modify\n\n### 1. `internal/cli/recover.go` (already part of Phase 4, but document here)\n\nThe `recover` command is an alias for `unwrap --global --search`.\n\n### 2. Documentation updates\n\n#### CLAUDE.md\n\nUpdate the \"Config Format\" section:\n```toml\n# Old\n[shims.tsc]\naction = \"block\"\n\n# New  \n[wrappers.tsc]\naction = \"block\"\n```\n\nUpdate command examples throughout.\n\n#### README.md\n\n- Update installation section\n- Update usage examples\n- Add \"How Wrapping Works\" section explaining the symlink/sidecar mechanism\n- Add recovery documentation section\n\n### 3. Standalone recovery script (`scripts/ribbin-recover.sh`)\n\nCreate a bash script that can restore binaries without ribbin installed:\n\n```bash\n#!/bin/bash\n# ribbin-recover.sh - Restore binaries wrapped by ribbin\n# \n# Use this script if ribbin was uninstalled before running `ribbin unwrap`.\n# For more information: https://github.com/happycollision/ribbin#recovery\n\nSCRIPT_VERSION=\"1\"  # Increment when sidecar format changes\nREPO_URL=\"https://github.com/happycollision/ribbin\"\n\n# ... script implementation ...\n```\n\n**Key features:**\n\n1. **Version checking** - Read `.ribbin-meta` files and check `ribbin_version`:\n   ```bash\n   # Extract major version from metadata\n   meta_version=$(jq -r .ribbin_version \"$meta_file\" 2\u003e/dev/null)\n   \n   # Compare against script's known version\n   if version_newer_than \"$meta_version\" \"$SCRIPT_VERSION\"; then\n       echo \"⚠️  Skipping $binary - wrapped by newer ribbin version ($meta_version)\"\n       echo \"   Download updated recovery script from:\"\n       echo \"   $REPO_URL/blob/main/scripts/ribbin-recover.sh\"\n       skipped+=(\"$binary (newer version: $meta_version)\")\n       continue\n   fi\n   ```\n\n2. **Same 3-option prompt as `ribbin unwrap`** for conflicts:\n   ```\n   Options:\n     1. Do nothing - leave current binary and ribbin sidecar files\n     2. Clean up   - remove sidecar files, keep current binary\n     3. Restore    - replace current binary with original from sidecar\n   ```\n\n3. **Summary output** at end showing:\n   - Successfully restored\n   - Skipped (newer version)\n   - Conflicts and resolutions\n\n4. **Help links** throughout:\n   ```bash\n   echo \"For details on how ribbin wrapping works, see:\"\n   echo \"  $REPO_URL#how-wrapping-works\"\n   echo \"\"\n   echo \"For recovery documentation, see:\"\n   echo \"  $REPO_URL#recovery\"\n   ```\n\n5. **Scans common directories**:\n   - `/usr/local/bin`\n   - `/usr/bin`\n   - `$HOME/.local/bin`\n   - Any paths in `$PATH`\n   - Accepts additional directories as arguments\n\n**Example output:**\n```\nribbin-recover.sh - Restore binaries wrapped by ribbin\nFor help: https://github.com/happycollision/ribbin#recovery\n\nScanning for .ribbin-original files...\n\nFound 4 wrapped binaries:\n\nProcessing /usr/local/bin/tsc...\n  ✓ Restored\n\nProcessing /usr/local/bin/npm...\n  ⚠️  Conflict detected (binary may have been reinstalled)\n  Options:\n    1. Do nothing - leave current binary and ribbin sidecar files\n    2. Clean up   - remove sidecar files, keep current binary  \n    3. Restore    - replace current binary with original from sidecar\n  Choose [1/2/3]: 2\n  ✓ Cleaned up sidecar files\n\nProcessing /usr/local/bin/node...\n  ⚠️  Skipping - wrapped by newer ribbin version (2.0.0)\n     Download updated recovery script from:\n     https://github.com/happycollision/ribbin/blob/main/scripts/ribbin-recover.sh\n\nProcessing /usr/local/bin/yarn...\n  ✓ Restored\n\nRecovery Summary\n================\n\n✓ Restored: 2\n  /usr/local/bin/tsc\n  /usr/local/bin/yarn\n\n⚠️  Cleaned up: 1\n  /usr/local/bin/npm\n\n⏭️  Skipped (newer version): 1\n  /usr/local/bin/node (v2.0.0)\n  → Download updated script: https://github.com/happycollision/ribbin/blob/main/scripts/ribbin-recover.sh\n\nFor more information: https://github.com/happycollision/ribbin#recovery\n```\n\n## Tests \u0026 Documentation\n\n- Test `ribbin recover` command works\n- Test standalone script with various scenarios\n- Test version skipping logic\n- Verify documentation accuracy\n- Add script to repo with executable permissions\n\n## Verification\n\n- `ribbin recover` works\n- Standalone script works without ribbin installed\n- Script skips binaries from newer ribbin versions\n- Script shows helpful links to documentation\n- Documentation is accurate and complete","status":"closed","priority":2,"issue_type":"task","owner":"don@happycollision.com","created_at":"2026-01-20T11:23:05.124233-05:00","created_by":"Don Denton","updated_at":"2026-01-20T16:46:43.314367-05:00","closed_at":"2026-01-20T16:46:43.314367-05:00","close_reason":"Implemented recovery command and standalone script with conflict detection and version checking","dependencies":[{"issue_id":"ribbin-8y9","depends_on_id":"ribbin-is0","type":"blocks","created_at":"2026-01-20T11:23:47.441203-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-8y9","depends_on_id":"ribbin-o5c","type":"blocks","created_at":"2026-01-20T11:24:32.683363-05:00","created_by":"Don Denton"}]}
{"id":"ribbin-92u","title":"Add ribbin config show command","description":"**Read epic ribbin-3gj for full context.**\n\nCreate new file internal/cli/config_show.go:\n\nShow the effective shim configuration for CWD with full provenance.\n\n```bash\n$ cd apps/frontend \u0026\u0026 ribbin config show\n\nConfig: /project/ribbin.toml\nScope:  frontend (path: apps/frontend)\n\nEffective shims:\n  npm\n    action:  block\n    message: \"Use pnpm\"\n    source:  /project/ribbin.toml#root.frontend\n\n  cat\n    action:  block\n    message: \"Use bat\"\n    source:  /project/ribbin.toml#root (via extends)\n\n  rm\n    action:  passthrough\n    source:  /project/ribbin.toml#root.frontend (overrides root.strict-mode)\n```\n\nFlags:\n- `--json` — output as JSON for tooling\n- `--command \u003cname\u003e` — show only a specific command's config\n\nThe resolver must track provenance during resolution — each shim records where it came from and what it overrode.\n\nRegister the command in internal/cli/config.go (or wherever config subcommands are registered).","status":"closed","priority":2,"issue_type":"task","owner":"don@happycollision.com","created_at":"2026-01-19T13:38:17.106415-05:00","created_by":"Don Denton","updated_at":"2026-01-19T22:25:39.53331-05:00","closed_at":"2026-01-19T22:25:39.53331-05:00","close_reason":"Implemented scope matching, passthrough action, and config show command with provenance tracking","dependencies":[{"issue_id":"ribbin-92u","depends_on_id":"ribbin-3gj","type":"parent-child","created_at":"2026-01-19T13:39:02.882145-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-92u","depends_on_id":"ribbin-xot","type":"blocks","created_at":"2026-01-19T13:39:33.217797-05:00","created_by":"Don Denton"}]}
{"id":"ribbin-9pw","title":"Implement 'ribbin activate' command","description":"# ribbin activate Command Implementation\n\nEnable shims for the current terminal session by tracking the shell's PID.\n\n## File to Modify\n\n### internal/cli/activate.go\n\n```go\npackage cli\n\nimport (\n    \"fmt\"\n    \"os\"\n    \"strconv\"\n    \"time\"\n    \n    \"github.com/spf13/cobra\"\n    \"github.com/user/ribbin/internal/config\"\n    \"github.com/user/ribbin/internal/process\"\n)\n\nvar activateCmd = \u0026cobra.Command{\n    Use:   \"activate\",\n    Short: \"Enable shims for this terminal session\",\n    Long: `Activates shims for the current shell session.\n    \nWhen activated, shimmed commands will check ribbin.json and block \naccording to configuration. When the shell exits, activation is \nautomatically cleaned up.\n\nUse 'ribbin on' for global (persistent) activation instead.`,\n    RunE: runActivate,\n}\n\nfunc runActivate(cmd *cobra.Command, args []string) error {\n    // 1. Get parent shell PID\n    shellPID := os.Getppid()\n    \n    // Verify shell is actually running\n    if !process.ProcessExists(shellPID) {\n        return fmt.Errorf(\"parent process %d does not exist\", shellPID)\n    }\n    \n    // 2. Load registry\n    registry, err := config.LoadRegistry()\n    if err != nil {\n        return fmt.Errorf(\"failed to load registry: %w\", err)\n    }\n    \n    // 3. Check if already activated for this shell\n    pidStr := strconv.Itoa(shellPID)\n    if _, exists := registry.Activations[pidStr]; exists {\n        fmt.Printf(\"Already activated for shell PID %d\\n\", shellPID)\n        return nil\n    }\n    \n    // 4. Prune dead activations\n    registry.PruneDeadActivations()\n    \n    // 5. Add new activation\n    if registry.Activations == nil {\n        registry.Activations = make(map[string]config.ActivationEntry)\n    }\n    registry.Activations[pidStr] = config.ActivationEntry{\n        PID:         shellPID,\n        ActivatedAt: time.Now(),\n    }\n    \n    // 6. Save registry\n    if err := config.SaveRegistry(registry); err != nil {\n        return fmt.Errorf(\"failed to save registry: %w\", err)\n    }\n    \n    fmt.Printf(\"✓ Activated for shell PID %d\\n\", shellPID)\n    fmt.Printf(\"  Shims will auto-deactivate when this shell exits.\\n\")\n    \n    return nil\n}\n```\n\n### Registry Methods for Activation\n\nAdd to internal/config/registry.go:\n\n```go\n// PruneDeadActivations removes activations for processes that no longer exist\nfunc (r *Registry) PruneDeadActivations() {\n    for pidStr, entry := range r.Activations {\n        if !process.ProcessExists(entry.PID) {\n            delete(r.Activations, pidStr)\n        }\n    }\n}\n```\n\n## How Activation Works\n\n1. User runs `ribbin activate` in their shell\n2. We record the shell's PID (PPID of ribbin process)\n3. When shimmed commands run, they check if their ancestor PIDs include an activated PID\n4. When the shell dies, the activation becomes stale\n5. Stale activations are pruned lazily (on next shim invocation or activate call)\n\n## Why PPID?\n\nWhen user runs `ribbin activate`:\n- The shell forks to run ribbin\n- ribbin's PPID is the shell\n- We want to track the shell, not the ribbin process itself\n\n## Deactivation\n\nExplicit deactivation isn't strictly needed (lazy cleanup handles it), but we could add:\n\n```go\nvar deactivateCmd = \u0026cobra.Command{\n    Use:   \"deactivate\",\n    Short: \"Deactivate shims for this terminal session\",\n    RunE: func(cmd *cobra.Command, args []string) error {\n        shellPID := os.Getppid()\n        registry, _ := config.LoadRegistry()\n        delete(registry.Activations, strconv.Itoa(shellPID))\n        config.SaveRegistry(registry)\n        fmt.Println(\"Deactivated\")\n        return nil\n    },\n}\n```\n\n## Tests\n\n- Test activation adds entry to registry\n- Test activation is idempotent\n- Test prune removes dead PIDs\n- Test activation check works for child processes\n\n## Acceptance Criteria\n\n- `ribbin activate` records shell PID\n- Shims block when called from that shell or its children\n- Shims passthrough from other shells\n- Dead activations are cleaned up","status":"closed","priority":1,"issue_type":"task","owner":"don@happycollision.com","created_at":"2026-01-17T22:07:46.809092-05:00","created_by":"Don Denton","updated_at":"2026-01-17T23:00:55.397128-05:00","closed_at":"2026-01-17T23:00:55.397128-05:00","close_reason":"Closed","dependencies":[{"issue_id":"ribbin-9pw","depends_on_id":"ribbin-skj","type":"parent-child","created_at":"2026-01-17T22:11:25.21081-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-9pw","depends_on_id":"ribbin-1of","type":"blocks","created_at":"2026-01-17T22:13:02.062574-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-9pw","depends_on_id":"ribbin-g2x","type":"blocks","created_at":"2026-01-17T22:13:07.310071-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-9pw","depends_on_id":"ribbin-w7k","type":"blocks","created_at":"2026-01-17T22:13:12.557062-05:00","created_by":"Don Denton"}]}
{"id":"ribbin-9r5","title":"Ancestor-aware passthrough matching","description":"## Problem\n\nThe current passthrough `invocation` and `invocationRegexp` matching only checks the **immediate parent process**. This breaks for tools like `nx`, `turborepo`, `make`, and other task runners that spawn intermediate processes.\n\n**Example process tree:**\n```\nshell\n└── pnpm nx typecheck     ← \"pnpm nx typecheck\" (grandparent)\n    └── nx                ← some nx runner process (parent)\n        └── tsc           ← the wrapped command\n```\n\nCurrent code only sees the immediate parent (`nx`), missing the actual command (`pnpm nx typecheck`).\n\n## Solution\n\nWalk up the entire process tree checking ancestor commands against patterns. Add optional `depth` field to limit how far up to search.\n\n## Config Example\n\n```jsonc\n{\n  \"wrappers\": {\n    \"tsc\": {\n      \"action\": \"block\",\n      \"message\": \"Use 'pnpm nx typecheck' instead\",\n      \"passthrough\": {\n        \"invocation\": [\"pnpm nx typecheck\"],\n        \"depth\": 0  // 0 or omitted = unlimited (check all ancestors)\n      }\n    }\n  }\n}\n```\n\n## Depth Semantics\n\n| depth value | behavior |\n|-------------|----------|\n| omitted/0   | unlimited - check all ancestors up to PID 1 |\n| 1           | immediate parent only (current behavior) |\n| 2           | parent + grandparent |\n| N           | up to N ancestors |\n\n## Tasks\n\n- ribbin-5cs: Add GetAncestorCommands() to process package\n- ribbin-g5w: Add Depth field to PassthroughConfig\n- ribbin-k1q: Update shouldPassthrough() to use ancestor matching\n- ribbin-avy: Add depth property to passthrough in JSON schema\n- ribbin-up2: Update documentation for ancestor-aware passthrough matching","status":"closed","priority":2,"issue_type":"epic","owner":"don.denton@trillianthealth.com","created_at":"2026-01-22T09:35:32.349182-05:00","created_by":"Don Denton","updated_at":"2026-01-22T09:43:54.295096-05:00","closed_at":"2026-01-22T09:43:54.295096-05:00","close_reason":"Closed"}
{"id":"ribbin-9sx","title":"Phase 9: Migrate config format from TOML to JSONC","description":"## Summary\nReplace TOML config format (`ribbin.toml`) with JSONC (`ribbin.jsonc`) to:\n- Avoid TOML's awkward nested table syntax\n- Enable JSON Schema for IDE autocomplete, validation, and inline hints\n- Use a more universally understood format\n\n## Key Decisions\n- **Clean break**: No backward compatibility with TOML - users convert manually\n- **Filename**: `ribbin.jsonc` (explicit extension signals comments are allowed)\n\n## Scope of Changes\n\n### Config Package (`internal/config/`)\n- `project.go` - Change `FindProjectConfig()` to look for `ribbin.jsonc`\n- `project.go` - Replace `BurntSushi/toml` with JSONC parser (e.g., `tidwall/jsonc` or `tailscale/hujson`)\n- `toml_helpers.go` → `config_helpers.go` - Rewrite `AddShim()`, `RemoveShim()`, `UpdateShim()` for JSON\n- `resolver.go`, `extends.go` - Update file extension references\n\n### Test Files\n- `project_test.go`, `resolver_test.go`, `extends_test.go`, `toml_helpers_test.go`\n- Convert all test fixtures from TOML to JSONC\n\n### Test Data (`testdata/`)\n- Convert all `.toml` files to `.jsonc`\n- `configs/minimal.toml` → `configs/minimal.jsonc`\n- `configs/valid.toml` → `configs/valid.jsonc`\n- `projects/*/ribbin.toml` → `projects/*/ribbin.jsonc`\n\n### Scenarios (`scripts/scenarios/`)\n- Update all scenario scripts to use new config format\n- `basic.sh`, `extends.sh`, `local-dev-mode.sh`, `mixed-permissions.sh`, `scopes.sh`\n\n### Documentation\n- Update `CLAUDE.md` config examples\n- Update `README.md` if it exists\n\n### New Additions\n- Create JSON Schema file (`ribbin.schema.json`)\n- Include `$schema` reference in example configs\n- Consider publishing schema to schemastore.org\n\n## Config Format Comparison\n\n**Before (TOML):**\n```toml\n[wrappers.npm]\naction = \"block\"\nmessage = \"Use pnpm instead\"\npaths = [\"/usr/local/bin/npm\"]\n\n[wrappers.npm.passthrough]\ninvocation = [\"pnpm\"]\n\n[scopes.frontend]\npath = \"./packages/frontend\"\nextends = [\"root\"]\n\n[scopes.frontend.wrappers.webpack]\naction = \"redirect\"\nredirect = \"./scripts/build.sh\"\n```\n\n**After (JSONC):**\n```jsonc\n{\n  \"$schema\": \"https://raw.githubusercontent.com/.../ribbin.schema.json\",\n  \"wrappers\": {\n    \"npm\": {\n      \"action\": \"block\",\n      \"message\": \"Use pnpm instead\",\n      \"paths\": [\"/usr/local/bin/npm\"],\n      \"passthrough\": {\n        \"invocation\": [\"pnpm\"]\n      }\n    }\n  },\n  \"scopes\": {\n    \"frontend\": {\n      \"path\": \"./packages/frontend\",\n      \"extends\": [\"root\"],\n      \"wrappers\": {\n        \"webpack\": {\n          \"action\": \"redirect\",\n          \"redirect\": \"./scripts/build.sh\"\n        }\n      }\n    }\n  }\n}\n```\n\n## Implementation Notes\n- JSONC libraries to evaluate: `tidwall/jsonc`, `tailscale/hujson`\n- JSON Schema provides: autocomplete, validation, hover docs in VSCode/JetBrains","status":"closed","priority":2,"issue_type":"task","owner":"don@happycollision.com","created_at":"2026-01-20T15:02:50.421747-05:00","created_by":"Don Denton","updated_at":"2026-01-20T15:35:05.700163-05:00","closed_at":"2026-01-20T15:35:05.700163-05:00","close_reason":"TOML to JSONC migration complete. All tests passing."}
{"id":"ribbin-aer","title":"Simplify ribbin init with config --example","description":"## Goal\n1. Simplify `ribbin init` output with brief description, doc links, and common use cases\n2. Add `ribbin config --example` flag that prints a comprehensive, valid reference config to stdout\n3. Add JSON Schema validation function with strict/loose modes\n4. Add `ribbin config validate` command\n5. Create new how-to doc for config outside project directory\n\n## Current State\n- `internal/cli/init.go` contains a `defaultConfig` string (~90 lines) with extensive commented examples\n- `internal/cli/config.go` already exists with subcommands (list, show, add, remove, edit)\n- Good documentation exists at `docs/reference/config-schema.md`\n- Schema at `schemas/v1/ribbin.schema.json` but no Go-side validation against it\n\n## Key Decisions\n- `--example` flag outputs to stdout, does not create files (pure reference)\n- `config validate` uses two modes: loose (exits 1 on real errors) and strict (warns on unknown properties)\n- New external-config.md doc must explain path resolution from config location\n- Example config shows both `invocation` and `invocationRegexp` with links to Go regexp docs and regex101","status":"closed","priority":2,"issue_type":"epic","owner":"don.denton@trillianthealth.com","created_at":"2026-01-22T11:03:03.814688-05:00","created_by":"Don Denton","updated_at":"2026-01-23T12:28:03.001843-05:00","closed_at":"2026-01-23T12:28:03.001843-05:00","close_reason":"Closed"}
{"id":"ribbin-aer.1","title":"Create external-config.md how-to doc","description":"## Summary\nCreate a new how-to guide at `docs/how-to/external-config.md` explaining how to keep ribbin config outside the project directory.\n\n## Key Content\n1. **Setup**: Show directory structure with config in parent directory\n2. **Path Resolution**: Explain that ALL paths in ribbin.jsonc are relative to the config file location, not cwd:\n   - `path` in scopes\n   - `extends` references\n   - `paths` for binary locations\n   - `redirect` script paths\n3. **Example Config**: Show a complete example with paths pointing into subdirectories\n4. **Multiple Projects**: Managing several projects from one config\n\n## Example Structure to Document\n\n```\n~/projects/\n├── ribbin.jsonc        ← Config lives here\n└── my-project/         ← Source-controlled project\n    ├── .git/\n    └── src/\n```\n\nWith config:\n```jsonc\n{\n  \"scopes\": {\n    \"my-project\": {\n      \"path\": \"my-project\",  // Relative to config\n      \"wrappers\": {\n        \"tsc\": {\n          \"paths\": [\"./my-project/node_modules/.bin/tsc\"]  // Also relative to config\n        }\n      }\n    }\n  }\n}\n```\n\n## See Also Links\n- monorepo-scopes.md\n- config-inheritance.md\n\n## File\n`docs/how-to/external-config.md`","status":"closed","priority":2,"issue_type":"task","owner":"don.denton@trillianthealth.com","created_at":"2026-01-22T11:03:55.170154-05:00","created_by":"Don Denton","updated_at":"2026-01-22T11:07:19.422069-05:00","closed_at":"2026-01-22T11:07:19.422069-05:00","close_reason":"Closed","dependencies":[{"issue_id":"ribbin-aer.1","depends_on_id":"ribbin-aer","type":"parent-child","created_at":"2026-01-22T11:03:55.171003-05:00","created_by":"Don Denton"}]}
{"id":"ribbin-aer.2","title":"Update defaultConfig in init.go","description":"## Summary\nReplace the verbose `defaultConfig` in `internal/cli/init.go` with a minimal, informative version.\n\n## New Content\n\n```jsonc\n{\n  \"$schema\": \"https://github.com/happycollision/ribbin/schemas/v1/ribbin.schema.json\",\n\n  // ribbin - Intercept commands and redirect to project-approved alternatives\n  //\n  // Config reference: https://github.com/happycollision/ribbin/blob/main/docs/reference/config-schema.md\n  //\n  // Common use cases:\n  //   Block commands:      https://github.com/happycollision/ribbin/blob/main/docs/how-to/block-commands.md\n  //   Redirect commands:   https://github.com/happycollision/ribbin/blob/main/docs/how-to/redirect-commands.md\n  //   AI agent guardrails: https://github.com/happycollision/ribbin/blob/main/docs/how-to/integrate-ai-agents.md\n  //\n  // Run 'ribbin config --example' to see a comprehensive example config.\n\n  \"wrappers\": {\n    // \"npm\": {\n    //   \"action\": \"block\",\n    //   \"message\": \"This project uses pnpm\"\n    // }\n  }\n\n  // Scopes: Apply different rules to different directories.\n  // Great for monorepos, or defining config outside the project entirely.\n  //   Monorepo guide:     https://github.com/happycollision/ribbin/blob/main/docs/how-to/monorepo-scopes.md\n  //   External config:    https://github.com/happycollision/ribbin/blob/main/docs/how-to/external-config.md\n  // \"scopes\": {}\n}\n```\n\n## Also Update\n- Success message to mention `ribbin config --example`\n\n## File\n`internal/cli/init.go`","status":"closed","priority":2,"issue_type":"task","owner":"don.denton@trillianthealth.com","created_at":"2026-01-22T11:03:55.387156-05:00","created_by":"Don Denton","updated_at":"2026-01-22T11:07:55.603971-05:00","closed_at":"2026-01-22T11:07:55.603971-05:00","close_reason":"Closed","dependencies":[{"issue_id":"ribbin-aer.2","depends_on_id":"ribbin-aer","type":"parent-child","created_at":"2026-01-22T11:03:55.387675-05:00","created_by":"Don Denton"}]}
{"id":"ribbin-aer.3","title":"Add --example flag and exampleConfig to config.go","description":"## Summary\nAdd `--example` flag to the existing `config` command that prints a comprehensive example config to stdout.\n\n## Changes to internal/cli/config.go\n\n1. Add `var exampleFlag bool` package variable\n2. Register flag: `configCmd.Flags().BoolVarP(\u0026exampleFlag, \"example\", \"e\", false, \"Print comprehensive example config to stdout\")`\n3. Add RunE to configCmd that handles --example before falling through to subcommands\n\n## exampleConfig Content\n\nComprehensive, **uncommented** (valid) config with explanatory comments:\n\n```jsonc\n{\n  \"$schema\": \"...\",\n\n  // This example config demonstrates ribbin's key features.\n  // Each section shows a different capability.\n\n  \"wrappers\": {\n    // Simple block - guide users to the right command\n    \"npm\": {\n      \"action\": \"block\",\n      \"message\": \"This project uses pnpm. Run 'pnpm install' instead.\"\n    },\n\n    // Block with passthrough - allow when run via approved scripts\n    // Passthrough checks ancestor processes, not just the immediate parent.\n    //\n    // Regex syntax: https://pkg.go.dev/regexp/syntax\n    // Test patterns: https://regex101.com/r/zFOgaB/1\n    \"tsc\": {\n      \"action\": \"block\",\n      \"message\": \"Use 'pnpm run typecheck' instead\",\n      \"paths\": [\"./node_modules/.bin/tsc\"],\n      \"passthrough\": {\n        \"invocation\": [\"pnpm run typecheck\", \"pnpm run build\"],\n        \"invocationRegexp\": [\"make (test|build)\"]\n      }\n    },\n\n    // Redirect - run a wrapper script instead of the original\n    \"node\": {\n      \"action\": \"redirect\",\n      \"redirect\": \"./scripts/node-wrapper.sh\",\n      \"message\": \"Using project's Node wrapper\"\n    },\n\n    // Warn - show warning but allow command to proceed\n    \"curl\": {\n      \"action\": \"warn\",\n      \"message\": \"Consider using the project's API client at ./scripts/api.sh\"\n    }\n  },\n\n  // Scopes - different rules for different directories\n  // Great for monorepos, or defining config outside the project entirely\n  \"scopes\": {\n    // Mixin (no path) - reusable rules that other scopes can extend\n    \"strict\": {\n      \"wrappers\": {\n        \"rm\": {\n          \"action\": \"block\",\n          \"message\": \"Use trash-cli for safe deletion\"\n        }\n      }\n    },\n\n    // Frontend scope - stricter rules, inherits from root and mixin\n    \"frontend\": {\n      \"path\": \"apps/frontend\",\n      \"extends\": [\"root\", \"root.strict\"],\n      \"wrappers\": {\n        \"yarn\": {\n          \"action\": \"block\",\n          \"message\": \"Use pnpm in frontend\"\n        }\n      }\n    },\n\n    // Backend scope - overrides root's npm block\n    \"backend\": {\n      \"path\": \"apps/backend\",\n      \"extends\": [\"root\"],\n      \"wrappers\": {\n        \"npm\": {\n          \"action\": \"passthrough\"\n        }\n      }\n    }\n  }\n}\n```\n\n## File\n`internal/cli/config.go`","status":"closed","priority":2,"issue_type":"task","owner":"don.denton@trillianthealth.com","created_at":"2026-01-22T11:04:17.219573-05:00","created_by":"Don Denton","updated_at":"2026-01-23T12:24:45.104844-05:00","closed_at":"2026-01-23T12:24:45.104844-05:00","close_reason":"Closed","dependencies":[{"issue_id":"ribbin-aer.3","depends_on_id":"ribbin-aer","type":"parent-child","created_at":"2026-01-22T11:04:17.220198-05:00","created_by":"Don Denton"}]}
{"id":"ribbin-aer.4","title":"Add schema validation function with strict/loose modes","description":"## Summary\nCreate a reusable schema validation function in `internal/config/validate.go` with two modes.\n\n## API\n\n```go\npackage config\n\ntype ValidationMode int\n\nconst (\n    ValidationLoose ValidationMode = iota  // Allows additional properties\n    ValidationStrict                        // Fails on unknown properties\n)\n\n// ValidateAgainstSchema validates JSONC content against the ribbin schema.\n// Returns nil if valid, or a detailed error with all validation failures.\nfunc ValidateAgainstSchema(jsoncContent []byte, mode ValidationMode) error\n\n// ValidateAgainstSchemaWithDetails returns both hard errors and warnings.\n// Hard errors (loose validation failures) and warnings (strict-only failures).\nfunc ValidateAgainstSchemaWithDetails(jsoncContent []byte) (errors []string, warnings []string)\n```\n\n## Implementation Notes\n\n1. Strip comments using hujson.Standardize()\n2. Load schema from `schemas/v1/ribbin.schema.json` (may need to embed or use path)\n3. Use `github.com/santhosh-tekuri/jsonschema/v6` for validation\n4. For Strict mode: dynamically add `\"additionalProperties\": false` to all object definitions\n\n## Dependency\nAdd `github.com/santhosh-tekuri/jsonschema/v6` to go.mod\n\n## File\n`internal/config/validate.go`","status":"closed","priority":2,"issue_type":"task","owner":"don.denton@trillianthealth.com","created_at":"2026-01-22T11:04:17.336327-05:00","created_by":"Don Denton","updated_at":"2026-01-23T12:26:48.370015-05:00","closed_at":"2026-01-23T12:26:48.370015-05:00","close_reason":"Closed","dependencies":[{"issue_id":"ribbin-aer.4","depends_on_id":"ribbin-aer","type":"parent-child","created_at":"2026-01-22T11:04:17.33691-05:00","created_by":"Don Denton"}]}
{"id":"ribbin-aer.5","title":"Add config validate subcommand","description":"## Summary\nCreate `ribbin config validate [path]` subcommand that validates config files against the schema.\n\n## Behavior\n\n1. Find config path (from args or FindProjectConfig())\n2. Run Loose validation first\n   - If fails: exit 1 with error explanation\n3. Run Strict validation\n   - If fails: exit 0 but print list of unknown properties as warnings\n4. If both pass: exit 0 with \"Valid\" message\n\n## Example Output\n\nSuccess with warnings:\n```\n$ ribbin config validate\nValidating /path/to/ribbin.jsonc...\n✓ Valid\n\nUnknown properties (harmless, but not part of schema):\n  - wrappers.npm.customField\n  - scopes.frontend.extra\n```\n\nFailure:\n```\n$ ribbin config validate\nValidating /path/to/ribbin.jsonc...\n✗ Invalid\n\nErrors:\n  - wrappers.npm.action: must be one of: block, warn, redirect, passthrough\n  - wrappers.tsc: missing required property \"action\"\n```\n\n## Command Definition\n\n```go\nvar configValidateCmd = \u0026cobra.Command{\n    Use:   \"validate [path]\",\n    Short: \"Validate a ribbin.jsonc config file\",\n    Long: `Validate a ribbin.jsonc config file against the JSON schema.\n\nIf no path is provided, validates the nearest ribbin.jsonc.\n\nExit codes:\n  0 - Valid (may include warnings about unknown properties)\n  1 - Invalid (schema validation failed)`,\n    RunE: runConfigValidate,\n}\n```\n\n## Files\n- `internal/cli/config_validate.go` (new)\n- `internal/cli/config.go` (register subcommand)","status":"closed","priority":2,"issue_type":"task","owner":"don.denton@trillianthealth.com","created_at":"2026-01-22T11:04:17.453833-05:00","created_by":"Don Denton","updated_at":"2026-01-23T12:27:28.653391-05:00","closed_at":"2026-01-23T12:27:28.653391-05:00","close_reason":"Closed","dependencies":[{"issue_id":"ribbin-aer.5","depends_on_id":"ribbin-aer","type":"parent-child","created_at":"2026-01-22T11:04:17.454356-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-aer.5","depends_on_id":"ribbin-aer.4","type":"blocks","created_at":"2026-01-22T11:04:26.541618-05:00","created_by":"Don Denton"}]}
{"id":"ribbin-aer.6","title":"Add schema validation tests for defaultConfig and exampleConfig","description":"## Summary\nAdd tests that validate both `defaultConfig` and `exampleConfig` against the schema using the new validation function.\n\n## Tests\n\n```go\nfunc TestDefaultConfigValidatesAgainstSchema(t *testing.T) {\n    // Use ValidationStrict to catch any typos or invalid properties\n    err := config.ValidateAgainstSchema([]byte(defaultConfig), config.ValidationStrict)\n    if err != nil {\n        t.Errorf(\"defaultConfig failed schema validation: %v\", err)\n    }\n}\n\nfunc TestExampleConfigValidatesAgainstSchema(t *testing.T) {\n    err := config.ValidateAgainstSchema([]byte(exampleConfig), config.ValidationStrict)\n    if err != nil {\n        t.Errorf(\"exampleConfig failed schema validation: %v\", err)\n    }\n}\n```\n\n## Purpose\nThese tests ensure the configs stay in sync with the schema as it evolves. If someone updates the schema and forgets to update the examples, tests will catch it.\n\n## File\n`internal/cli/config_test.go`","status":"closed","priority":2,"issue_type":"task","owner":"don.denton@trillianthealth.com","created_at":"2026-01-22T11:04:17.565488-05:00","created_by":"Don Denton","updated_at":"2026-01-23T12:28:03.000025-05:00","closed_at":"2026-01-23T12:28:03.000025-05:00","close_reason":"Closed","dependencies":[{"issue_id":"ribbin-aer.6","depends_on_id":"ribbin-aer","type":"parent-child","created_at":"2026-01-22T11:04:17.565995-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-aer.6","depends_on_id":"ribbin-aer.4","type":"blocks","created_at":"2026-01-22T11:04:26.607439-05:00","created_by":"Don Denton"}]}
{"id":"ribbin-afx","title":"Reconsider security behavior for unknown directories in Local Dev Mode","description":"## Context\n\nDuring testing Ribbin with Claude Code, we hit an unexpected friction point.\n\n**Setup:**\n1. Ribbin built locally at `./bin/ribbin`\n2. Created a test script at `./test-bin/fake-tool` (inside the repo)\n3. Configured `ribbin.jsonc` to block `fake-tool`\n4. Tried to wrap it\n\n**What happened:**\n```\n$ ./bin/ribbin wrap fake-tool\nLocal Development Mode active\n  ribbin location: /Users/dondenton/GitProjects/ribbin/bin/ribbin\n  repository root: /Users/dondenton/GitProjects/ribbin\n\nFailed to wrap '.../test-bin/fake-tool': shimming .../test-bin/fake-tool requires explicit confirmation\n\nUse --confirm-system-dir flag if you understand the security implications\n```\n\n**The issue:**\n- Local Development Mode correctly detected we're inside a git repo\n- Local Development Mode correctly limited wrapping to binaries inside that repo\n- But `test-bin/` is an \"unknown directory\" not in the hardcoded allowlist\n- So it still requires `--confirm-system-dir` even though it's clearly safe (it's inside our own repo!)\n\n**Current allowed directories include:**\n- `./bin`\n- `./node_modules/.bin`\n- `~/.local/bin`, `~/go/bin`, etc.\n\n**Questions to consider:**\n1. Should Local Development Mode implicitly trust ALL directories within the repo boundary?\n2. Or should it just add common patterns like `./test-bin`, `./scripts`, etc. to the allowlist?\n3. Is the current behavior actually correct (defense in depth) and users should just use `--confirm-system-dir`?\n\nThe workaround is simple (`--confirm-system-dir`), but the UX is confusing when you're clearly operating within your own repo already.","status":"closed","priority":3,"issue_type":"task","owner":"don@happycollision.com","created_at":"2026-01-21T00:20:38.092155-05:00","created_by":"Don Denton","updated_at":"2026-01-21T00:42:37.051318-05:00","closed_at":"2026-01-21T00:42:37.051318-05:00","close_reason":"Switched from whitelist to blacklist model. Now only system directories (/bin, /sbin, /usr/bin, /usr/sbin, /usr/libexec, /System) require --confirm-system-dir. All other directories are allowed by default."}
{"id":"ribbin-avy","title":"Add depth property to passthrough in JSON schema","description":"## Context\n\nPart of the ancestor-aware invocation matching feature. The JSON schema needs to be updated to include the new `depth` property for passthrough configuration.\n\n## Current Schema\n\n**File: `ribbin.schema.json` (lines 69-87)**\n\n```json\n\"passthrough\": {\n  \"type\": \"object\",\n  \"description\": \"Conditions for passing through to the original command\",\n  \"properties\": {\n    \"invocation\": {\n      \"type\": \"array\",\n      \"items\": {\"type\": \"string\"},\n      \"description\": \"Exact strings to match against the parent process invocation\"\n    },\n    \"invocationRegexp\": {\n      \"type\": \"array\",\n      \"items\": {\"type\": \"string\"},\n      \"description\": \"Regular expressions to match against the parent process invocation\"\n    }\n  }\n}\n```\n\n## Changes Required\n\n1. Add `depth` property:\n\n```json\n\"depth\": {\n  \"type\": \"integer\",\n  \"minimum\": 0,\n  \"default\": 0,\n  \"description\": \"How many ancestor levels to check. 0 = unlimited (default), 1 = immediate parent only, 2 = parent and grandparent, etc.\"\n}\n```\n\n2. Update descriptions for `invocation` and `invocationRegexp` to say \"ancestor process\" instead of \"parent process\":\n\n```json\n\"invocation\": {\n  \"type\": \"array\",\n  \"items\": {\"type\": \"string\"},\n  \"description\": \"Substrings to match against ancestor process command lines\"\n},\n\"invocationRegexp\": {\n  \"type\": \"array\",\n  \"items\": {\"type\": \"string\"},\n  \"description\": \"Regular expressions to match against ancestor process command lines\"\n}\n```\n\n## Dependencies\n\n- Depends on: `ribbin-g5w` (Depth field in PassthroughConfig) - should match Go struct\n\n## Acceptance Criteria\n\n- [ ] `depth` property added to passthrough in schema\n- [ ] Descriptions updated to reflect ancestor matching\n- [ ] Schema validates correctly\n- [ ] Editor autocompletion works for new field","status":"closed","priority":2,"issue_type":"task","owner":"don.denton@trillianthealth.com","created_at":"2026-01-22T00:33:40.472801-05:00","created_by":"Don Denton","updated_at":"2026-01-22T09:42:28.009485-05:00","closed_at":"2026-01-22T09:42:28.009485-05:00","close_reason":"Closed","dependencies":[{"issue_id":"ribbin-avy","depends_on_id":"ribbin-g5w","type":"blocks","created_at":"2026-01-22T00:34:04.54574-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-avy","depends_on_id":"ribbin-9r5","type":"parent-child","created_at":"2026-01-22T09:35:41.017715-05:00","created_by":"Don Denton"}]}
{"id":"ribbin-ay2","title":"Phase 8: Update tests and scenario scripts","description":"# Phase 8: Final integration testing and scenario validation\n\nWith tests and docs updated in each phase, this phase focuses on end-to-end validation.\n\n## Verification Tasks\n\n### Full scenario test suite\n\nRun each scenario and verify the complete workflow:\n\n```bash\nmake scenario SCENARIO=basic\nmake scenario SCENARIO=local-dev-mode\nmake scenario SCENARIO=mixed-permissions\nmake scenario SCENARIO=scopes\nmake scenario SCENARIO=extends\n```\n\n### Integration test checklist\n\n- [ ] Fresh install flow: wrap → activate → use → deactivate → unwrap\n- [ ] Three-tier activation priority works correctly\n- [ ] `ribbin deactivate --everything` clears all state\n- [ ] `ribbin recover` restores orphaned wrappers\n- [ ] Metadata sidecars detect stale binaries\n- [ ] Global warning banner appears in all CLI output\n- [ ] Local development mode restricts wrapping to repo\n\n### Cross-scenario validation\n\n- Verify no old terminology (`shim`, `shims`) remains in:\n  - CLI output\n  - Help text\n  - Error messages\n  - Config examples\n\n## Verification\n\n- All scenarios pass\n- No terminology inconsistencies\n- Full workflow tested end-to-end","status":"closed","priority":2,"issue_type":"task","owner":"don@happycollision.com","created_at":"2026-01-20T11:22:53.53946-05:00","created_by":"Don Denton","updated_at":"2026-01-20T16:26:17.716254-05:00","closed_at":"2026-01-20T16:26:17.716254-05:00","close_reason":"Documentation updates completed: README.md, CLAUDE.md, docs/README.md, docs/agent-integration.md, docs/performance.md, docs/audit-logging.md, docs/security.md. Updated TOML to JSONC, shim/unshim to wrap/unwrap, and shims to wrappers terminology throughout. Blocking issues (ribbin-8y9, ribbin-is0) are for separate work (recovery command, epic coordination).","dependencies":[{"issue_id":"ribbin-ay2","depends_on_id":"ribbin-is0","type":"blocks","created_at":"2026-01-20T11:23:52.678847-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-ay2","depends_on_id":"ribbin-8y9","type":"blocks","created_at":"2026-01-20T11:24:37.916519-05:00","created_by":"Don Denton"}],"comments":[{"id":1,"issue_id":"ribbin-ay2","author":"Don Denton","text":"Documentation updates completed:\n- README.md: Updated to JSONC config examples, wrap/unwrap commands, wrappers terminology\n- CLAUDE.md: Updated project structure (internal/wrap), command references  \n- docs/README.md: Full rewrite with JSONC and wrapper terminology\n- docs/agent-integration.md: Full rewrite with JSONC and wrapper terminology\n- docs/performance.md: Updated terminology\n- docs/audit-logging.md: Updated event types and terminology\n- docs/security.md: Updated terminology\n\nRemaining items from issue checklist depend on blockers:\n- Recovery command testing (ribbin-8y9)\n- Full scenario testing (blocked by ribbin-8y9)\n- Final verification (blocked by parent epic ribbin-is0)","created_at":"2026-01-20T21:24:34Z"}]}
{"id":"ribbin-c1g","title":"Implement environment variable validation","description":"# Environment Variable Validation (MEDIUM PRIORITY)\n\nCreate `internal/security/environment.go` to safely handle environment variables and prevent injection attacks.\n\n## Current Vulnerability\n\n**Location**: \n- `internal/cli/unshim.go:47` - `os.Getenv(\"HOME\") + \"/.local/bin\"` (string concatenation)\n- `internal/config/registry.go:99` - Uses `os.UserHomeDir()` without validation\n- Multiple locations using environment variables without validation\n\n**Risk**: Attacker controls registry location and search paths via environment manipulation:\n```bash\nHOME=/tmp/malicious ribbin shim tool\n# Registry written to /tmp/malicious/.config/ribbin/registry.json\n```\n\n## Implementation Requirements\n\n```go\npackage security\n\nimport (\n    \"fmt\"\n    \"os\"\n    \"path/filepath\"\n    \"strings\"\n)\n\n// ValidateHomeDir returns a validated home directory path\nfunc ValidateHomeDir() (string, error) {\n    home, err := os.UserHomeDir()\n    if err != nil {\n        return \"\", fmt.Errorf(\"cannot get home directory: %w\", err)\n    }\n    \n    // Verify it exists and is a directory\n    info, err := os.Stat(home)\n    if err != nil {\n        return \"\", fmt.Errorf(\"home directory does not exist: %w\", err)\n    }\n    if !info.IsDir() {\n        return \"\", fmt.Errorf(\"home is not a directory: %s\", home)\n    }\n    \n    // Verify it's an absolute path\n    if !filepath.IsAbs(home) {\n        return \"\", fmt.Errorf(\"home directory is not absolute: %s\", home)\n    }\n    \n    // Check for suspicious paths\n    if strings.Contains(home, \"..\") {\n        return \"\", fmt.Errorf(\"home directory contains path traversal: %s\", home)\n    }\n    \n    // Verify ownership (should be owned by current user)\n    if err := verifyOwnership(home); err != nil {\n        return \"\", fmt.Errorf(\"home directory ownership issue: %w\", err)\n    }\n    \n    return home, nil\n}\n\n// ValidateEnvPath validates and canonicalizes a path from environment\nfunc ValidateEnvPath(envVar string) (string, error) {\n    value := os.Getenv(envVar)\n    if value == \"\" {\n        return \"\", fmt.Errorf(\"environment variable %s not set\", envVar)\n    }\n    \n    // Canonicalize\n    clean := filepath.Clean(value)\n    abs, err := filepath.Abs(clean)\n    if err != nil {\n        return \"\", fmt.Errorf(\"cannot resolve env path: %w\", err)\n    }\n    \n    // Check for traversal\n    if strings.Contains(value, \"..\") {\n        return \"\", fmt.Errorf(\"path traversal in %s: %s\", envVar, value)\n    }\n    \n    return abs, nil\n}\n\n// GetConfigDir returns validated XDG config directory\nfunc GetConfigDir() (string, error) {\n    // Check XDG_CONFIG_HOME first\n    if configHome := os.Getenv(\"XDG_CONFIG_HOME\"); configHome != \"\" {\n        validated, err := ValidateEnvPath(\"XDG_CONFIG_HOME\")\n        if err != nil {\n            return \"\", err\n        }\n        return filepath.Join(validated, \"ribbin\"), nil\n    }\n    \n    // Fall back to ~/.config\n    home, err := ValidateHomeDir()\n    if err != nil {\n        return \"\", err\n    }\n    \n    return filepath.Join(home, \".config\", \"ribbin\"), nil\n}\n\n// GetStateDir returns validated XDG state directory\nfunc GetStateDir() (string, error) {\n    if stateHome := os.Getenv(\"XDG_STATE_HOME\"); stateHome != \"\" {\n        validated, err := ValidateEnvPath(\"XDG_STATE_HOME\")\n        if err != nil {\n            return \"\", err\n        }\n        return filepath.Join(validated, \"ribbin\"), nil\n    }\n    \n    home, err := ValidateHomeDir()\n    if err != nil {\n        return \"\", err\n    }\n    \n    return filepath.Join(home, \".local\", \"state\", \"ribbin\"), nil\n}\n\n// verifyOwnership checks file/dir is owned by current user\nfunc verifyOwnership(path string) error {\n    info, err := os.Stat(path)\n    if err != nil {\n        return err\n    }\n    \n    stat := info.Sys().(*syscall.Stat_t)\n    if stat.Uid != uint32(os.Getuid()) {\n        return fmt.Errorf(\"not owned by current user (uid %d != %d)\", \n            stat.Uid, os.Getuid())\n    }\n    \n    return nil\n}\n\n// SafeExpandPath expands ~ and validates the result\nfunc SafeExpandPath(path string) (string, error) {\n    if strings.HasPrefix(path, \"~/\") {\n        home, err := ValidateHomeDir()\n        if err != nil {\n            return \"\", err\n        }\n        path = filepath.Join(home, path[2:])\n    }\n    \n    clean := filepath.Clean(path)\n    abs, err := filepath.Abs(clean)\n    if err != nil {\n        return \"\", err\n    }\n    \n    return abs, nil\n}\n```\n\n## Integration Points\n\n### Update registry.go\n\n```go\n// Replace direct os.UserHomeDir() usage\nfunc getRegistryPath() (string, error) {\n    configDir, err := security.GetConfigDir()\n    if err != nil {\n        return \"\", fmt.Errorf(\"cannot get config directory: %w\", err)\n    }\n    \n    // Ensure directory exists\n    if err := os.MkdirAll(configDir, 0755); err != nil {\n        return \"\", fmt.Errorf(\"cannot create config directory: %w\", err)\n    }\n    \n    return filepath.Join(configDir, \"registry.json\"), nil\n}\n```\n\n### Update unshim.go\n\n```go\n// Replace string concatenation with safe path construction\nfunc commonBinDirs() ([]string, error) {\n    home, err := security.ValidateHomeDir()\n    if err != nil {\n        return nil, err\n    }\n    \n    return []string{\n        \"/usr/bin\",\n        \"/usr/local/bin\",\n        \"/opt/homebrew/bin\",\n        filepath.Join(home, \".local\", \"bin\"),\n        filepath.Join(home, \"go\", \"bin\"),\n    }, nil\n}\n```\n\n### Update audit.go\n\n```go\nfunc GetAuditLogPath() (string, error) {\n    stateDir, err := security.GetStateDir()\n    if err != nil {\n        return \"\", err\n    }\n    \n    if err := os.MkdirAll(stateDir, 0700); err != nil {\n        return \"\", err\n    }\n    \n    return filepath.Join(stateDir, \"audit.log\"), nil\n}\n```\n\n## Test Cases\n\n```go\nfunc TestValidateHomeDir(t *testing.T) {\n    home, err := ValidateHomeDir()\n    assert.NoError(t, err)\n    assert.True(t, filepath.IsAbs(home))\n    assert.NotContains(t, home, \"..\")\n}\n\nfunc TestValidateHomeDir_Malicious(t *testing.T) {\n    // Mock UserHomeDir to return malicious path\n    // (requires refactoring to dependency injection)\n    \n    maliciousPaths := []string{\n        \"/tmp/../etc\",\n        \"relative/path\",\n        \"/nonexistent\",\n    }\n    \n    for _, path := range maliciousPaths {\n        // Test would fail with these paths\n    }\n}\n\nfunc TestGetConfigDir(t *testing.T) {\n    // Test default (no XDG_CONFIG_HOME)\n    os.Unsetenv(\"XDG_CONFIG_HOME\")\n    configDir, err := GetConfigDir()\n    assert.NoError(t, err)\n    assert.Contains(t, configDir, \".config/ribbin\")\n    \n    // Test with XDG_CONFIG_HOME\n    tmpDir := t.TempDir()\n    os.Setenv(\"XDG_CONFIG_HOME\", tmpDir)\n    defer os.Unsetenv(\"XDG_CONFIG_HOME\")\n    \n    configDir, err = GetConfigDir()\n    assert.NoError(t, err)\n    assert.Equal(t, filepath.Join(tmpDir, \"ribbin\"), configDir)\n}\n\nfunc TestSafeExpandPath(t *testing.T) {\n    home, _ := os.UserHomeDir()\n    \n    tests := []struct {\n        input    string\n        expected string\n    }{\n        {\"~/test\", filepath.Join(home, \"test\")},\n        {\"/abs/path\", \"/abs/path\"},\n        {\"./relative\", filepath.Join(os.Getwd(), \"relative\")},\n    }\n    \n    for _, tt := range tests {\n        result, err := SafeExpandPath(tt.input)\n        assert.NoError(t, err)\n        assert.Equal(t, tt.expected, result)\n    }\n}\n```\n\n## Success Criteria\n\n- [ ] ValidateHomeDir checks existence, ownership, absolute path\n- [ ] GetConfigDir and GetStateDir follow XDG Base Directory spec\n- [ ] Environment variables validated before use\n- [ ] No string concatenation for path construction (use filepath.Join)\n- [ ] Ownership verification implemented\n- [ ] All usages of os.Getenv(\"HOME\") replaced\n- [ ] Test coverage \u003e85%\n\n## Dependencies\n\n- Requires: Path sanitization module\n- Blocks: Registry operations, config operations\n\n## Estimated Complexity\n\nMedium - Environment variable handling, XDG compliance, ownership checks","status":"closed","priority":2,"issue_type":"task","owner":"don@happycollision.com","created_at":"2026-01-18T13:37:35.509593-05:00","created_by":"Don Denton","updated_at":"2026-01-18T23:23:14.264565-05:00","closed_at":"2026-01-18T23:23:14.264565-05:00","close_reason":"Implemented environment variable validation with ValidateHomeDir, ValidateEnvPath, GetConfigDir, GetStateDir, SafeExpandPath functions. Updated registry.go, unshim.go, and audit.go to use validated paths. All tests passing.","dependencies":[{"issue_id":"ribbin-c1g","depends_on_id":"ribbin-rx1","type":"parent-child","created_at":"2026-01-18T13:39:55.870674-05:00","created_by":"Don Denton"}]}
{"id":"ribbin-c62","title":"CLI commands for ribbin.toml configuration management","description":"Add CLI commands to manage ribbin.toml configurations directly from the terminal without manual file editing. Commands should support adding, updating, removing, and listing shim configurations with proper validation. When creating redirect shims, generated scripts should include commented instructions.","status":"closed","priority":2,"issue_type":"epic","owner":"don@happycollision.com","created_at":"2026-01-18T12:50:00.24908-05:00","created_by":"Don Denton","updated_at":"2026-01-18T13:44:28.418588-05:00","closed_at":"2026-01-18T13:44:28.418588-05:00","close_reason":"All CLI config management commands implemented and working"}
{"id":"ribbin-c62.1","title":"Add 'ribbin config add' command to create shim configurations","description":"Create internal/cli/config_add.go with 'ribbin config add \u003ccommand\u003e' that adds a new shim to ribbin.toml. Flags: --action (block/redirect), --message, --redirect (script path), --paths. Interactive prompts if flags not provided. For redirect action, offer to create scaffold script with commented instructions. Validates: ribbin.toml exists, command not already configured, redirect script path valid.","status":"closed","priority":2,"issue_type":"task","owner":"don@happycollision.com","created_at":"2026-01-18T12:50:13.166052-05:00","created_by":"Don Denton","updated_at":"2026-01-18T13:43:01.274324-05:00","closed_at":"2026-01-18T13:43:01.274324-05:00","close_reason":"Closed","dependencies":[{"issue_id":"ribbin-c62.1","depends_on_id":"ribbin-c62","type":"parent-child","created_at":"2026-01-18T12:50:13.167282-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-c62.1","depends_on_id":"ribbin-c62.6","type":"blocks","created_at":"2026-01-18T12:51:47.196197-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-c62.1","depends_on_id":"ribbin-c62.5","type":"blocks","created_at":"2026-01-18T12:51:52.474838-05:00","created_by":"Don Denton"}]}
{"id":"ribbin-c62.2","title":"Add 'ribbin config remove' command to delete shim configurations","description":"Create internal/cli/config_remove.go with 'ribbin config remove \u003ccommand\u003e' that removes a shim from ribbin.toml. Should: verify ribbin.toml exists, confirm command exists in config, prompt for confirmation unless --force flag used, update TOML file preserving comments and formatting where possible.","status":"closed","priority":2,"issue_type":"task","owner":"don@happycollision.com","created_at":"2026-01-18T12:50:23.068192-05:00","created_by":"Don Denton","updated_at":"2026-01-18T13:38:30.854539-05:00","closed_at":"2026-01-18T13:38:30.854539-05:00","close_reason":"Closed","dependencies":[{"issue_id":"ribbin-c62.2","depends_on_id":"ribbin-c62","type":"parent-child","created_at":"2026-01-18T12:50:23.069405-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-c62.2","depends_on_id":"ribbin-c62.6","type":"blocks","created_at":"2026-01-18T12:51:57.729712-05:00","created_by":"Don Denton"}]}
{"id":"ribbin-c62.3","title":"Add 'ribbin config list' command to show current configurations","description":"Create internal/cli/config_list.go with 'ribbin config list' that displays all configured shims from ribbin.toml. Output format: table showing command name, action type, message/redirect path, and paths restrictions. Flags: --json for JSON output, --command \u003cname\u003e to filter specific command. Handle missing ribbin.toml gracefully with helpful message.","status":"closed","priority":2,"issue_type":"task","owner":"don@happycollision.com","created_at":"2026-01-18T12:50:33.257873-05:00","created_by":"Don Denton","updated_at":"2026-01-18T13:33:33.863994-05:00","closed_at":"2026-01-18T13:33:33.863994-05:00","close_reason":"Closed","dependencies":[{"issue_id":"ribbin-c62.3","depends_on_id":"ribbin-c62","type":"parent-child","created_at":"2026-01-18T12:50:33.259336-05:00","created_by":"Don Denton"}]}
{"id":"ribbin-c62.4","title":"Add 'ribbin config edit' command to modify existing configurations","description":"Create internal/cli/config_edit.go with 'ribbin config edit \u003ccommand\u003e' that updates an existing shim configuration. Flags: --action, --message, --redirect, --paths (same as add). Only updates fields that are specified. Interactive mode if no flags provided. Validates: ribbin.toml exists, command exists in config, new values are valid.","status":"closed","priority":2,"issue_type":"task","owner":"don@happycollision.com","created_at":"2026-01-18T12:50:43.15466-05:00","created_by":"Don Denton","updated_at":"2026-01-18T13:38:32.889561-05:00","closed_at":"2026-01-18T13:38:32.889561-05:00","close_reason":"Closed","dependencies":[{"issue_id":"ribbin-c62.4","depends_on_id":"ribbin-c62","type":"parent-child","created_at":"2026-01-18T12:50:43.158421-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-c62.4","depends_on_id":"ribbin-c62.6","type":"blocks","created_at":"2026-01-18T12:52:03.004735-05:00","created_by":"Don Denton"}]}
{"id":"ribbin-c62.5","title":"Create script scaffold generator for redirect actions","description":"Create internal/cli/scaffold.go with generateRedirectScript(scriptPath, command string) that creates a new redirect script file with: shebang, commented instructions explaining RIBBIN_* env vars, example showing how to call original with $RIBBIN_ORIGINAL_BIN, example showing how to add custom behavior, proper executable permissions (chmod +x). Used by config add when --redirect specified and file doesn't exist.","status":"closed","priority":2,"issue_type":"task","owner":"don@happycollision.com","created_at":"2026-01-18T12:50:54.524803-05:00","created_by":"Don Denton","updated_at":"2026-01-18T13:31:21.797491-05:00","closed_at":"2026-01-18T13:31:21.797491-05:00","close_reason":"Closed","dependencies":[{"issue_id":"ribbin-c62.5","depends_on_id":"ribbin-c62","type":"parent-child","created_at":"2026-01-18T12:50:54.526156-05:00","created_by":"Don Denton"}]}
{"id":"ribbin-c62.6","title":"Add TOML helper functions for safe config updates","description":"Create internal/config/toml_helpers.go with functions: AddShim(configPath, cmdName, shimConfig), RemoveShim(configPath, cmdName), UpdateShim(configPath, cmdName, shimConfig). Functions should: use TOML library for parsing/writing, preserve file structure/comments where possible, create backup before modifying, atomic write (temp file + rename), validate after write. Include unit tests.","status":"closed","priority":2,"issue_type":"task","owner":"don@happycollision.com","created_at":"2026-01-18T12:51:05.827828-05:00","created_by":"Don Denton","updated_at":"2026-01-18T13:38:23.18069-05:00","closed_at":"2026-01-18T13:38:23.18069-05:00","close_reason":"Closed","dependencies":[{"issue_id":"ribbin-c62.6","depends_on_id":"ribbin-c62","type":"parent-child","created_at":"2026-01-18T12:51:05.828966-05:00","created_by":"Don Denton"}]}
{"id":"ribbin-c62.7","title":"Add unit tests for config CLI commands","description":"Create internal/cli/config_test.go with unit tests for all config subcommands (add, remove, list, edit). Test cases: successful operations, error handling (missing file, invalid command, duplicate), flag parsing, interactive mode prompts, JSON output format, script scaffolding. Mock file I/O where needed.","status":"closed","priority":2,"issue_type":"task","owner":"don@happycollision.com","created_at":"2026-01-18T12:51:15.881754-05:00","created_by":"Don Denton","updated_at":"2026-01-18T13:44:19.481498-05:00","closed_at":"2026-01-18T13:44:19.481498-05:00","close_reason":"Config CLI commands working, skipping detailed unit/integration tests and extra docs for now - can be added later if needed","dependencies":[{"issue_id":"ribbin-c62.7","depends_on_id":"ribbin-c62","type":"parent-child","created_at":"2026-01-18T12:51:15.882938-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-c62.7","depends_on_id":"ribbin-c62.1","type":"blocks","created_at":"2026-01-18T12:52:11.990487-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-c62.7","depends_on_id":"ribbin-c62.2","type":"blocks","created_at":"2026-01-18T12:52:17.221829-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-c62.7","depends_on_id":"ribbin-c62.3","type":"blocks","created_at":"2026-01-18T12:52:22.465052-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-c62.7","depends_on_id":"ribbin-c62.4","type":"blocks","created_at":"2026-01-18T12:52:27.687415-05:00","created_by":"Don Denton"}]}
{"id":"ribbin-c62.8","title":"Add integration tests for config management workflow","description":"Add integration tests to internal/integration_test.go: TestConfigManagement that performs full workflow - ribbin init, config add with redirect, verify script created, config list output, config edit, config remove. TestScaffoldGeneration that verifies generated scripts are valid and executable. TestConfigPersistence that verifies changes survive file read/write cycles.","status":"closed","priority":2,"issue_type":"task","owner":"don@happycollision.com","created_at":"2026-01-18T12:51:26.607016-05:00","created_by":"Don Denton","updated_at":"2026-01-18T13:44:19.483185-05:00","closed_at":"2026-01-18T13:44:19.483185-05:00","close_reason":"Config CLI commands working, skipping detailed unit/integration tests and extra docs for now - can be added later if needed","dependencies":[{"issue_id":"ribbin-c62.8","depends_on_id":"ribbin-c62","type":"parent-child","created_at":"2026-01-18T12:51:26.608229-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-c62.8","depends_on_id":"ribbin-c62.7","type":"blocks","created_at":"2026-01-18T12:52:36.006039-05:00","created_by":"Don Denton"}]}
{"id":"ribbin-c62.9","title":"Update documentation for config CLI commands","description":"Update README.md with: new 'Configuration Management' section showing ribbin config commands, examples of add/remove/list/edit, example of generated scaffold scripts. Update CLI help text in internal/cli/cli.go to mention config subcommands. Add examples to ribbin config --help output showing common workflows (add block shim, add redirect with scaffold, edit existing).","status":"closed","priority":2,"issue_type":"task","owner":"don@happycollision.com","created_at":"2026-01-18T12:51:37.525571-05:00","created_by":"Don Denton","updated_at":"2026-01-18T13:44:19.48437-05:00","closed_at":"2026-01-18T13:44:19.48437-05:00","close_reason":"Config CLI commands working, skipping detailed unit/integration tests and extra docs for now - can be added later if needed","dependencies":[{"issue_id":"ribbin-c62.9","depends_on_id":"ribbin-c62","type":"parent-child","created_at":"2026-01-18T12:51:37.526703-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-c62.9","depends_on_id":"ribbin-c62.7","type":"blocks","created_at":"2026-01-18T12:52:41.309744-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-c62.9","depends_on_id":"ribbin-c62.8","type":"blocks","created_at":"2026-01-18T12:52:46.5665-05:00","created_by":"Don Denton"}]}
{"id":"ribbin-c97","title":"Passthrough check: regex matching on argv0 for conditional bypass","description":"Allow shim configs to define a regex pattern that, if matched against argv0, passes through to the original command instead of blocking.\n\n## Use Case\nBlock a command in general, but allow it when invoked through specific tooling. For example:\n- Block `tsc` directly, but allow when invoked via `pnpm run typecheck`, `pnpm run build`, etc.\n\n## Proposed Config\n```toml\n[shims.tsc]\naction = \"block\"\nmessage = \"Use 'pnpm run typecheck' instead\"\npassthrough_pattern = \"/pnpm (run|typecheck|build)/\"\n```\n\n## Implementation Notes\n- Add `passthrough_pattern` field to shim config\n- Check argv0 (or full command line) against regex before blocking\n- If pattern matches, pass through to original command\n- Consider whether to match against argv0 only or full command line","status":"closed","priority":2,"issue_type":"feature","owner":"don@happycollision.com","created_at":"2026-01-19T00:27:52.250132-05:00","created_by":"Don Denton","updated_at":"2026-01-19T13:56:11.813566-05:00","closed_at":"2026-01-19T13:56:11.813566-05:00","close_reason":"Implemented passthrough config with invocation and invocationRegexp patterns"}
{"id":"ribbin-d7s","title":"Implement symlink attack prevention and validation","description":"# Symlink Attack Prevention (HIGH PRIORITY)\n\nCreate `internal/security/symlinks.go` to safely handle symlinks and prevent symlink-based attacks.\n\n## Current Vulnerability\n\n**Location**: `internal/shim/resolver.go:32-50`, `internal/shim/installer.go`\n\n**Current Code**:\n```go\n// Uses Lstat (good - doesn't follow)\ninfo, err := os.Lstat(path)\n// ...\n// But then manually reads and trusts target\ntarget, err := os.Readlink(path)\n// No validation of target safety\n```\n\n**Risk**: Attacker can create symlinks pointing to:\n- Critical system files (`/etc/passwd`)\n- Files outside allowed directories\n- Circular symlink chains (DoS)\n- Nested symlinks for privilege escalation\n\n**Attack Scenario**:\n```bash\n# Attacker creates malicious symlink\nln -s /usr/bin/bash ~/.local/bin/myapp\n# User tries to shim myapp\nribbin shim myapp\n# Now shimming /usr/bin/bash - system compromised\n```\n\n## Implementation Requirements\n\n### Core Functions\n\n```go\npackage security\n\nimport (\n    \"fmt\"\n    \"os\"\n    \"path/filepath\"\n    \"strings\"\n)\n\nconst MaxSymlinkDepth = 10  // Prevent infinite loops\n\n// SafeReadlink reads a symlink and validates its target\nfunc SafeReadlink(linkPath string) (string, error) {\n    // Must use Lstat, not Stat (don't follow symlinks)\n    info, err := os.Lstat(linkPath)\n    if err != nil {\n        return \"\", fmt.Errorf(\"cannot stat link: %w\", err)\n    }\n    \n    // Verify it's actually a symlink\n    if info.Mode()\u0026os.ModeSymlink == 0 {\n        return \"\", fmt.Errorf(\"not a symlink: %s\", linkPath)\n    }\n    \n    // Read the target\n    target, err := os.Readlink(linkPath)\n    if err != nil {\n        return \"\", fmt.Errorf(\"cannot read symlink: %w\", err)\n    }\n    \n    // If target is relative, resolve against link's directory\n    if !filepath.IsAbs(target) {\n        target = filepath.Join(filepath.Dir(linkPath), target)\n    }\n    \n    // Canonicalize target\n    target, err = filepath.Abs(filepath.Clean(target))\n    if err != nil {\n        return \"\", fmt.Errorf(\"cannot resolve target: %w\", err)\n    }\n    \n    return target, nil\n}\n\n// ResolveSymlinkChain follows symlinks to final target\n// Returns error if chain is too deep or leads outside allowed dirs\nfunc ResolveSymlinkChain(path string) (string, error) {\n    current := path\n    visited := make(map[string]bool)\n    \n    for depth := 0; depth \u003c MaxSymlinkDepth; depth++ {\n        // Check for cycles\n        if visited[current] {\n            return \"\", fmt.Errorf(\"circular symlink detected: %s\", current)\n        }\n        visited[current] = true\n        \n        // Check current path\n        info, err := os.Lstat(current)\n        if err != nil {\n            return \"\", fmt.Errorf(\"cannot stat %s: %w\", current, err)\n        }\n        \n        // If not a symlink, we're done\n        if info.Mode()\u0026os.ModeSymlink == 0 {\n            // Validate final target is in allowed directory\n            if !IsAllowedDirectory(current) {\n                return \"\", fmt.Errorf(\"symlink target outside allowed directories: %s\", current)\n            }\n            return current, nil\n        }\n        \n        // Read and validate symlink\n        target, err := SafeReadlink(current)\n        if err != nil {\n            return \"\", fmt.Errorf(\"invalid symlink in chain: %w\", err)\n        }\n        \n        // Validate intermediate target is safe\n        if err := ValidateSymlinkTarget(current, target); err != nil {\n            return \"\", err\n        }\n        \n        current = target\n    }\n    \n    return \"\", fmt.Errorf(\"symlink chain too deep (\u003e%d): %s\", MaxSymlinkDepth, path)\n}\n\n// ValidateSymlinkTarget checks if a symlink target is safe\nfunc ValidateSymlinkTarget(link, target string) error {\n    // Get absolute paths\n    absLink, err := filepath.Abs(filepath.Clean(link))\n    if err != nil {\n        return fmt.Errorf(\"cannot resolve link: %w\", err)\n    }\n    absTarget, err := filepath.Abs(filepath.Clean(target))\n    if err != nil {\n        return fmt.Errorf(\"cannot resolve target: %w\", err)\n    }\n    \n    // Check for path traversal in target\n    if strings.Contains(target, \"..\") {\n        return fmt.Errorf(\"path traversal in symlink target: %s\", target)\n    }\n    \n    // Target must be in an allowed directory\n    allowed, err := IsAllowedDirectory(absTarget)\n    if err != nil {\n        return fmt.Errorf(\"cannot check target directory: %w\", err)\n    }\n    if !allowed {\n        return fmt.Errorf(\"symlink target outside allowed directories: %s -\u003e %s\", \n            absLink, absTarget)\n    }\n    \n    // Check for critical system binaries\n    if IsCriticalSystemBinary(absTarget) {\n        return fmt.Errorf(\"symlink points to critical system binary: %s -\u003e %s\",\n            absLink, absTarget)\n    }\n    \n    return nil\n}\n\n// IsSymlinkSafe performs comprehensive symlink safety check\nfunc IsSymlinkSafe(linkPath string) (bool, error) {\n    // Resolve full chain\n    _, err := ResolveSymlinkChain(linkPath)\n    if err != nil {\n        return false, err\n    }\n    return true, nil\n}\n\n// GetSymlinkInfo returns detailed information about a symlink chain\ntype SymlinkInfo struct {\n    IsSymlink   bool\n    Target      string      // Direct target\n    FinalTarget string      // After resolving chain\n    ChainDepth  int\n    Chain       []string    // All links in chain\n}\n\nfunc GetSymlinkInfo(path string) (*SymlinkInfo, error) {\n    info := \u0026SymlinkInfo{\n        Chain: []string{path},\n    }\n    \n    // Check if it's a symlink\n    stat, err := os.Lstat(path)\n    if err != nil {\n        return nil, err\n    }\n    \n    if stat.Mode()\u0026os.ModeSymlink == 0 {\n        info.IsSymlink = false\n        info.FinalTarget = path\n        return info, nil\n    }\n    \n    info.IsSymlink = true\n    \n    // Get direct target\n    target, err := SafeReadlink(path)\n    if err != nil {\n        return nil, err\n    }\n    info.Target = target\n    \n    // Resolve full chain\n    current := path\n    for depth := 0; depth \u003c MaxSymlinkDepth; depth++ {\n        stat, err := os.Lstat(current)\n        if err != nil {\n            return nil, err\n        }\n        \n        if stat.Mode()\u0026os.ModeSymlink == 0 {\n            info.FinalTarget = current\n            info.ChainDepth = depth\n            return info, nil\n        }\n        \n        target, err := SafeReadlink(current)\n        if err != nil {\n            return nil, err\n        }\n        \n        info.Chain = append(info.Chain, target)\n        current = target\n    }\n    \n    return nil, fmt.Errorf(\"symlink chain too deep\")\n}\n\n// NoSymlinksInPath checks that no component of path is a symlink\nfunc NoSymlinksInPath(path string) error {\n    abs, err := filepath.Abs(filepath.Clean(path))\n    if err != nil {\n        return err\n    }\n    \n    // Check each component\n    parts := strings.Split(abs, string(filepath.Separator))\n    current := string(filepath.Separator)\n    \n    for _, part := range parts {\n        if part == \"\" {\n            continue\n        }\n        current = filepath.Join(current, part)\n        \n        info, err := os.Lstat(current)\n        if err != nil {\n            if os.IsNotExist(err) {\n                continue  // Path doesn't exist yet - OK\n            }\n            return err\n        }\n        \n        if info.Mode()\u0026os.ModeSymlink != 0 {\n            return fmt.Errorf(\"symlink in path at %s\", current)\n        }\n    }\n    \n    return nil\n}\n```\n\n## Integration Points\n\n### Update resolver.go\n\n```go\n// In internal/shim/resolver.go\n\nfunc FindShimPath(shimPath string) (string, error) {\n    // Use Lstat, not Stat\n    info, err := os.Lstat(shimPath)\n    if err != nil {\n        return \"\", err\n    }\n    \n    // If it's a symlink, validate and resolve it safely\n    if info.Mode()\u0026os.ModeSymlink != 0 {\n        target, err := security.ResolveSymlinkChain(shimPath)\n        if err != nil {\n            return \"\", fmt.Errorf(\"unsafe symlink: %w\", err)\n        }\n        return target, nil\n    }\n    \n    return shimPath, nil\n}\n```\n\n### Update installer.go\n\n```go\n// In internal/shim/installer.go Install function\n\nfunc Install(binaryPath, ribbinPath string, allowSystemDir bool) error {\n    lock, err := security.AcquireLock(binaryPath, 10*time.Second)\n    if err != nil {\n        return err\n    }\n    defer lock.Release()\n    \n    // Validate paths\n    if err := security.ValidateBinaryPath(binaryPath); err != nil {\n        return err\n    }\n    \n    // If binary path is a symlink, validate it\n    info, err := os.Lstat(binaryPath)\n    if err != nil {\n        return err\n    }\n    if info.Mode()\u0026os.ModeSymlink != 0 {\n        // Resolve and validate symlink chain\n        finalTarget, err := security.ResolveSymlinkChain(binaryPath)\n        if err != nil {\n            return fmt.Errorf(\"cannot shim unsafe symlink: %w\", err)\n        }\n        \n        // Warn user about shimming a symlink\n        fmt.Fprintf(os.Stderr, \"⚠️  Warning: %s is a symlink to %s\\n\", binaryPath, finalTarget)\n        fmt.Fprintf(os.Stderr, \"   The shim will redirect to the symlink, not the final target\\n\")\n    }\n    \n    // Ensure no symlinks in sidecar path\n    sidecarPath := SidecarPath(binaryPath)\n    if err := security.NoSymlinksInPath(filepath.Dir(sidecarPath)); err != nil {\n        return fmt.Errorf(\"symlinks in parent directory: %w\", err)\n    }\n    \n    // Continue with installation...\n}\n\n// Verify sidecar isn't a symlink after creation\nfunc verifySidecarNotSymlink(sidecarPath string) error {\n    info, err := os.Lstat(sidecarPath)\n    if err != nil {\n        return err\n    }\n    if info.Mode()\u0026os.ModeSymlink != 0 {\n        return fmt.Errorf(\"sidecar unexpectedly became a symlink: %s\", sidecarPath)\n    }\n    return nil\n}\n```\n\n### Update cli/shim.go\n\n```go\n// In internal/cli/shim.go\n\n// Warn about symlinks in PATH\nfor _, path := range paths {\n    info, err := os.Lstat(path)\n    if err != nil {\n        continue\n    }\n    \n    if info.Mode()\u0026os.ModeSymlink != 0 {\n        // Get symlink info\n        symlinkInfo, err := security.GetSymlinkInfo(path)\n        if err != nil {\n            fmt.Printf(\"⚠️  Skipping unsafe symlink: %s (%v)\\n\", path, err)\n            continue\n        }\n        \n        if symlinkInfo.ChainDepth \u003e 0 {\n            fmt.Printf(\"ℹ️  %s is a symlink (depth %d) -\u003e %s\\n\", \n                path, symlinkInfo.ChainDepth, symlinkInfo.FinalTarget)\n        }\n    }\n}\n```\n\n## Test Cases\n\nCreate `internal/security/symlinks_test.go`:\n\n```go\nfunc TestSafeReadlink_NotSymlink(t *testing.T) {\n    tmpDir := t.TempDir()\n    file := filepath.Join(tmpDir, \"file\")\n    os.WriteFile(file, []byte(\"test\"), 0644)\n    \n    _, err := SafeReadlink(file)\n    assert.Error(t, err)\n    assert.Contains(t, err.Error(), \"not a symlink\")\n}\n\nfunc TestSafeReadlink_Valid(t *testing.T) {\n    tmpDir := t.TempDir()\n    target := filepath.Join(tmpDir, \"target\")\n    link := filepath.Join(tmpDir, \"link\")\n    \n    os.WriteFile(target, []byte(\"test\"), 0644)\n    os.Symlink(target, link)\n    \n    resolved, err := SafeReadlink(link)\n    assert.NoError(t, err)\n    assert.Equal(t, target, resolved)\n}\n\nfunc TestResolveSymlinkChain_Circular(t *testing.T) {\n    tmpDir := t.TempDir()\n    link1 := filepath.Join(tmpDir, \"link1\")\n    link2 := filepath.Join(tmpDir, \"link2\")\n    \n    // Create circular symlinks\n    os.Symlink(link2, link1)\n    os.Symlink(link1, link2)\n    \n    _, err := ResolveSymlinkChain(link1)\n    assert.Error(t, err)\n    assert.Contains(t, err.Error(), \"circular\")\n}\n\nfunc TestResolveSymlinkChain_TooDeep(t *testing.T) {\n    tmpDir := t.TempDir()\n    \n    // Create chain longer than MaxSymlinkDepth\n    var prev string\n    for i := 0; i \u003c= MaxSymlinkDepth+1; i++ {\n        current := filepath.Join(tmpDir, fmt.Sprintf(\"link%d\", i))\n        if i == 0 {\n            os.WriteFile(current, []byte(\"target\"), 0644)\n        } else {\n            os.Symlink(prev, current)\n        }\n        prev = current\n    }\n    \n    _, err := ResolveSymlinkChain(prev)\n    assert.Error(t, err)\n    assert.Contains(t, err.Error(), \"too deep\")\n}\n\nfunc TestValidateSymlinkTarget_PathTraversal(t *testing.T) {\n    tmpDir := t.TempDir()\n    link := filepath.Join(tmpDir, \"link\")\n    target := \"../../etc/passwd\"\n    \n    os.Symlink(target, link)\n    \n    err := ValidateSymlinkTarget(link, target)\n    assert.Error(t, err)\n    assert.Contains(t, err.Error(), \"traversal\")\n}\n\nfunc TestValidateSymlinkTarget_CriticalBinary(t *testing.T) {\n    tmpDir := t.TempDir()\n    link := filepath.Join(tmpDir, \"link\")\n    \n    os.Symlink(\"/usr/bin/bash\", link)\n    \n    err := ValidateSymlinkTarget(link, \"/usr/bin/bash\")\n    assert.Error(t, err)\n    assert.Contains(t, err.Error(), \"critical system binary\")\n}\n\nfunc TestNoSymlinksInPath(t *testing.T) {\n    tmpDir := t.TempDir()\n    \n    // Create a symlink in the path\n    linkDir := filepath.Join(tmpDir, \"linkdir\")\n    targetDir := filepath.Join(tmpDir, \"target\")\n    os.Mkdir(targetDir, 0755)\n    os.Symlink(targetDir, linkDir)\n    \n    file := filepath.Join(linkDir, \"file\")\n    \n    err := NoSymlinksInPath(file)\n    assert.Error(t, err)\n    assert.Contains(t, err.Error(), \"symlink in path\")\n}\n\nfunc TestGetSymlinkInfo(t *testing.T) {\n    tmpDir := t.TempDir()\n    \n    // Create chain: link1 -\u003e link2 -\u003e target\n    target := filepath.Join(tmpDir, \"target\")\n    link2 := filepath.Join(tmpDir, \"link2\")\n    link1 := filepath.Join(tmpDir, \"link1\")\n    \n    os.WriteFile(target, []byte(\"test\"), 0644)\n    os.Symlink(target, link2)\n    os.Symlink(link2, link1)\n    \n    info, err := GetSymlinkInfo(link1)\n    assert.NoError(t, err)\n    assert.True(t, info.IsSymlink)\n    assert.Equal(t, link2, info.Target)\n    assert.Equal(t, target, info.FinalTarget)\n    assert.Equal(t, 2, info.ChainDepth)\n    assert.Len(t, info.Chain, 3)\n}\n```\n\n### Integration Tests\n\n```go\nfunc TestShimSymlink_ToSystemBinary_Rejected(t *testing.T) {\n    tmpDir := t.TempDir()\n    link := filepath.Join(tmpDir, \"myapp\")\n    \n    // Create symlink to bash\n    os.Symlink(\"/usr/bin/bash\", link)\n    \n    // Try to shim it\n    err := Install(link, \"/path/to/ribbin\", false)\n    assert.Error(t, err)\n    assert.Contains(t, err.Error(), \"critical system binary\")\n}\n\nfunc TestShimSymlink_CircularChain_Rejected(t *testing.T) {\n    tmpDir := t.TempDir()\n    link1 := filepath.Join(tmpDir, \"link1\")\n    link2 := filepath.Join(tmpDir, \"link2\")\n    \n    os.Symlink(link2, link1)\n    os.Symlink(link1, link2)\n    \n    err := Install(link1, \"/path/to/ribbin\", false)\n    assert.Error(t, err)\n    assert.Contains(t, err.Error(), \"circular\")\n}\n```\n\n## Success Criteria\n\n- [ ] SafeReadlink validates symlink targets\n- [ ] ResolveSymlinkChain detects circular references\n- [ ] Maximum symlink depth enforced (prevents DoS)\n- [ ] Path traversal in symlink targets detected\n- [ ] Symlinks to critical binaries rejected\n- [ ] Symlinks to directories outside allowlist rejected\n- [ ] NoSymlinksInPath checks all path components\n- [ ] GetSymlinkInfo provides detailed chain analysis\n- [ ] Integration with installer.go complete\n- [ ] Test coverage \u003e90%\n- [ ] Manual testing with various symlink attacks confirms protection\n\n## Dependencies\n\n- Requires: Allowlist module (calls IsAllowedDirectory, IsCriticalSystemBinary)\n- Requires: Path sanitization (calls ValidateBinaryPath)\n\n## Estimated Complexity\n\nMedium-High - Complex chain resolution, circular detection, path validation","status":"closed","priority":1,"issue_type":"task","owner":"don@happycollision.com","created_at":"2026-01-18T13:33:21.079319-05:00","created_by":"Don Denton","updated_at":"2026-01-18T16:14:57.868309-05:00","closed_at":"2026-01-18T16:14:57.868309-05:00","close_reason":"Implemented comprehensive symlink attack prevention with SafeReadlink, ResolveSymlinkChain, NoSymlinksInPath, and GetSymlinkInfo functions. Integrated into installer.go, resolver.go, and CLI. All tests pass with \u003e90% coverage.","dependencies":[{"issue_id":"ribbin-d7s","depends_on_id":"ribbin-rrg","type":"blocks","created_at":"2026-01-18T13:33:47.477544-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-d7s","depends_on_id":"ribbin-pu4","type":"blocks","created_at":"2026-01-18T13:33:52.734738-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-d7s","depends_on_id":"ribbin-rx1","type":"parent-child","created_at":"2026-01-18T13:39:45.38879-05:00","created_by":"Don Denton"}]}
{"id":"ribbin-d9y","title":"Implement shim installer (symlink and sidecar management)","description":"# Shim Installer Implementation\n\nCreate and remove symlinks, manage sidecar files.\n\n## File to Create\n\n### internal/shim/installer.go\n\n```go\n// Install creates a shim for a binary:\n// 1. Rename original to {path}.ribbin-original\n// 2. Create symlink {path} -\u003e ribbinPath\n// 3. Update registry\nfunc Install(binaryPath, ribbinPath string, registry *Registry, configPath string) error\n\n// Uninstall removes a shim:\n// 1. Remove symlink at {path}\n// 2. Rename {path}.ribbin-original back to {path}\n// 3. Remove from registry\nfunc Uninstall(binaryPath string, registry *Registry) error\n\n// FindSidecars searches directories for .ribbin-original files\nfunc FindSidecars(searchPaths []string) ([]string, error)\n\n// SidecarPath returns the sidecar path for a binary\nfunc SidecarPath(binaryPath string) string {\n    return binaryPath + \".ribbin-original\"\n}\n```\n\n## Implementation Details\n\n### Install Flow\n```go\nfunc Install(binaryPath, ribbinPath string, registry *Registry, configPath string) error {\n    sidecar := SidecarPath(binaryPath)\n    \n    // Check if already shimmed\n    if _, err := os.Stat(sidecar); err == nil {\n        return fmt.Errorf(\"%s is already shimmed\", binaryPath)\n    }\n    \n    // Check original exists\n    if _, err := os.Stat(binaryPath); os.IsNotExist(err) {\n        return fmt.Errorf(\"%s does not exist\", binaryPath)\n    }\n    \n    // Rename original to sidecar\n    if err := os.Rename(binaryPath, sidecar); err != nil {\n        return fmt.Errorf(\"failed to rename %s: %w\", binaryPath, err)\n    }\n    \n    // Create symlink\n    if err := os.Symlink(ribbinPath, binaryPath); err != nil {\n        // Rollback: restore original\n        os.Rename(sidecar, binaryPath)\n        return fmt.Errorf(\"failed to create symlink: %w\", err)\n    }\n    \n    // Update registry\n    registry.Shims[binaryPath] = ShimEntry{\n        Original: sidecar,\n        Config:   configPath,\n    }\n    \n    return nil\n}\n```\n\n### Uninstall Flow\n```go\nfunc Uninstall(binaryPath string, registry *Registry) error {\n    sidecar := SidecarPath(binaryPath)\n    \n    // Verify sidecar exists\n    if _, err := os.Stat(sidecar); os.IsNotExist(err) {\n        return fmt.Errorf(\"sidecar not found: %s\", sidecar)\n    }\n    \n    // Remove symlink\n    if err := os.Remove(binaryPath); err != nil {\n        return fmt.Errorf(\"failed to remove symlink: %w\", err)\n    }\n    \n    // Restore original\n    if err := os.Rename(sidecar, binaryPath); err != nil {\n        return fmt.Errorf(\"failed to restore original: %w\", err)\n    }\n    \n    // Update registry\n    delete(registry.Shims, binaryPath)\n    \n    return nil\n}\n```\n\n### FindSidecars\n- Search common binary directories: /usr/bin, /usr/local/bin, /opt/homebrew/bin, etc.\n- Use filepath.Glob with pattern `*.ribbin-original`\n- Return list of original binary paths (strip .ribbin-original suffix)\n\n## Permission Handling\n\n- Check write permission before attempting operations\n- Return clear error message if permission denied\n- Suggest `sudo ribbin shim` in error message\n\n## Tests\n\n- Test install creates symlink and sidecar\n- Test uninstall restores original\n- Test install rollback on symlink failure\n- Test permission denied handling\n- Test already-shimmed detection\n\n## Acceptance Criteria\n\n- Can shim and unshim a test binary\n- Registry is updated correctly\n- Rollback works if symlink creation fails\n- Clear error messages for permission issues","status":"closed","priority":1,"issue_type":"task","owner":"don@happycollision.com","created_at":"2026-01-17T22:03:29.139095-05:00","created_by":"Don Denton","updated_at":"2026-01-17T23:00:55.394422-05:00","closed_at":"2026-01-17T23:00:55.394422-05:00","close_reason":"Closed","dependencies":[{"issue_id":"ribbin-d9y","depends_on_id":"ribbin-skj","type":"parent-child","created_at":"2026-01-17T22:10:53.812426-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-d9y","depends_on_id":"ribbin-g2x","type":"blocks","created_at":"2026-01-17T22:12:14.937198-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-d9y","depends_on_id":"ribbin-pmw","type":"blocks","created_at":"2026-01-17T22:12:20.175342-05:00","created_by":"Don Denton"}]}
{"id":"ribbin-g2x","title":"Implement config layer: ribbin.json and registry parsing","description":"# Config Layer Implementation\n\nImplement parsing and discovery for project config and global registry.\n\n## Files to Create\n\n### internal/config/project.go\n\n```go\ntype ProjectConfig struct {\n    Shims map[string]ShimConfig `json:\"shims\"`\n}\n\ntype ShimConfig struct {\n    Action  string   `json:\"action\"`           // \"block\" for v1\n    Message string   `json:\"message\"`          // Error message to display\n    Paths   []string `json:\"paths,omitempty\"`  // Optional explicit paths\n}\n\n// FindProjectConfig walks up from PWD looking for ribbin.json\nfunc FindProjectConfig() (*ProjectConfig, string, error)\n\n// LoadProjectConfig loads config from a specific path\nfunc LoadProjectConfig(path string) (*ProjectConfig, error)\n```\n\n### internal/config/registry.go\n\n```go\ntype Registry struct {\n    Shims       map[string]ShimEntry       `json:\"shims\"`\n    Activations map[string]ActivationEntry `json:\"activations\"`\n    GlobalOn    bool                       `json:\"global_on\"`\n}\n\ntype ShimEntry struct {\n    Original string `json:\"original\"`  // Path to .ribbin-original sidecar\n    Config   string `json:\"config\"`    // Path to ribbin.json that created it\n}\n\ntype ActivationEntry struct {\n    PID         int       `json:\"pid\"`\n    ActivatedAt time.Time `json:\"activated_at\"`\n}\n\n// RegistryPath returns ~/.config/ribbin/registry.json\nfunc RegistryPath() string\n\n// LoadRegistry loads or creates empty registry\nfunc LoadRegistry() (*Registry, error)\n\n// SaveRegistry writes registry to disk\nfunc SaveRegistry(r *Registry) error\n```\n\n## Behavior\n\n### FindProjectConfig\n- Start at current working directory\n- Walk up parent directories\n- Look for `ribbin.json` at each level\n- Return config, config path, and error\n- Return error if not found (reaching root)\n\n### Registry Location\n- `~/.config/ribbin/registry.json`\n- Create directory if doesn't exist\n- Return empty registry if file doesn't exist\n\n## Tests\n\n- Test walking up directories to find config\n- Test missing config error\n- Test malformed JSON handling\n- Test registry creation when missing\n- Test registry persistence\n\n## Acceptance Criteria\n\n- Can discover ribbin.json from nested directories\n- Registry persists between runs\n- Graceful handling of missing/corrupt files","status":"closed","priority":1,"issue_type":"task","owner":"don@happycollision.com","created_at":"2026-01-17T22:02:41.288143-05:00","created_by":"Don Denton","updated_at":"2026-01-17T22:56:39.468271-05:00","closed_at":"2026-01-17T22:56:39.468271-05:00","close_reason":"Closed","dependencies":[{"issue_id":"ribbin-g2x","depends_on_id":"ribbin-skj","type":"parent-child","created_at":"2026-01-17T22:10:43.346535-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-g2x","depends_on_id":"ribbin-8n3","type":"blocks","created_at":"2026-01-17T22:11:59.223115-05:00","created_by":"Don Denton"}]}
{"id":"ribbin-g5w","title":"Add Depth field to PassthroughConfig","description":"## Context\n\nPart of the ancestor-aware invocation matching feature. We need to add an optional `Depth` field to `PassthroughConfig` that controls how many ancestor levels to check.\n\n## Current Code\n\n**File: `internal/config/project.go` (lines 18-24)**\n\n```go\ntype PassthroughConfig struct {\n    // Invocation is a list of exact strings to match against the parent process invocation\n    Invocation []string `json:\"invocation,omitempty\"`\n    // InvocationRegexp is a list of regular expressions to match against the parent process invocation\n    InvocationRegexp []string `json:\"invocationRegexp,omitempty\"`\n}\n```\n\n## Implementation\n\nAdd `Depth` field:\n\n```go\ntype PassthroughConfig struct {\n    // Invocation is a list of exact strings to match against ancestor process invocations\n    Invocation []string `json:\"invocation,omitempty\"`\n    // InvocationRegexp is a list of regular expressions to match against ancestor process invocations\n    InvocationRegexp []string `json:\"invocationRegexp,omitempty\"`\n    // Depth limits how many ancestor levels to check. nil/0 = unlimited, 1 = parent only, N = up to N ancestors\n    Depth *int `json:\"depth,omitempty\"`\n}\n```\n\n## Depth Semantics\n\n| depth value | behavior |\n|-------------|----------|\n| omitted/nil | unlimited - check all ancestors up to PID 1 |\n| 0           | unlimited - same as omitted |\n| 1           | immediate parent only (current/legacy behavior) |\n| 2           | parent + grandparent |\n| N           | up to N ancestors |\n\n## Example Config\n\n```jsonc\n{\n  \"wrappers\": {\n    \"tsc\": {\n      \"action\": \"block\",\n      \"message\": \"Use 'pnpm nx typecheck' instead\",\n      \"passthrough\": {\n        \"invocation\": [\"pnpm nx typecheck\"],\n        \"depth\": 0  // Check all ancestors (default)\n      }\n    }\n  }\n}\n```\n\n## Tests\n\n**File: `internal/config/project_test.go`**\n\n- Update existing passthrough config tests to verify Depth field parsing\n- Test nil/omitted Depth\n- Test explicit Depth values (0, 1, 5)\n\n## Acceptance Criteria\n\n- [ ] `Depth *int` field added to `PassthroughConfig`\n- [ ] JSON unmarshaling works correctly (nil when omitted)\n- [ ] Existing tests still pass\n- [ ] New tests verify Depth field parsing","status":"closed","priority":2,"issue_type":"task","owner":"don.denton@trillianthealth.com","created_at":"2026-01-22T00:33:11.935524-05:00","created_by":"Don Denton","updated_at":"2026-01-22T09:40:49.986346-05:00","closed_at":"2026-01-22T09:40:49.986346-05:00","close_reason":"Closed","dependencies":[{"issue_id":"ribbin-g5w","depends_on_id":"ribbin-9r5","type":"parent-child","created_at":"2026-01-22T09:35:40.891038-05:00","created_by":"Don Denton"}]}
{"id":"ribbin-hzh","title":"Phase 4: CLI commands overhaul","description":"# Phase 4: CLI commands overhaul\n\nRewrite CLI commands with new names and flag-based activation.\n\n## Files to Delete\n\n- `internal/cli/on.go`\n- `internal/cli/off.go`\n\n## Files to Rename\n\n- `internal/cli/shim.go` → `internal/cli/wrap.go`\n- `internal/cli/unshim.go` → `internal/cli/unwrap.go`\n\n## New Files to Create\n\n### 1. `internal/cli/activate.go`\n\n```go\nvar activateCmd = \u0026cobra.Command{\n    Use:   \"activate [config-files...]\",\n    Short: \"Activate ribbin for configs, shell, or globally\",\n    Long: `Activate ribbin interception.\n\nBy default (--config), activates the nearest ribbin.toml for all shells.\nWith --shell, activates all configs for the current shell only.\nWith --global, activates everything everywhere.\n\nExamples:\n  ribbin activate                    # Activate nearest config\n  ribbin activate ./a.toml ./b.toml  # Activate specific configs\n  ribbin activate --shell            # Activate for this shell\n  ribbin activate --global           # Activate globally`,\n}\n\n// Flags: --config (default), --shell, --global\n// Args: optional list of config file paths (only with --config)\n```\n\n### 2. `internal/cli/deactivate.go`\n\n```go\nvar deactivateCmd = \u0026cobra.Command{\n    Use:   \"deactivate [config-files...]\",\n    Short: \"Deactivate ribbin for configs, shell, or globally\",\n    Long: `Deactivate ribbin interception.\n\nScope flags (mutually exclusive):\n  --config   Deactivate config(s) - DEFAULT\n  --shell    Deactivate shell activation(s)\n  --global   Turn off global mode\n\nModifier flags:\n  --all         Deactivate ALL items in the chosen scope\n  --everything  Nuclear option: deactivate global + all shells + all configs\n\nExamples:\n  ribbin deactivate                    # Deactivate nearest config\n  ribbin deactivate ./a.toml ./b.toml  # Deactivate specific configs\n  ribbin deactivate --config --all     # Deactivate ALL configs\n  ribbin deactivate --all              # Same as --config --all\n  ribbin deactivate --shell            # Deactivate current shell\n  ribbin deactivate --shell --all      # Deactivate ALL shells\n  ribbin deactivate --global           # Turn off global mode\n  ribbin deactivate --everything       # Nuclear: global + all shells + all configs`,\n}\n\n// Flags:\n// --config (default scope)\n// --shell\n// --global\n// --all (works with --config or --shell, or standalone means --config --all)\n// --everything (ignores other flags, nukes everything)\n```\n\n### 3. `internal/cli/status.go`\n\n```go\nvar statusCmd = \u0026cobra.Command{\n    Use:   \"status\",\n    Short: \"Show ribbin activation status\",\n}\n\n// Output format:\n// Ribbin Status\n// =============\n// \n// Activation:\n//   Global:  ✗ inactive\n//   Shell:   ✓ active (PID 12345)\n//   Configs: 2 active\n//     • /projects/A/ribbin.toml (activated 2h ago)\n//     • /projects/B/ribbin.toml (activated 15m ago)\n// \n// Wrapped Tools:\n//   tsc  → /usr/local/bin/tsc  (from /projects/A/ribbin.toml)\n```\n\n### 4. `internal/cli/recover.go`\n\n```go\nvar recoverCmd = \u0026cobra.Command{\n    Use:   \"recover\",\n    Short: \"Recover wrapped binaries (alias for unwrap --global --search)\",\n    Run: func(cmd *cobra.Command, args []string) {\n        // Call unwrap with --global --search\n    },\n}\n```\n\n## Modifications to wrap.go (formerly shim.go)\n\n- Rename command from \"shim\" to \"wrap\"\n- Accept optional config file paths as arguments\n- Update help text and messages\n- Add warning message after successful wrap:\n  ```\n  ⚠️  Important: Run `ribbin unwrap --global --search` (aliased as `ribbin recover`)\n     before uninstalling ribbin. Failure to do so will result in recoverable, but\n     temporarily broken tools. See https://github.com/happycollision/ribbin#recovery\n     for more information.\n  ```\n\n## Modifications to unwrap.go (formerly unshim.go)\n\n- Rename command from \"unshim\" to \"unwrap\"\n- Add `--global` flag (replaces old `--all`)\n- Add `--search` flag (works with `--global`)\n- Accept optional config file paths as arguments\n\n## Update cli.go\n\nRegister new commands, remove old ones.\n\n## Tests \u0026 Documentation\n\n- Update CLI tests for all new/renamed commands\n- Update scenario scripts that use old command names\n- Update CLAUDE.md and README.md command examples\n- Test all flag combinations for deactivate\n\n## Verification\n\n- `ribbin wrap` works\n- `ribbin unwrap` works\n- `ribbin unwrap --global` works\n- `ribbin unwrap --global --search` works\n- `ribbin activate` with all flag combinations works\n- `ribbin deactivate` with all flag combinations works\n- `ribbin deactivate --everything` nukes all activation state\n- `ribbin status` shows correct information\n- `ribbin recover` works as alias\n- `ribbin help` shows updated commands","status":"closed","priority":2,"issue_type":"task","owner":"don@happycollision.com","created_at":"2026-01-20T11:22:13.519101-05:00","created_by":"Don Denton","updated_at":"2026-01-20T14:11:28.849983-05:00","closed_at":"2026-01-20T14:11:28.849983-05:00","close_reason":"Phase 4 CLI overhaul complete: wrap/unwrap/activate/deactivate/status/recover commands implemented","dependencies":[{"issue_id":"ribbin-hzh","depends_on_id":"ribbin-is0","type":"blocks","created_at":"2026-01-20T11:23:31.730893-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-hzh","depends_on_id":"ribbin-u13","type":"blocks","created_at":"2026-01-20T11:24:16.985389-05:00","created_by":"Don Denton"}]}
{"id":"ribbin-is0","title":"UX Redesign: Command Structure Overhaul","description":"# UX Redesign: Command Structure Overhaul\n\nComplete redesign of ribbin's command structure based on design discussion (ribbin-6g0.3).\n\n## Summary of Changes\n\n| Area | Old | New |\n|------|-----|-----|\n| Commands | `shim`/`unshim` | `wrap`/`unwrap` |\n| Config sections | `[shims.*]` | `[wrappers.*]` |\n| Activation | `on`/`off`/`activate` | `activate`/`deactivate` with `--config`/`--shell`/`--global` flags |\n| Directory | `internal/shim/` | `internal/wrap/` |\n\n## Three-Tier Activation Model\n\n| Scope | Flag | What it controls | Stored where |\n|-------|------|------------------|--------------|\n| **config** | `--config` (default) | This specific ribbin.toml, all shells | Registry: `config_activations[path]` |\n| **shell** | `--shell` | All configs, this shell only | Registry: `shell_activations[pid]` |\n| **global** | `--global` | All configs, all shells | Registry: `global_active` |\n\n**Priority:** `global` \u003e `shell` \u003e `config`\n\n## New Command Structure\n\n```bash\n# Installation\nribbin wrap                              # Wrap tools from nearest ribbin.toml\nribbin wrap ./a.toml ./b.toml            # Wrap tools from specific configs\nribbin unwrap                            # Unwrap tools from nearest ribbin.toml\nribbin unwrap --global                   # Unwrap all from registry\nribbin unwrap --global --search          # Search filesystem for orphaned sidecars\nribbin recover                           # Alias for unwrap --global --search\n\n# Activation (--config is default)\nribbin activate                          # Activate nearest ribbin.toml\nribbin activate ./a.toml                 # Activate specific config\nribbin activate --shell                  # Activate all configs for this shell\nribbin activate --global                 # Activate everything everywhere\n\n# Deactivation\nribbin deactivate                        # Deactivate nearest config (same as --config)\nribbin deactivate --config               # Deactivate nearest config\nribbin deactivate --config --all         # Deactivate ALL configs\nribbin deactivate --shell                # Deactivate current shell\nribbin deactivate --shell --all          # Deactivate ALL shells\nribbin deactivate --all                  # Shorthand for --config --all\nribbin deactivate --everything           # Nuclear: global + all shells + all configs\nribbin deactivate --global               # Turn off global mode\n\n# Status\nribbin status                            # Show full activation state\n```\n\n## Config Format Change\n\n```toml\n# Old\n[shims.npm]\naction = \"block\"\n\n# New\n[wrappers.npm]\naction = \"block\"\n```\n\n## Registry Structure\n\n```json\n{\n  \"wrappers\": { \"npm\": { \"original\": \"/usr/local/bin/npm\", \"config\": \"...\" } },\n  \"global_active\": false,\n  \"shell_activations\": { \"12345\": { \"pid\": 12345, \"activated_at\": \"...\" } },\n  \"config_activations\": { \"/path/to/ribbin.toml\": { \"activated_at\": \"...\" } }\n}\n```\n\n## Additional Features\n\n- **Metadata sidecars**: `.ribbin-meta` files track original binary hash to detect stale sidecars\n- **Status command**: Full visibility into activation state\n- **Global warning banner**: When global mode is active, all CLI output shows warning\n- **Recovery script**: Standalone bash script for restoring binaries without ribbin\n\n## Implementation Notes\n\nEach phase includes updating its own tests, scenarios, and documentation. No commits with failing tests.","status":"closed","priority":2,"issue_type":"epic","owner":"don@happycollision.com","created_at":"2026-01-20T11:20:42.644793-05:00","created_by":"Don Denton","updated_at":"2026-01-20T16:53:54.046956-05:00","closed_at":"2026-01-20T16:53:54.046956-05:00","close_reason":"All phases complete: registry changes, config format, internal rename, CLI overhaul, activation logic, metadata sidecars, recovery, tests, and JSONC migration","dependencies":[{"issue_id":"ribbin-is0","depends_on_id":"ribbin-9sx","type":"blocks","created_at":"2026-01-20T15:03:02.602013-05:00","created_by":"Don Denton"}]}
{"id":"ribbin-jf8","title":"Implement 'ribbin shim' command","description":"# ribbin shim Command Implementation\n\nImplement the shim command that installs shims based on project config.\n\n## File to Modify\n\n### internal/cli/shim.go\n\n```go\nfunc runShim(cmd *cobra.Command, args []string) error {\n    // 1. Find nearest ribbin.json\n    cfg, configPath, err := config.FindProjectConfig()\n    if err != nil {\n        return fmt.Errorf(\"no ribbin.json found: %w\", err)\n    }\n    \n    fmt.Printf(\"Using config: %s\\n\", configPath)\n    \n    // 2. Load registry\n    registry, err := config.LoadRegistry()\n    if err != nil {\n        return fmt.Errorf(\"failed to load registry: %w\", err)\n    }\n    \n    // 3. Get ribbin binary path\n    ribbinPath, err := os.Executable()\n    if err != nil {\n        return fmt.Errorf(\"failed to get ribbin path: %w\", err)\n    }\n    // Resolve symlinks to get actual binary\n    ribbinPath, err = filepath.EvalSymlinks(ribbinPath)\n    if err != nil {\n        return fmt.Errorf(\"failed to resolve ribbin path: %w\", err)\n    }\n    \n    // 4. Process each shim in config\n    var shimmed, skipped, failed int\n    \n    for name, shimCfg := range cfg.Shims {\n        paths := shimCfg.Paths\n        if len(paths) == 0 {\n            // Resolve via which\n            resolved, err := shim.ResolveCommand(name)\n            if err != nil {\n                fmt.Printf(\"⚠ %s: command not found, skipping\\n\", name)\n                skipped++\n                continue\n            }\n            paths = []string{resolved}\n        }\n        \n        for _, p := range paths {\n            // Check if already shimmed\n            if shim.IsAlreadyShimmed(p) {\n                fmt.Printf(\"○ %s: already shimmed\\n\", p)\n                skipped++\n                continue\n            }\n            \n            // Install shim\n            if err := shim.Install(p, ribbinPath, registry, configPath); err != nil {\n                fmt.Printf(\"✗ %s: %v\\n\", p, err)\n                failed++\n            } else {\n                fmt.Printf(\"✓ %s: shimmed\\n\", p)\n                shimmed++\n            }\n        }\n    }\n    \n    // 5. Save registry\n    if err := config.SaveRegistry(registry); err != nil {\n        return fmt.Errorf(\"failed to save registry: %w\", err)\n    }\n    \n    // 6. Summary\n    fmt.Printf(\"\\nShimmed: %d, Skipped: %d, Failed: %d\\n\", shimmed, skipped, failed)\n    \n    if failed \u003e 0 {\n        return fmt.Errorf(\"%d shim(s) failed\", failed)\n    }\n    \n    return nil\n}\n```\n\n## Behavior\n\n1. Find nearest `ribbin.json` by walking up from PWD\n2. For each command in config:\n   - Use explicit `paths` if provided\n   - Otherwise resolve via `which`\n   - Skip if already shimmed\n   - Skip if command not found (with warning)\n   - Install shim (rename original, create symlink)\n3. Update global registry\n4. Print summary\n\n## Error Handling\n\n- No config found → clear error with hint to create ribbin.json\n- Permission denied → suggest running with sudo\n- Command not found → warning, continue with others\n- Already shimmed → skip silently or with note\n\n## Acceptance Criteria\n\n- Creates symlinks for all commands in config\n- Updates registry correctly\n- Handles missing commands gracefully\n- Reports clear summary\n- Works with explicit paths in config","status":"closed","priority":1,"issue_type":"task","owner":"don@happycollision.com","created_at":"2026-01-17T22:04:10.93236-05:00","created_by":"Don Denton","updated_at":"2026-01-17T23:06:51.993125-05:00","closed_at":"2026-01-17T23:06:51.993125-05:00","close_reason":"Closed","dependencies":[{"issue_id":"ribbin-jf8","depends_on_id":"ribbin-skj","type":"parent-child","created_at":"2026-01-17T22:11:04.300605-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-jf8","depends_on_id":"ribbin-1of","type":"blocks","created_at":"2026-01-17T22:12:25.428377-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-jf8","depends_on_id":"ribbin-d9y","type":"blocks","created_at":"2026-01-17T22:12:30.682229-05:00","created_by":"Don Denton"}]}
{"id":"ribbin-k1q","title":"Update shouldPassthrough() to use ancestor matching","description":"## Context\n\nPart of the ancestor-aware invocation matching feature. The `shouldPassthrough()` function in `internal/wrap/runner.go` currently only checks the immediate parent process. It needs to be updated to walk the ancestor tree using the new `GetAncestorCommands()` function.\n\n## Current Code\n\n**File: `internal/wrap/runner.go` (lines 303-332)**\n\n```go\nfunc shouldPassthrough(pt *config.PassthroughConfig) bool {\n    parentCmd, err := process.GetParentCommand()\n    if err != nil {\n        return false\n    }\n\n    // Check exact matches\n    for _, pattern := range pt.Invocation {\n        if strings.Contains(parentCmd, pattern) {\n            return true\n        }\n    }\n\n    // Check regexp matches\n    for _, pattern := range pt.InvocationRegexp {\n        re, err := regexp.Compile(pattern)\n        if err != nil {\n            continue\n        }\n        if re.MatchString(parentCmd) {\n            return true\n        }\n    }\n\n    return false\n}\n```\n\n## New Implementation\n\n```go\nfunc shouldPassthrough(pt *config.PassthroughConfig) bool {\n    // Determine max depth (0 = unlimited)\n    maxDepth := 0\n    if pt.Depth != nil {\n        maxDepth = *pt.Depth\n    }\n\n    // Get ancestor commands up to depth limit\n    ancestorCmds, err := process.GetAncestorCommands(maxDepth)\n    if err != nil || len(ancestorCmds) == 0 {\n        return false\n    }\n\n    // Check each ancestor against patterns\n    for _, cmd := range ancestorCmds {\n        // Check exact matches\n        for _, pattern := range pt.Invocation {\n            if strings.Contains(cmd, pattern) {\n                return true\n            }\n        }\n\n        // Check regexp matches\n        for _, pattern := range pt.InvocationRegexp {\n            re, err := regexp.Compile(pattern)\n            if err != nil {\n                continue\n            }\n            if re.MatchString(cmd) {\n                return true\n            }\n        }\n    }\n\n    return false\n}\n```\n\n## Logging Updates\n\nThe verbose logging at line 131 currently says:\n```go\nverboseLogDecision(cmdName, \"PASS\", \"parent process matched passthrough rule\")\n```\n\nConsider updating to indicate ancestor matching (optional enhancement).\n\n## Tests\n\n**File: `internal/wrap/runner_test.go`**\n\nExisting tests (lines 225-332) test against the actual parent process (test runner). These should continue to work since the test runner will be in the ancestor chain.\n\nAdditional tests needed:\n- Test with explicit `Depth: 1` to verify parent-only behavior\n- Test with `Depth: 0` or nil to verify unlimited behavior\n- Mock or integration test to verify matching at grandparent level\n\n## Dependencies\n\n- Depends on: `ribbin-5cs` (GetAncestorCommands in process package)\n- Depends on: `ribbin-g5w` (Depth field in PassthroughConfig)\n\n## Acceptance Criteria\n\n- [ ] `shouldPassthrough()` uses `GetAncestorCommands()` instead of `GetParentCommand()`\n- [ ] Respects `Depth` field from config\n- [ ] Existing tests pass\n- [ ] New tests verify ancestor matching behavior","status":"closed","priority":2,"issue_type":"task","owner":"don.denton@trillianthealth.com","created_at":"2026-01-22T00:33:30.047721-05:00","created_by":"Don Denton","updated_at":"2026-01-22T09:42:09.902311-05:00","closed_at":"2026-01-22T09:42:09.902311-05:00","close_reason":"Closed","dependencies":[{"issue_id":"ribbin-k1q","depends_on_id":"ribbin-5cs","type":"blocks","created_at":"2026-01-22T00:34:04.423829-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-k1q","depends_on_id":"ribbin-g5w","type":"blocks","created_at":"2026-01-22T00:34:04.487569-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-k1q","depends_on_id":"ribbin-9r5","type":"parent-child","created_at":"2026-01-22T09:35:40.956122-05:00","created_by":"Don Denton"}]}
{"id":"ribbin-ksw","title":"Create comprehensive security test suite","description":"# Security Test Suite (MEDIUM PRIORITY)\n\nCreate comprehensive security tests to validate all security controls and attempt to exploit vulnerabilities.\n\n## Purpose\n\nSystematically test all security mitigations to ensure:\n- Vulnerabilities are actually fixed\n- Security controls can't be bypassed\n- Edge cases are covered\n- Regression testing for security fixes\n\n## Test Categories\n\n### 1. Path Traversal Tests\n\n**File**: `tests/security/path_traversal_test.go`\n\n```go\nfunc TestPathTraversal_ConfigPaths(t *testing.T) {\n    maliciousPaths := []string{\n        \"../../etc/passwd\",\n        \"../../../usr/bin/bash\",\n        \"/usr/bin/../../../etc/shadow\",\n        \"~/../../../etc/passwd\",\n        \"./../../etc/passwd\",\n    }\n    \n    for _, path := range maliciousPaths {\n        t.Run(path, func(t *testing.T) {\n            err := security.ValidateBinaryPath(path)\n            assert.Error(t, err, \"should reject: %s\", path)\n            assert.Contains(t, err.Error(), \"traversal\")\n        })\n    }\n}\n\nfunc TestPathTraversal_InConfig(t *testing.T) {\n    tmpDir := t.TempDir()\n    configFile := filepath.Join(tmpDir, \"ribbin.toml\")\n    \n    maliciousConfig := `\n[shims.evil]\naction = \"block\"\npaths = [\"../../etc/passwd\"]\n`\n    \n    os.WriteFile(configFile, []byte(maliciousConfig), 0644)\n    \n    cfg, err := config.LoadProjectConfig(configFile)\n    assert.Error(t, err, \"should reject config with path traversal\")\n}\n```\n\n### 2. TOCTOU Race Condition Tests\n\n**File**: `tests/security/toctou_test.go`\n\n```go\nfunc TestTOCTOU_ConcurrentInstall(t *testing.T) {\n    tmpDir := t.TempDir()\n    binary := filepath.Join(tmpDir, \"test-binary\")\n    ribbin := \"/usr/local/bin/ribbin\"  // Assume ribbin is installed\n    \n    // Create test binary\n    content := []byte(\"#!/bin/sh\\necho original\")\n    os.WriteFile(binary, content, 0755)\n    \n    // Launch concurrent install attempts\n    const numAttempts = 10\n    var wg sync.WaitGroup\n    errors := make([]error, numAttempts)\n    \n    for i := 0; i \u003c numAttempts; i++ {\n        wg.Add(1)\n        go func(idx int) {\n            defer wg.Done()\n            errors[idx] = shim.Install(binary, ribbin, false)\n        }(i)\n    }\n    \n    wg.Wait()\n    \n    // Exactly ONE install should succeed\n    successCount := 0\n    for _, err := range errors {\n        if err == nil {\n            successCount++\n        }\n    }\n    \n    assert.Equal(t, 1, successCount, \"exactly one install should succeed\")\n}\n\nfunc TestTOCTOU_FileReplacement(t *testing.T) {\n    // Test attacker replacing file between check and use\n    tmpDir := t.TempDir()\n    binary := filepath.Join(tmpDir, \"test-binary\")\n    \n    // Create original\n    os.WriteFile(binary, []byte(\"original\"), 0755)\n    \n    // Start install in goroutine\n    installDone := make(chan error)\n    go func() {\n        installDone \u003c- shim.Install(binary, \"/usr/local/bin/ribbin\", false)\n    }()\n    \n    // Try to replace file during install\n    time.Sleep(10 * time.Millisecond)\n    os.WriteFile(binary, []byte(\"malicious\"), 0755)\n    \n    err := \u003c-installDone\n    \n    // Should either succeed with original OR fail with verification error\n    // Should NEVER succeed with malicious content\n    if err != nil {\n        assert.Contains(t, err.Error(), \"changed\")\n    }\n}\n```\n\n### 3. Symlink Attack Tests\n\n**File**: `tests/security/symlink_test.go`\n\n```go\nfunc TestSymlinkAttack_ToSystemBinary(t *testing.T) {\n    tmpDir := t.TempDir()\n    link := filepath.Join(tmpDir, \"myapp\")\n    \n    // Create symlink to bash\n    os.Symlink(\"/usr/bin/bash\", link)\n    \n    err := shim.Install(link, \"/usr/local/bin/ribbin\", false)\n    assert.Error(t, err)\n    assert.Contains(t, err.Error(), \"critical system binary\")\n}\n\nfunc TestSymlinkAttack_Circular(t *testing.T) {\n    tmpDir := t.TempDir()\n    link1 := filepath.Join(tmpDir, \"link1\")\n    link2 := filepath.Join(tmpDir, \"link2\")\n    \n    // Create circular symlinks\n    os.Symlink(link2, link1)\n    os.Symlink(link1, link2)\n    \n    err := shim.Install(link1, \"/usr/local/bin/ribbin\", false)\n    assert.Error(t, err)\n    assert.Contains(t, err.Error(), \"circular\")\n}\n\nfunc TestSymlinkAttack_ChainToForbidden(t *testing.T) {\n    tmpDir := t.TempDir()\n    \n    // Create chain: link1 -\u003e link2 -\u003e /etc/passwd\n    link2 := filepath.Join(tmpDir, \"link2\")\n    link1 := filepath.Join(tmpDir, \"link1\")\n    \n    os.Symlink(\"/etc/passwd\", link2)\n    os.Symlink(link2, link1)\n    \n    err := shim.Install(link1, \"/usr/local/bin/ribbin\", false)\n    assert.Error(t, err)\n    assert.Contains(t, err.Error(), \"outside allowed\")\n}\n```\n\n### 4. Allowlist Bypass Tests\n\n**File**: `tests/security/allowlist_test.go`\n\n```go\nfunc TestAllowlist_CriticalBinaries(t *testing.T) {\n    criticalBinaries := []string{\n        \"/usr/bin/bash\",\n        \"/bin/sh\",\n        \"/usr/bin/sudo\",\n        \"/usr/bin/su\",\n        \"/usr/bin/ssh\",\n        \"/usr/sbin/sshd\",\n    }\n    \n    for _, binary := range criticalBinaries {\n        t.Run(binary, func(t *testing.T) {\n            err := security.ValidateBinaryForShim(binary, true)\n            assert.Error(t, err, \"should block critical binary: %s\", binary)\n            assert.Contains(t, err.Error(), \"critical\")\n        })\n    }\n}\n\nfunc TestAllowlist_SystemDirectories(t *testing.T) {\n    forbiddenDirs := []string{\n        \"/bin/myapp\",\n        \"/sbin/myapp\",\n        \"/usr/bin/myapp\",\n        \"/usr/sbin/myapp\",\n    }\n    \n    for _, path := range forbiddenDirs {\n        t.Run(path, func(t *testing.T) {\n            err := security.ValidateBinaryForShim(path, false)\n            assert.Error(t, err, \"should block system directory: %s\", path)\n        })\n    }\n}\n\nfunc TestAllowlist_ConfirmationRequired(t *testing.T) {\n    // These should succeed WITH confirmation flag\n    confirmDirs := []string{\n        \"/usr/local/bin/myapp\",\n        \"/opt/homebrew/bin/myapp\",\n    }\n    \n    for _, path := range confirmDirs {\n        t.Run(path+\"_without_flag\", func(t *testing.T) {\n            err := security.ValidateBinaryForShim(path, false)\n            assert.Error(t, err)\n            assert.Contains(t, err.Error(), \"confirmation\")\n        })\n        \n        t.Run(path+\"_with_flag\", func(t *testing.T) {\n            err := security.ValidateBinaryForShim(path, true)\n            assert.NoError(t, err)\n        })\n    }\n}\n```\n\n### 5. Environment Injection Tests\n\n**File**: `tests/security/environment_test.go`\n\n```go\nfunc TestEnvInjection_HomeDirManipulation(t *testing.T) {\n    // Save original\n    originalHome := os.Getenv(\"HOME\")\n    defer os.Setenv(\"HOME\", originalHome)\n    \n    // Set malicious HOME\n    os.Setenv(\"HOME\", \"/tmp/malicious\")\n    \n    // Should detect and reject\n    home, err := security.ValidateHomeDir()\n    assert.Error(t, err)\n}\n\nfunc TestEnvInjection_XDGConfigHome(t *testing.T) {\n    originalXDG := os.Getenv(\"XDG_CONFIG_HOME\")\n    defer func() {\n        if originalXDG != \"\" {\n            os.Setenv(\"XDG_CONFIG_HOME\", originalXDG)\n        } else {\n            os.Unsetenv(\"XDG_CONFIG_HOME\")\n        }\n    }()\n    \n    // Try path traversal in XDG_CONFIG_HOME\n    os.Setenv(\"XDG_CONFIG_HOME\", \"/tmp/../../etc\")\n    \n    configDir, err := security.GetConfigDir()\n    assert.Error(t, err)\n}\n```\n\n### 6. Privilege Escalation Tests\n\n**File**: `tests/security/privilege_test.go`\n\n```go\nfunc TestPrivilegeEscalation_RootWarning(t *testing.T) {\n    if os.Getuid() != 0 {\n        t.Skip(\"must run as root\")\n    }\n    \n    // Running as root should trigger warnings\n    tmpDir := t.TempDir()\n    binary := filepath.Join(tmpDir, \"test-binary\")\n    os.WriteFile(binary, []byte(\"#!/bin/sh\\necho test\"), 0755)\n    \n    // Should warn about running as root\n    // (implementation should log to audit log)\n    err := shim.Install(binary, \"/usr/local/bin/ribbin\", false)\n    \n    // Check audit log for elevated privilege event\n    events, _ := security.QueryAuditLog(\u0026security.AuditQuery{\n        Elevated: boolPtr(true),\n    })\n    assert.NotEmpty(t, events, \"should log elevated privilege operation\")\n}\n```\n\n### 7. Integration Attack Scenarios\n\n**File**: `tests/security/integration_test.go`\n\n```go\nfunc TestAttackScenario_ConfigInjection(t *testing.T) {\n    // Attacker creates malicious config in parent directory\n    tmpDir := t.TempDir()\n    projectDir := filepath.Join(tmpDir, \"project\")\n    os.Mkdir(projectDir, 0755)\n    \n    // Malicious config in parent\n    maliciousConfig := `\n[shims.bash]\naction = \"redirect\"\npaths = [\"/usr/bin/bash\"]\nscript = \"#!/bin/sh\\ncat /etc/passwd\"\n`\n    configFile := filepath.Join(tmpDir, \"ribbin.toml\")\n    os.WriteFile(configFile, []byte(maliciousConfig), 0644)\n    \n    // Change to project directory\n    os.Chdir(projectDir)\n    \n    // Try to load config\n    cfg, err := config.FindProjectConfig()\n    \n    // Should reject malicious config\n    if err == nil {\n        // Config found, but shims should be rejected\n        for name, shim := range cfg.Shims {\n            for _, path := range shim.Paths {\n                err := security.ValidateBinaryPath(path)\n                assert.Error(t, err, \"should reject path for %s\", name)\n            }\n        }\n    }\n}\n\nfunc TestAttackScenario_RegistryTampering(t *testing.T) {\n    // Test detection of registry tampering\n    tmpDir := t.TempDir()\n    os.Setenv(\"XDG_CONFIG_HOME\", tmpDir)\n    defer os.Unsetenv(\"XDG_CONFIG_HOME\")\n    \n    // Create valid registry\n    registry := \u0026config.ShimRegistry{\n        Shims: make(map[string]*config.ShimEntry),\n    }\n    config.SaveRegistry(registry)\n    \n    // Tamper with registry\n    registryPath, _ := security.GetConfigDir()\n    registryFile := filepath.Join(registryPath, \"registry.json\")\n    data, _ := os.ReadFile(registryFile)\n    \n    // Modify data\n    tampered := strings.Replace(string(data), \"{\", \"{ \\\"injected\\\": \\\"data\\\",\", 1)\n    os.WriteFile(registryFile, []byte(tampered), 0644)\n    \n    // Should detect tampering (if integrity checks implemented)\n    _, err := config.LoadRegistry()\n    // Implementation-dependent: may succeed with extra fields or fail with checksum error\n}\n```\n\n## Fuzzing Tests\n\n**File**: `tests/security/fuzz_test.go`\n\n```go\nfunc FuzzPathValidation(f *testing.F) {\n    // Seed corpus\n    seeds := []string{\n        \"/usr/bin/tool\",\n        \"../../etc/passwd\",\n        \"/tmp/test\",\n        \"~/.local/bin/tool\",\n    }\n    \n    for _, seed := range seeds {\n        f.Add(seed)\n    }\n    \n    f.Fuzz(func(t *testing.T, path string) {\n        // Should never panic\n        security.ValidateBinaryPath(path)\n    })\n}\n\nfunc FuzzConfigParsing(f *testing.F) {\n    f.Fuzz(func(t *testing.T, configData []byte) {\n        tmpDir := t.TempDir()\n        configFile := filepath.Join(tmpDir, \"ribbin.toml\")\n        os.WriteFile(configFile, configData, 0644)\n        \n        // Should never panic\n        config.LoadProjectConfig(configFile)\n    })\n}\n```\n\n## Test Execution\n\nCreate `tests/security/run_security_tests.sh`:\n\n```bash\n#!/bin/bash\nset -e\n\necho \"Running security test suite...\"\n\n# Unit tests\necho \"==\u003e Path traversal tests\"\ngo test -v ./tests/security/path_traversal_test.go\n\necho \"==\u003e TOCTOU tests\"\ngo test -v ./tests/security/toctou_test.go -race\n\necho \"==\u003e Symlink attack tests\"\ngo test -v ./tests/security/symlink_test.go\n\necho \"==\u003e Allowlist tests\"\ngo test -v ./tests/security/allowlist_test.go\n\necho \"==\u003e Environment injection tests\"\ngo test -v ./tests/security/environment_test.go\n\necho \"==\u003e Integration attack scenarios\"\ngo test -v ./tests/security/integration_test.go\n\necho \"==\u003e Fuzzing (5 seconds)\"\ngo test -fuzz=FuzzPathValidation -fuzztime=5s ./tests/security/fuzz_test.go\n\necho \"✅ All security tests passed\"\n```\n\n## Success Criteria\n\n- [ ] All vulnerability categories have test coverage\n- [ ] Tests attempt real exploits (not just happy path)\n- [ ] Race condition tests use -race flag\n- [ ] Fuzzing tests for parser and validation\n- [ ] Integration tests simulate attack scenarios\n- [ ] Tests verify audit logging of security events\n- [ ] All tests pass consistently\n- [ ] Test suite runs in CI/CD\n\n## Dependencies\n\n- Requires: All security modules implemented\n- Final validation step\n\n## Estimated Complexity\n\nHigh - Comprehensive testing, race conditions, fuzzing, attack simulation","status":"closed","priority":2,"issue_type":"task","owner":"don@happycollision.com","created_at":"2026-01-18T13:38:42.465521-05:00","created_by":"Don Denton","updated_at":"2026-01-18T23:27:20.809641-05:00","closed_at":"2026-01-18T23:27:20.809641-05:00","close_reason":"Created comprehensive security attack test suite covering path traversal, symlink attacks, allowlist bypass, environment injection, TOCTOU race conditions, and integration scenarios. All tests pass including with race detector.","dependencies":[{"issue_id":"ribbin-ksw","depends_on_id":"ribbin-rx1","type":"parent-child","created_at":"2026-01-18T13:40:01.136176-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-ksw","depends_on_id":"ribbin-pu4","type":"blocks","created_at":"2026-01-18T13:40:21.124236-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-ksw","depends_on_id":"ribbin-rrg","type":"blocks","created_at":"2026-01-18T13:40:26.372061-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-ksw","depends_on_id":"ribbin-x2z","type":"blocks","created_at":"2026-01-18T13:40:31.628054-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-ksw","depends_on_id":"ribbin-d7s","type":"blocks","created_at":"2026-01-18T13:40:36.868423-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-ksw","depends_on_id":"ribbin-4rc","type":"blocks","created_at":"2026-01-18T13:40:42.145346-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-ksw","depends_on_id":"ribbin-c1g","type":"blocks","created_at":"2026-01-18T13:40:47.386478-05:00","created_by":"Don Denton"}]}
{"id":"ribbin-lk2","title":"Support ribbin.local.jsonc as user-local config override","description":"Allow users to define local config overrides via ribbin.local.jsonc. This file takes precedence over ribbin.jsonc in the same directory, giving users a way to define their own rules in a shared repo.\n\nKey behaviors:\n- ribbin.local.jsonc is loaded INSTEAD of ribbin.jsonc when present\n- If users want to extend the original rules, they must explicitly use extends\n- Documentation should recommend adding ribbin.local.jsonc to .gitignore","status":"closed","priority":2,"issue_type":"feature","owner":"don@happycollision.com","created_at":"2026-01-20T15:31:28.826233-05:00","created_by":"Don Denton","updated_at":"2026-01-20T16:12:21.933735-05:00","closed_at":"2026-01-20T16:12:21.933735-05:00","close_reason":"Implemented ribbin.local.jsonc support: FindProjectConfig now prefers local config, security validation updated, tests added, documentation updated"}
{"id":"ribbin-mz1","title":"Phase 2: Config format changes (shims → wraps)","description":"# Phase 2: Config format changes (shims → wrappers)\n\nRename config sections from `[shims.*]` to `[wrappers.*]`.\n\n## Files to Modify\n\n- `internal/config/project.go`\n- All files in `testdata/**/*.toml`\n\n## Changes Required\n\n### 1. Rename structs in project.go\n\n```go\n// Old\ntype ShimConfig struct { ... }\ntype ProjectConfig struct {\n    Shims  map[string]ShimConfig  `toml:\"shims\"`\n    Scopes map[string]ScopeConfig `toml:\"scopes\"`\n}\ntype ScopeConfig struct {\n    Shims map[string]ShimConfig `toml:\"shims\"`\n    ...\n}\n\n// New\ntype WrapperConfig struct { ... }\ntype ProjectConfig struct {\n    Wrappers map[string]WrapperConfig  `toml:\"wrappers\"`\n    Scopes   map[string]ScopeConfig    `toml:\"scopes\"`\n}\ntype ScopeConfig struct {\n    Wrappers map[string]WrapperConfig `toml:\"wrappers\"`\n    ...\n}\n```\n\n### 2. Update all testdata TOML files\n\nChange:\n```toml\n[shims.npm]\naction = \"block\"\n\n[scopes.frontend.shims.yarn]\naction = \"block\"\n```\n\nTo:\n```toml\n[wrappers.npm]\naction = \"block\"\n\n[scopes.frontend.wrappers.yarn]\naction = \"block\"\n```\n\n## Testdata files to update\n\n- `testdata/configs/valid.toml`\n- `testdata/configs/minimal.toml`\n- `testdata/projects/basic/ribbin.toml`\n- `testdata/projects/nested/ribbin.toml`\n- `testdata/projects/redirect/ribbin.toml`\n- `testdata/projects/scoped/ribbin.toml`\n- `testdata/projects/scoped/external/ribbin.toml`\n\n## Tests \u0026 Documentation\n\n- Update all config loading tests\n- Update CLAUDE.md config examples\n- Update any scenario scripts that embed TOML configs\n\n## Verification\n\n- All config loading tests pass\n- TOML parsing works with new field names","status":"closed","priority":2,"issue_type":"task","owner":"don@happycollision.com","created_at":"2026-01-20T11:21:14.753597-05:00","created_by":"Don Denton","updated_at":"2026-01-20T13:07:20.266061-05:00","closed_at":"2026-01-20T13:07:20.266061-05:00","close_reason":"Completed: Renamed config format from shims to wrappers","dependencies":[{"issue_id":"ribbin-mz1","depends_on_id":"ribbin-is0","type":"blocks","created_at":"2026-01-20T11:23:21.27738-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-mz1","depends_on_id":"ribbin-4ao","type":"blocks","created_at":"2026-01-20T11:24:06.508654-05:00","created_by":"Don Denton"}]}
{"id":"ribbin-no9","title":"Phase 5: Three-tier activation logic in runner","description":"# Phase 5: Three-tier activation logic in runner\n\nUpdate the wrap runner to implement the three-tier activation model.\n\n## Files to Modify\n\n- `internal/wrap/runner.go` (formerly internal/shim/runner.go)\n\n## Changes Required\n\n### 1. Update isActive() function\n\nCurrent logic:\n```go\nfunc isActive(registry *config.Registry) bool {\n    if registry.GlobalOn {\n        return true\n    }\n    // Check shell activations\n    for pid := range registry.Activations {\n        if process.IsDescendantOf(pid) {\n            return true\n        }\n    }\n    return false\n}\n```\n\nNew logic:\n```go\nfunc isActive(registry *config.Registry, configPath string) bool {\n    // Priority 1: Global overrides everything\n    if registry.GlobalActive {\n        return true\n    }\n    \n    // Priority 2: Shell activation (any config fires)\n    registry.PruneDeadShellActivations()\n    for pid := range registry.ShellActivations {\n        if isDescendant, _ := process.IsDescendantOf(pid); isDescendant {\n            return true\n        }\n    }\n    \n    // Priority 3: Config-specific activation\n    if _, ok := registry.ConfigActivations[configPath]; ok {\n        return true\n    }\n    \n    return false\n}\n```\n\n### 2. Pass config path to isActive()\n\nThe runner needs to know which config file is relevant for the current invocation.\nUpdate the call site to pass the nearest ribbin.toml path.\n\n### 3. Add global warning banner to CLI output\n\nCreate a helper function that all CLI commands can use:\n\n```go\nfunc printGlobalWarningIfActive() {\n    registry, _ := config.LoadRegistry()\n    if registry != nil \u0026\u0026 registry.GlobalActive {\n        fmt.Fprintln(os.Stderr, \"⚠️  GLOBAL MODE ACTIVE - All wrappers firing everywhere\")\n        fmt.Fprintln(os.Stderr, \"   Run `ribbin deactivate --global` to disable\")\n        fmt.Fprintln(os.Stderr, \"\")\n    }\n}\n```\n\nCall this at the start of every CLI command.\n\n## Tests \u0026 Documentation\n\n- Add tests for three-tier activation priority\n- Test global warning banner appears correctly\n- Update any documentation about activation behavior\n\n## Verification\n\n- With nothing activated: wrapped tools pass through\n- With config activated: only that config's tools intercept\n- With shell activated: all configs intercept in that shell\n- With global activated: everything intercepts everywhere\n- Global warning banner appears on all CLI output when global is active","status":"closed","priority":2,"issue_type":"task","owner":"don@happycollision.com","created_at":"2026-01-20T11:22:18.852379-05:00","created_by":"Don Denton","updated_at":"2026-01-20T14:54:00.452645-05:00","closed_at":"2026-01-20T14:54:00.452645-05:00","close_reason":"Phase 5 complete: Three-tier activation logic implemented in runner. isActive() now checks global \u003e shell \u003e config priority. Global warning banner added to all CLI commands.","dependencies":[{"issue_id":"ribbin-no9","depends_on_id":"ribbin-is0","type":"blocks","created_at":"2026-01-20T11:23:36.97399-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-no9","depends_on_id":"ribbin-hzh","type":"blocks","created_at":"2026-01-20T11:24:22.218532-05:00","created_by":"Don Denton"}]}
{"id":"ribbin-o5c","title":"Phase 6: Metadata sidecars for stale detection","description":"# Phase 6: Metadata sidecars for stale detection\n\nAdd `.ribbin-meta` files to track original binary hash and detect stale sidecars.\n\n## Files to Modify\n\n- `internal/wrap/installer.go`\n\n## Changes Required\n\n### 1. Create metadata struct\n\n```go\ntype WrapperMetadata struct {\n    WrappedAt     time.Time `json:\"wrapped_at\"`\n    OriginalHash  string    `json:\"original_hash\"`   // sha256:abc123...\n    OriginalSize  int64     `json:\"original_size\"`\n    RibbinPath    string    `json:\"ribbin_path\"`\n    RibbinVersion string    `json:\"ribbin_version\"`\n}\n```\n\n### 2. On wrap (Install function)\n\nAfter creating the sidecar, also create `.ribbin-meta`:\n\n```go\nfunc Install(binaryPath, ribbinPath string, ...) error {\n    // ... existing logic to create sidecar ...\n    \n    // Calculate hash of original binary\n    hash, err := hashFile(binaryPath)\n    if err != nil {\n        return err\n    }\n    \n    // Get file size\n    info, _ := os.Stat(binaryPath)\n    \n    // Create metadata\n    meta := WrapperMetadata{\n        WrappedAt:     time.Now(),\n        OriginalHash:  hash,\n        OriginalSize:  info.Size(),\n        RibbinPath:    ribbinPath,\n        RibbinVersion: version.Version, // need to add version package\n    }\n    \n    // Write metadata file\n    metaPath := binaryPath + \".ribbin-meta\"\n    data, _ := json.MarshalIndent(meta, \"\", \"  \")\n    os.WriteFile(metaPath, data, 0644)\n    \n    // ... continue with symlink creation ...\n}\n```\n\n### 3. On unwrap (Uninstall function)\n\nWhen hash mismatch or unexpected state detected, present clear options:\n\n```go\nfunc Uninstall(binaryPath string, ...) error {\n    sidecarPath := binaryPath + \".ribbin-original\"\n    metaPath := binaryPath + \".ribbin-meta\"\n    \n    // Read metadata if exists\n    meta, err := loadMetadata(metaPath)\n    if err == nil {\n        currentHash, _ := hashFile(sidecarPath)\n        if currentHash != meta.OriginalHash {\n            // Present situation clearly\n            fmt.Printf(\"\\n⚠️  Conflict detected for %s\\n\", binaryPath)\n            fmt.Printf(\"The tool appears to have been reinstalled since ribbin wrapped it.\\n\")\n            fmt.Printf(\"\\n\")\n            fmt.Printf(\"For details on how ribbin wrapping works, see:\\n\")\n            fmt.Printf(\"  https://github.com/happycollision/ribbin#how-wrapping-works\\n\")\n            fmt.Printf(\"\\n\")\n            fmt.Printf(\"Options:\\n\")\n            fmt.Printf(\"  1. Do nothing - leave current binary and ribbin sidecar files\\n\")\n            fmt.Printf(\"  2. Clean up   - remove sidecar files, keep current binary\\n\")\n            fmt.Printf(\"  3. Restore    - replace current binary with original from sidecar\\n\")\n            fmt.Printf(\"\\n\")\n            fmt.Print(\"Choose [1/2/3]: \")\n            \n            // Record choice for summary\n            choice := readUserChoice()\n            recordResolution(binaryPath, choice)\n            \n            switch choice {\n            case 1:\n                return nil // skip this binary\n            case 2:\n                os.Remove(sidecarPath)\n                os.Remove(metaPath)\n                return nil\n            case 3:\n                // proceed with normal restoration\n            }\n        }\n    }\n    \n    // Clean up metadata file\n    os.Remove(metaPath)\n    \n    // ... continue with restoration ...\n}\n```\n\n### 4. Summary output at end of unwrap\n\nAfter processing all binaries, print a summary:\n\n```\nUnwrap Summary\n==============\n\n✓ Restored:\n  /usr/local/bin/tsc\n  /usr/local/bin/eslint\n\n⚠️  Conflicts resolved:\n  /usr/local/bin/npm      → cleaned up (kept current binary)\n  /usr/local/bin/node     → skipped (no changes made)\n  /usr/local/bin/yarn     → restored original\n\nFor details on how ribbin wrapping works, see:\n  https://github.com/happycollision/ribbin#how-wrapping-works\n```\n\n### 5. Hash function\n\n```go\nfunc hashFile(path string) (string, error) {\n    f, err := os.Open(path)\n    if err != nil {\n        return \"\", err\n    }\n    defer f.Close()\n    \n    h := sha256.New()\n    if _, err := io.Copy(h, f); err != nil {\n        return \"\", err\n    }\n    \n    return \"sha256:\" + hex.EncodeToString(h.Sum(nil)), nil\n}\n```\n\n## Tests \u0026 Documentation\n\n- Test metadata file creation on wrap\n- Test hash verification on unwrap\n- Test all three resolution options\n- Test summary output format\n- Document the metadata sidecar format\n- Add \"How Wrapping Works\" section to README\n\n## Verification\n\n- Wrap creates both `.ribbin-original` and `.ribbin-meta`\n- Unwrap reads metadata and verifies hash\n- Three clear options presented on conflict\n- Summary at end shows all resolutions\n- Documentation link displayed for conflicts","status":"closed","priority":2,"issue_type":"task","owner":"don@happycollision.com","created_at":"2026-01-20T11:22:24.217814-05:00","created_by":"Don Denton","updated_at":"2026-01-20T15:06:28.018554-05:00","closed_at":"2026-01-20T15:06:28.018554-05:00","close_reason":"Phase 6 complete: Metadata sidecars implemented. Install creates .ribbin-meta files with hash/size/version. Unwrap detects hash conflicts and presents interactive resolution options (skip/cleanup/restore). Summary output at end of unwrap.","dependencies":[{"issue_id":"ribbin-o5c","depends_on_id":"ribbin-is0","type":"blocks","created_at":"2026-01-20T11:23:42.206152-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-o5c","depends_on_id":"ribbin-no9","type":"blocks","created_at":"2026-01-20T11:24:27.448084-05:00","created_by":"Don Denton"}]}
{"id":"ribbin-pmw","title":"Implement command resolver (which lookup)","description":"# Command Resolver Implementation\n\nResolve command names to their binary paths.\n\n## File to Create\n\n### internal/shim/resolver.go\n\n```go\n// ResolveCommand finds the path to a command using the system PATH\n// Similar to running `which \u003ccommand\u003e`\nfunc ResolveCommand(name string) (string, error)\n\n// ResolveCommands resolves multiple commands, returning map of name-\u003epath\n// Skips commands that can't be found (logs warning)\nfunc ResolveCommands(names []string) map[string]string\n```\n\n## Implementation Notes\n\n- Use `exec.LookPath(name)` from `os/exec` package\n- This finds the command the same way the shell would\n- Must handle case where command doesn't exist (return error)\n- Must handle case where command is already a symlink to ribbin (skip it)\n\n## Edge Cases\n\n- Command not found → return descriptive error\n- Command is already shimmed (symlink to ribbin) → detect and skip\n- Multiple commands with same name in PATH → returns first match (correct behavior)\n\n## Detection of Already-Shimmed\n\n```go\nfunc IsAlreadyShimmed(path string) (bool, error) {\n    // Check if path is a symlink\n    info, err := os.Lstat(path)\n    if err != nil {\n        return false, err\n    }\n    if info.Mode()\u0026os.ModeSymlink == 0 {\n        return false, nil // Not a symlink\n    }\n    \n    // Check if symlink points to ribbin\n    target, err := os.Readlink(path)\n    if err != nil {\n        return false, err\n    }\n    return filepath.Base(target) == \"ribbin\", nil\n}\n```\n\n## Tests\n\n- Test resolving common commands (ls, cat, echo)\n- Test command not found error\n- Test detecting already-shimmed binary\n\n## Acceptance Criteria\n\n- `ResolveCommand(\"cat\")` returns `/bin/cat` or similar\n- `ResolveCommand(\"nonexistent\")` returns error\n- Can detect if a binary is already a ribbin symlink","status":"closed","priority":2,"issue_type":"task","owner":"don@happycollision.com","created_at":"2026-01-17T22:03:02.035042-05:00","created_by":"Don Denton","updated_at":"2026-01-17T22:56:39.47062-05:00","closed_at":"2026-01-17T22:56:39.47062-05:00","close_reason":"Closed","dependencies":[{"issue_id":"ribbin-pmw","depends_on_id":"ribbin-skj","type":"parent-child","created_at":"2026-01-17T22:10:48.57734-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-pmw","depends_on_id":"ribbin-8n3","type":"blocks","created_at":"2026-01-17T22:12:04.452226-05:00","created_by":"Don Denton"}]}
{"id":"ribbin-pu4","title":"Implement path sanitization and validation module","description":"# Path Sanitization Module (CRITICAL)\n\nCreate `internal/security/paths.go` to provide comprehensive path validation for all file operations.\n\n## Current Vulnerability\n\n**Location**: Throughout codebase, especially:\n- `internal/config/project.go:26-48` - Config discovery with no traversal checks\n- `internal/cli/shim.go:89-94` - Paths from config used directly\n- `internal/shim/installer.go:13` - Simple string concatenation for sidecar paths\n- `internal/shim/resolver.go:11` - Relies solely on exec.LookPath()\n\n**Risk**: User-provided paths in config files enable path traversal attacks:\n```toml\n[shims.evil]\npaths = [\"../../etc/passwd\"]  # Could target any file\n```\n\n## Implementation Requirements\n\n### Core Functions\n\n```go\npackage security\n\nimport (\n    \"fmt\"\n    \"path/filepath\"\n    \"os\"\n    \"strings\"\n)\n\n// ValidateBinaryPath ensures a binary path is safe to shim\nfunc ValidateBinaryPath(path string) error {\n    // 1. Canonicalize path\n    clean := filepath.Clean(path)\n    abs, err := filepath.Abs(clean)\n    if err != nil {\n        return fmt.Errorf(\"cannot resolve path: %w\", err)\n    }\n\n    // 2. Check for traversal sequences\n    if strings.Contains(path, \"..\") {\n        return fmt.Errorf(\"path traversal detected: %s\", path)\n    }\n\n    // 3. Validate it's within expected directories (use allowlist)\n    if !isWithinAllowedDirectory(abs) {\n        return fmt.Errorf(\"path outside allowed directories: %s\", abs)\n    }\n\n    // 4. Check it's not a symlink (or validate symlink target)\n    info, err := os.Lstat(abs)\n    if err != nil \u0026\u0026 !os.IsNotExist(err) {\n        return fmt.Errorf(\"cannot stat path: %w\", err)\n    }\n    if info != nil \u0026\u0026 info.Mode()\u0026os.ModeSymlink != 0 {\n        // Validate symlink target\n        target, err := ValidateSymlinkTarget(abs)\n        if err != nil {\n            return err\n        }\n        abs = target\n    }\n\n    return nil\n}\n\n// ValidateConfigPath ensures config file is safe to load\nfunc ValidateConfigPath(path string) error {\n    clean := filepath.Clean(path)\n    abs, err := filepath.Abs(clean)\n    if err != nil {\n        return fmt.Errorf(\"cannot resolve config path: %w\", err)\n    }\n\n    // Must end with ribbin.toml\n    if filepath.Base(abs) != \"ribbin.toml\" {\n        return fmt.Errorf(\"config must be named ribbin.toml\")\n    }\n\n    // Check file permissions (not world-writable)\n    info, err := os.Stat(abs)\n    if err != nil {\n        return fmt.Errorf(\"cannot stat config: %w\", err)\n    }\n    if info.Mode().Perm()\u00260002 != 0 {\n        return fmt.Errorf(\"config file is world-writable: %s\", abs)\n    }\n\n    return nil\n}\n\n// ValidateSymlinkTarget safely resolves and validates symlink\nfunc ValidateSymlinkTarget(link string) (string, error) {\n    target, err := os.Readlink(link)\n    if err != nil {\n        return \"\", fmt.Errorf(\"cannot read symlink: %w\", err)\n    }\n\n    // If relative, resolve against link's directory\n    if !filepath.IsAbs(target) {\n        target = filepath.Join(filepath.Dir(link), target)\n    }\n\n    // Canonicalize and validate target\n    clean := filepath.Clean(target)\n    abs, err := filepath.Abs(clean)\n    if err != nil {\n        return \"\", fmt.Errorf(\"cannot resolve symlink target: %w\", err)\n    }\n\n    // Target must be within allowed directories\n    if !isWithinAllowedDirectory(abs) {\n        return \"\", fmt.Errorf(\"symlink target outside allowed directories: %s\", abs)\n    }\n\n    return abs, nil\n}\n\n// SanitizePath cleans and canonicalizes a path\nfunc SanitizePath(path string) (string, error) {\n    clean := filepath.Clean(path)\n    abs, err := filepath.Abs(clean)\n    if err != nil {\n        return \"\", fmt.Errorf(\"cannot resolve path: %w\", err)\n    }\n    return abs, nil\n}\n\n// IsWithinDirectory checks if path is within root (no escaping via ..)\nfunc IsWithinDirectory(path, root string) (bool, error) {\n    cleanPath, err := filepath.Abs(filepath.Clean(path))\n    if err != nil {\n        return false, err\n    }\n    cleanRoot, err := filepath.Abs(filepath.Clean(root))\n    if err != nil {\n        return false, err\n    }\n\n    rel, err := filepath.Rel(cleanRoot, cleanPath)\n    if err != nil {\n        return false, err\n    }\n\n    // If relative path starts with .., it escapes root\n    return !strings.HasPrefix(rel, \"..\"), nil\n}\n\n// Helper: check if path is within any allowed directory\nfunc isWithinAllowedDirectory(path string) bool {\n    // Implemented after allowlist module is created\n    // For now, return true but this will be replaced\n    return true\n}\n```\n\n## Integration Points\n\n### Update installer.go\n```go\n// In internal/shim/installer.go Install function\nfunc Install(binaryPath, ribbinPath string) error {\n    // Validate paths first\n    if err := security.ValidateBinaryPath(binaryPath); err != nil {\n        return fmt.Errorf(\"invalid binary path: %w\", err)\n    }\n    if err := security.ValidateBinaryPath(ribbinPath); err != nil {\n        return fmt.Errorf(\"invalid ribbin path: %w\", err)\n    }\n\n    // Continue with installation...\n}\n\n// In SidecarPath function\nfunc SidecarPath(binaryPath string) (string, error) {\n    // Validate first\n    if err := security.ValidateBinaryPath(binaryPath); err != nil {\n        return \"\", err\n    }\n    \n    // Then construct sidecar path\n    return binaryPath + \".ribbin-original\", nil\n}\n```\n\n### Update project.go\n```go\n// In internal/config/project.go FindProjectConfig\nfunc FindProjectConfig() (string, error) {\n    cwd, err := os.Getwd()\n    if err != nil {\n        return \"\", err\n    }\n\n    dir := cwd\n    for {\n        configPath := filepath.Join(dir, \"ribbin.toml\")\n        \n        // Validate before returning\n        if _, err := os.Stat(configPath); err == nil {\n            if err := security.ValidateConfigPath(configPath); err != nil {\n                return \"\", fmt.Errorf(\"unsafe config file: %w\", err)\n            }\n            return configPath, nil\n        }\n        \n        // Walk up\n        parent := filepath.Dir(dir)\n        if parent == dir {\n            break\n        }\n        dir = parent\n    }\n    \n    return \"\", fmt.Errorf(\"no ribbin.toml found\")\n}\n```\n\n### Update cli/shim.go\n```go\n// In internal/cli/shim.go when processing config paths\nfor _, path := range paths {\n    // Validate path from config\n    if err := security.ValidateBinaryPath(path); err != nil {\n        fmt.Printf(\"Skipping invalid path '%s': %v\\n\", path, err)\n        continue\n    }\n    \n    // Check if command exists at this path\n    if _, err := os.Stat(path); os.IsNotExist(err) {\n        fmt.Printf(\"Warning: path '%s' does not exist\\n\", path)\n        continue\n    }\n    \n    // Install shim\n    // ...\n}\n```\n\n## Test Cases\n\nCreate `internal/security/paths_test.go`:\n\n```go\nfunc TestValidateBinaryPath_PathTraversal(t *testing.T) {\n    tests := []struct {\n        path      string\n        shouldErr bool\n    }{\n        {\"../../etc/passwd\", true},\n        {\"../../../usr/bin/bash\", true},\n        {\"/usr/bin/../../../etc/passwd\", true},\n        {\"/home/user/.local/bin/tool\", false},\n        {\"~/go/bin/tool\", false},\n    }\n    \n    for _, tt := range tests {\n        err := ValidateBinaryPath(tt.path)\n        if tt.shouldErr \u0026\u0026 err == nil {\n            t.Errorf(\"expected error for %s\", tt.path)\n        }\n        if !tt.shouldErr \u0026\u0026 err != nil {\n            t.Errorf(\"unexpected error for %s: %v\", tt.path, err)\n        }\n    }\n}\n\nfunc TestIsWithinDirectory(t *testing.T) {\n    tmpDir := t.TempDir()\n    \n    within := filepath.Join(tmpDir, \"subdir\", \"file\")\n    outside := filepath.Join(tmpDir, \"..\", \"outside\")\n    \n    ok, err := IsWithinDirectory(within, tmpDir)\n    assert.NoError(t, err)\n    assert.True(t, ok)\n    \n    ok, err = IsWithinDirectory(outside, tmpDir)\n    assert.NoError(t, err)\n    assert.False(t, ok)\n}\n\nfunc TestValidateSymlinkTarget(t *testing.T) {\n    tmpDir := t.TempDir()\n    target := filepath.Join(tmpDir, \"target\")\n    link := filepath.Join(tmpDir, \"link\")\n    \n    os.WriteFile(target, []byte(\"test\"), 0644)\n    os.Symlink(target, link)\n    \n    resolved, err := ValidateSymlinkTarget(link)\n    assert.NoError(t, err)\n    assert.Equal(t, target, resolved)\n    \n    // Evil symlink to /etc/passwd\n    evilLink := filepath.Join(tmpDir, \"evil\")\n    os.Symlink(\"/etc/passwd\", evilLink)\n    \n    _, err = ValidateSymlinkTarget(evilLink)\n    assert.Error(t, err)\n    assert.Contains(t, err.Error(), \"outside allowed directories\")\n}\n```\n\n## Success Criteria\n\n- [ ] All functions implemented with proper error handling\n- [ ] Path traversal sequences detected and rejected\n- [ ] Symlinks validated before following\n- [ ] Integration with installer.go, project.go, cli/shim.go complete\n- [ ] Test coverage \u003e90%\n- [ ] Manual testing with malicious paths confirms rejection\n\n## Dependencies\n\n- Must coordinate with task for directory allowlist (isWithinAllowedDirectory dependency)\n\n## Estimated Complexity\n\nHigh - Core security primitive affecting all file operations","status":"closed","priority":0,"issue_type":"task","owner":"don@happycollision.com","created_at":"2026-01-18T13:21:04.65315-05:00","created_by":"Don Denton","updated_at":"2026-01-18T14:45:53.913401-05:00","closed_at":"2026-01-18T14:45:53.913401-05:00","close_reason":"All three P0 security modules implemented and tested successfully. Directory allowlist prevents critical binary shimming, path sanitization blocks traversal attacks, and file locking eliminates TOCTOU race conditions.","dependencies":[{"issue_id":"ribbin-pu4","depends_on_id":"ribbin-rrg","type":"blocks","created_at":"2026-01-18T13:33:31.786133-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-pu4","depends_on_id":"ribbin-rx1","type":"parent-child","created_at":"2026-01-18T13:39:29.636213-05:00","created_by":"Don Denton"}]}
{"id":"ribbin-rrg","title":"Implement directory allowlist and critical binary protection","description":"# Directory Allowlist Module (CRITICAL)\n\nCreate `internal/security/allowlist.go` to restrict shim operations to safe directories and prevent compromising critical system binaries.\n\n## Current Vulnerability\n\n**Location**: All shim operations - no restrictions\n**Risk**: Can shim ANY binary in ANY directory, including:\n- `/usr/bin/bash` - compromise shell for all users\n- `/usr/bin/sudo` - intercept privilege escalation\n- `/usr/bin/su` - intercept user switching\n- `/bin/sh` - compromise system scripts\n\nCurrently this would succeed:\n```bash\nribbin shim bash  # Shims /usr/bin/bash - EXTREMELY DANGEROUS\n```\n\n## Implementation Requirements\n\n### Core Data Structures\n\n```go\npackage security\n\nimport (\n    \"path/filepath\"\n    \"os\"\n    \"strings\"\n)\n\n// DirectoryCategory defines security levels for directories\ntype DirectoryCategory int\n\nconst (\n    CategoryAllowed DirectoryCategory = iota  // Safe to shim\n    CategoryRequiresConfirmation              // System dirs, need confirmation\n    CategoryForbidden                         // Critical dirs, never allow\n)\n\n// AllowlistConfig defines which directories are safe for shimming\ntype AllowlistConfig struct {\n    // Directories where shimming is always safe\n    AllowedDirs []string\n    \n    // Directories that require explicit confirmation\n    ConfirmationDirs []string\n    \n    // Directories that are never allowed\n    ForbiddenDirs []string\n    \n    // Specific critical binaries that must never be shimmed\n    CriticalBinaries []string\n}\n\n// DefaultAllowlist returns the default secure allowlist\nfunc DefaultAllowlist() *AllowlistConfig {\n    home, _ := os.UserHomeDir()\n    \n    return \u0026AllowlistConfig{\n        AllowedDirs: []string{\n            filepath.Join(home, \".local\", \"bin\"),\n            filepath.Join(home, \"go\", \"bin\"),\n            filepath.Join(home, \".cargo\", \"bin\"),\n            filepath.Join(home, \"bin\"),\n            \"./bin\",           // Project-local bin\n            \"./node_modules/.bin\",  // npm bins\n        },\n        \n        ConfirmationDirs: []string{\n            \"/usr/local/bin\",\n            \"/opt/homebrew/bin\",\n            \"/opt/*/bin\",\n        },\n        \n        ForbiddenDirs: []string{\n            \"/bin\",\n            \"/sbin\",\n            \"/usr/bin\",\n            \"/usr/sbin\",\n            \"/usr/libexec\",\n            \"/System\",\n        },\n        \n        CriticalBinaries: []string{\n            \"bash\", \"sh\", \"zsh\", \"fish\",  // Shells\n            \"sudo\", \"su\", \"doas\",          // Privilege escalation\n            \"ssh\", \"sshd\",                 // Remote access\n            \"login\", \"passwd\",             // Authentication\n            \"init\", \"systemd\",             // System init\n            \"launchd\",                     // macOS init\n        },\n    }\n}\n```\n\n### Core Functions\n\n```go\n// IsAllowedDirectory checks if path is within an allowed directory\nfunc IsAllowedDirectory(path string) (bool, error) {\n    abs, err := filepath.Abs(filepath.Clean(path))\n    if err != nil {\n        return false, err\n    }\n    \n    config := DefaultAllowlist()\n    \n    // Check forbidden first\n    for _, forbidden := range config.ForbiddenDirs {\n        if isWithinDir(abs, forbidden) {\n            return false, nil\n        }\n    }\n    \n    // Check allowed\n    for _, allowed := range config.AllowedDirs {\n        if isWithinDir(abs, allowed) {\n            return true, nil\n        }\n    }\n    \n    // Not explicitly allowed\n    return false, nil\n}\n\n// IsCriticalSystemBinary checks if binary name is critical\nfunc IsCriticalSystemBinary(path string) bool {\n    config := DefaultAllowlist()\n    binName := filepath.Base(path)\n    \n    for _, critical := range config.CriticalBinaries {\n        if binName == critical {\n            return true\n        }\n    }\n    \n    return false\n}\n\n// RequiresConfirmation checks if path needs user confirmation\nfunc RequiresConfirmation(path string) bool {\n    abs, err := filepath.Abs(filepath.Clean(path))\n    if err != nil {\n        return true  // Err on side of caution\n    }\n    \n    config := DefaultAllowlist()\n    \n    for _, confirmDir := range config.ConfirmationDirs {\n        // Handle wildcards like /opt/*/bin\n        if strings.Contains(confirmDir, \"*\") {\n            matched, _ := filepath.Match(confirmDir, abs)\n            if matched {\n                return true\n            }\n        } else if isWithinDir(abs, confirmDir) {\n            return true\n        }\n    }\n    \n    return false\n}\n\n// GetDirectoryCategory returns the security category for a path\nfunc GetDirectoryCategory(path string) (DirectoryCategory, error) {\n    abs, err := filepath.Abs(filepath.Clean(path))\n    if err != nil {\n        return CategoryForbidden, err\n    }\n    \n    config := DefaultAllowlist()\n    \n    // Check forbidden first\n    for _, forbidden := range config.ForbiddenDirs {\n        if isWithinDir(abs, forbidden) {\n            return CategoryForbidden, nil\n        }\n    }\n    \n    // Check if requires confirmation\n    if RequiresConfirmation(abs) {\n        return CategoryRequiresConfirmation, nil\n    }\n    \n    // Check allowed\n    for _, allowed := range config.AllowedDirs {\n        if isWithinDir(abs, allowed) {\n            return CategoryAllowed, nil\n        }\n    }\n    \n    // Default: forbidden\n    return CategoryForbidden, nil\n}\n\n// ValidateBinaryForShim performs comprehensive validation\nfunc ValidateBinaryForShim(path string, allowConfirmed bool) error {\n    abs, err := filepath.Abs(filepath.Clean(path))\n    if err != nil {\n        return fmt.Errorf(\"cannot resolve path: %w\", err)\n    }\n    \n    // Check if critical binary\n    if IsCriticalSystemBinary(abs) {\n        return fmt.Errorf(\"cannot shim critical system binary: %s\\n\\nShimming %s could compromise system security and stability.\", \n            filepath.Base(abs), filepath.Base(abs))\n    }\n    \n    // Check directory category\n    category, err := GetDirectoryCategory(abs)\n    if err != nil {\n        return err\n    }\n    \n    switch category {\n    case CategoryForbidden:\n        return fmt.Errorf(\"cannot shim binaries in system directory: %s\\n\\nDirectory %s is protected for security reasons.\",\n            abs, filepath.Dir(abs))\n    \n    case CategoryRequiresConfirmation:\n        if !allowConfirmed {\n            return fmt.Errorf(\"shimming %s requires explicit confirmation\\n\\nUse --confirm-system-dir flag if you understand the security implications\",\n                abs)\n        }\n        // Allowed with confirmation\n        return nil\n    \n    case CategoryAllowed:\n        // Safe to proceed\n        return nil\n    \n    default:\n        return fmt.Errorf(\"unknown directory category\")\n    }\n}\n\n// Helper: check if path is within dir (handling symlinks)\nfunc isWithinDir(path, dir string) bool {\n    absPath, err := filepath.Abs(path)\n    if err != nil {\n        return false\n    }\n    absDir, err := filepath.Abs(dir)\n    if err != nil {\n        return false\n    }\n    \n    rel, err := filepath.Rel(absDir, absPath)\n    if err != nil {\n        return false\n    }\n    \n    return !strings.HasPrefix(rel, \"..\")\n}\n```\n\n## CLI Integration\n\n### Update shim command to require confirmation flag\n\n```go\n// In internal/cli/shim.go\n\nvar shimCmd = \u0026cobra.Command{\n    Use:   \"shim \u003ccommand\u003e\",\n    Short: \"Install a shim for a command\",\n    RunE:  runShim,\n}\n\nvar confirmSystemDir bool\n\nfunc init() {\n    shimCmd.Flags().BoolVar(\u0026confirmSystemDir, \"confirm-system-dir\", false, \n        \"Confirm shimming binaries in system directories (security risk)\")\n}\n\nfunc runShim(cmd *cobra.Command, args []string) error {\n    // ... existing code ...\n    \n    // Validate before shimming\n    if err := security.ValidateBinaryForShim(binaryPath, confirmSystemDir); err != nil {\n        return err\n    }\n    \n    // Warn if in confirmation directory\n    if security.RequiresConfirmation(binaryPath) \u0026\u0026 confirmSystemDir {\n        fmt.Fprintf(os.Stderr, \"⚠️  WARNING: Shimming binary in system directory\\n\")\n        fmt.Fprintf(os.Stderr, \"   Path: %s\\n\", binaryPath)\n        fmt.Fprintf(os.Stderr, \"   This may affect all users on the system\\n\\n\")\n    }\n    \n    // Proceed with installation\n    // ...\n}\n```\n\n### Update installer.go\n\n```go\n// In internal/shim/installer.go Install function\n\nfunc Install(binaryPath, ribbinPath string, allowSystemDir bool) error {\n    // Validate paths with allowlist\n    if err := security.ValidateBinaryForShim(binaryPath, allowSystemDir); err != nil {\n        return err\n    }\n    \n    // ... rest of installation ...\n}\n```\n\n### Update error messages in installer.go\n\n```go\n// Replace generic \"try with sudo\" with specific guidance\n\nif os.IsPermission(err) {\n    if security.IsCriticalSystemBinary(binaryPath) {\n        return fmt.Errorf(\"permission denied: %s\\n\\nCANNOT shim critical system binary %s for security reasons\",\n            binaryPath, filepath.Base(binaryPath))\n    }\n    \n    category, _ := security.GetDirectoryCategory(binaryPath)\n    if category == CategoryForbidden {\n        return fmt.Errorf(\"permission denied: %s\\n\\nDirectory %s is protected and cannot be shimmed\",\n            binaryPath, filepath.Dir(binaryPath))\n    }\n    \n    return fmt.Errorf(\"permission denied: %s\\n\\nIf you understand the security implications:\\n  sudo ribbin shim %s --confirm-system-dir\",\n        binaryPath, cmdName)\n}\n```\n\n## Test Cases\n\nCreate `internal/security/allowlist_test.go`:\n\n```go\nfunc TestIsCriticalSystemBinary(t *testing.T) {\n    tests := []struct {\n        path     string\n        critical bool\n    }{\n        {\"/usr/bin/bash\", true},\n        {\"/bin/sh\", true},\n        {\"/usr/bin/sudo\", true},\n        {\"/usr/local/bin/node\", false},\n        {\"/home/user/.local/bin/myapp\", false},\n    }\n    \n    for _, tt := range tests {\n        result := IsCriticalSystemBinary(tt.path)\n        if result != tt.critical {\n            t.Errorf(\"IsCriticalSystemBinary(%s) = %v, want %v\", \n                tt.path, result, tt.critical)\n        }\n    }\n}\n\nfunc TestGetDirectoryCategory(t *testing.T) {\n    home, _ := os.UserHomeDir()\n    \n    tests := []struct {\n        path     string\n        category DirectoryCategory\n    }{\n        {filepath.Join(home, \".local/bin/tool\"), CategoryAllowed},\n        {\"/usr/local/bin/tool\", CategoryRequiresConfirmation},\n        {\"/usr/bin/bash\", CategoryForbidden},\n        {\"/bin/sh\", CategoryForbidden},\n        {\"/opt/homebrew/bin/node\", CategoryRequiresConfirmation},\n    }\n    \n    for _, tt := range tests {\n        cat, err := GetDirectoryCategory(tt.path)\n        assert.NoError(t, err)\n        assert.Equal(t, tt.category, cat, \"path: %s\", tt.path)\n    }\n}\n\nfunc TestValidateBinaryForShim_CriticalBinary(t *testing.T) {\n    err := ValidateBinaryForShim(\"/usr/bin/bash\", false)\n    assert.Error(t, err)\n    assert.Contains(t, err.Error(), \"critical system binary\")\n}\n\nfunc TestValidateBinaryForShim_ForbiddenDirectory(t *testing.T) {\n    err := ValidateBinaryForShim(\"/usr/bin/myapp\", false)\n    assert.Error(t, err)\n    assert.Contains(t, err.Error(), \"protected\")\n}\n\nfunc TestValidateBinaryForShim_RequiresConfirmation(t *testing.T) {\n    // Without confirmation flag\n    err := ValidateBinaryForShim(\"/usr/local/bin/myapp\", false)\n    assert.Error(t, err)\n    assert.Contains(t, err.Error(), \"confirmation\")\n    \n    // With confirmation flag\n    err = ValidateBinaryForShim(\"/usr/local/bin/myapp\", true)\n    assert.NoError(t, err)\n}\n\nfunc TestValidateBinaryForShim_AllowedDirectory(t *testing.T) {\n    home, _ := os.UserHomeDir()\n    path := filepath.Join(home, \".local/bin/myapp\")\n    \n    err := ValidateBinaryForShim(path, false)\n    assert.NoError(t, err)\n}\n```\n\n## Integration Tests\n\nCreate `tests/integration/allowlist_test.go`:\n\n```go\nfunc TestShimCriticalBinary_Rejected(t *testing.T) {\n    // Attempt to shim bash\n    cmd := exec.Command(\"ribbin\", \"shim\", \"bash\")\n    output, err := cmd.CombinedOutput()\n    \n    assert.Error(t, err)\n    assert.Contains(t, string(output), \"critical system binary\")\n}\n\nfunc TestShimSystemDirectory_RequiresFlag(t *testing.T) {\n    // Create a test binary in /usr/local/bin (if writable)\n    testBin := \"/usr/local/bin/ribbin-test-\" + randomString()\n    \n    // Without flag - should fail\n    cmd := exec.Command(\"ribbin\", \"shim\", testBin)\n    output, err := cmd.CombinedOutput()\n    \n    assert.Error(t, err)\n    assert.Contains(t, string(output), \"confirmation\")\n    \n    // With flag - should succeed (or fail with permission error)\n    cmd = exec.Command(\"ribbin\", \"shim\", testBin, \"--confirm-system-dir\")\n    err = cmd.Run()\n    \n    // Either succeeds or fails with permission error (not validation error)\n    if err != nil {\n        assert.Contains(t, err.Error(), \"permission\")\n    }\n}\n\nfunc TestShimUserBinary_Succeeds(t *testing.T) {\n    home, _ := os.UserHomeDir()\n    testBin := filepath.Join(home, \".local/bin/ribbin-test-\" + randomString())\n    \n    // Create dummy binary\n    os.MkdirAll(filepath.Dir(testBin), 0755)\n    os.WriteFile(testBin, []byte(\"#!/bin/sh\\necho test\"), 0755)\n    defer os.Remove(testBin)\n    \n    // Should succeed without confirmation\n    cmd := exec.Command(\"ribbin\", \"shim\", filepath.Base(testBin))\n    err := cmd.Run()\n    \n    assert.NoError(t, err)\n}\n```\n\n## Success Criteria\n\n- [ ] AllowlistConfig with sensible defaults implemented\n- [ ] Critical binaries (bash, sudo, etc.) always rejected\n- [ ] System directories (/usr/bin, /bin) always rejected\n- [ ] Confirmation directories (/usr/local/bin) require --confirm-system-dir flag\n- [ ] User directories (~/.local/bin) allowed without confirmation\n- [ ] Clear, actionable error messages for each rejection case\n- [ ] Test coverage \u003e90%\n- [ ] Integration tests verify CLI behavior\n\n## Dependencies\n\n- Blocks: Path sanitization module (calls isWithinDir helper)\n- Blocks: All other security tasks (foundational control)\n\n## Estimated Complexity\n\nHigh - Core security control affecting all operations","status":"closed","priority":0,"issue_type":"task","owner":"don@happycollision.com","created_at":"2026-01-18T13:22:14.405505-05:00","created_by":"Don Denton","updated_at":"2026-01-18T14:45:53.911693-05:00","closed_at":"2026-01-18T14:45:53.911693-05:00","close_reason":"All three P0 security modules implemented and tested successfully. Directory allowlist prevents critical binary shimming, path sanitization blocks traversal attacks, and file locking eliminates TOCTOU race conditions.","dependencies":[{"issue_id":"ribbin-rrg","depends_on_id":"ribbin-rx1","type":"parent-child","created_at":"2026-01-18T13:39:34.917245-05:00","created_by":"Don Denton"}]}
{"id":"ribbin-rx1","title":"Security hardening for privileged file operations","description":"# Security Hardening Epic\n\nRibbin writes to critical system directories (/usr/bin, /usr/local/bin, ~/.config) and manipulates binary files, but currently lacks fundamental security controls. This epic addresses 8 critical security vulnerabilities that could lead to privilege escalation, file system attacks, and system compromise.\n\n## Critical Vulnerabilities\n\n1. **No Path Sanitization** - User paths from config are used directly, enabling path traversal\n2. **TOCTOU Vulnerabilities** - Race conditions between file checks and operations\n3. **Symlink Attacks** - No validation of symlink targets\n4. **Unsafe Privilege Escalation** - Tool suggests sudo without security warnings\n5. **No Directory Allowlist** - Can shim critical system binaries (bash, sudo, su)\n6. **Environment Variable Injection** - HOME can be manipulated to control registry location\n7. **No Audit Trail** - No logging of privileged operations\n8. **No Atomic Operations** - Partial failures leave system in inconsistent state\n\n## Implementation Phases\n\n**Phase 1 (Critical)**: Path validation, allowlists, file locking\n**Phase 2 (High)**: Symlink prevention, privilege controls, env validation  \n**Phase 3 (Medium)**: Audit logging, config validation, monitoring\n\n## Testing Requirements\n\n- Security test suite for each vulnerability\n- Integration tests for attack scenarios\n- Manual security review of all file operations\n\n## References\n\nDetailed analysis: /Users/dondenton/.claude/plans/snoopy-bubbling-lerdorf.md","status":"closed","priority":0,"issue_type":"epic","owner":"don@happycollision.com","created_at":"2026-01-18T13:20:18.917778-05:00","created_by":"Don Denton","updated_at":"2026-01-18T23:27:57.149041-05:00","closed_at":"2026-01-18T23:27:57.149041-05:00","close_reason":"All security hardening tasks complete: path sanitization, directory allowlist, file locking, symlink prevention, audit logging, environment validation, and comprehensive test suite."}
{"id":"ribbin-skj","title":"Implement Ribbin - Go-based command shimming tool","description":"# Ribbin\n\nCommand shimming tool that replaces binaries with symlinks to a single Go binary.\n\n## How It Works\n\n1. **Single Go binary** (`ribbin`) handles both CLI commands and shim invocations\n2. **Symlinks replace target binaries**: `/usr/bin/cat` → `/usr/local/bin/ribbin`\n3. **Originals renamed to sidecars**: `/usr/bin/cat.ribbin-original`\n4. **Mode detection via `argv[0]`**: If invoked as \"ribbin\" → CLI mode, otherwise → shim mode\n5. **Shim checks PWD** for nearest `ribbin.json`, applies configured action or passes through\n\n## Commands\n\n| Command | Description |\n|---------|-------------|\n| `ribbin shim` | Replace binaries with symlinks based on nearest `ribbin.json` |\n| `ribbin unshim` | Restore originals from nearest config |\n| `ribbin unshim --all` | Restore all from global registry |\n| `ribbin unshim --all --search` | Find all sidecars system-wide, restore |\n| `ribbin activate` | Enable shims for this terminal session (tracks shell PID) |\n| `ribbin on` | Enable shims globally |\n| `ribbin off` | Disable shims globally |\n\n## Config Format (ribbin.json)\n\n```json\n{\n  \"shims\": {\n    \"tsc\": {\n      \"action\": \"block\",\n      \"message\": \"Use pnpm run typecheck instead\"\n    },\n    \"cat\": {\n      \"action\": \"block\",\n      \"message\": \"Use bat instead\",\n      \"paths\": [\"/usr/bin/cat\", \"/bin/cat\"]\n    }\n  }\n}\n```\n\n- Command names resolve via `which` by default\n- Optional `paths` array for explicit locations\n\n## Global Registry (~/.config/ribbin/registry.json)\n\n```json\n{\n  \"shims\": {\n    \"/usr/bin/cat\": {\n      \"original\": \"/usr/bin/cat.ribbin-original\",\n      \"config\": \"/path/to/project/ribbin.json\"\n    }\n  },\n  \"activations\": {\n    \"12345\": { \"pid\": 12345, \"activated_at\": \"...\" }\n  },\n  \"global_on\": false\n}\n```\n\n## Project Structure\n\n```\nribbin/\n├── cmd/ribbin/main.go           # Entry point, mode detection\n├── internal/\n│   ├── cli/                     # CLI commands (shim, unshim, activate, on, off)\n│   ├── config/                  # ribbin.json and registry parsing\n│   ├── shim/                    # Shim logic, installer, resolver\n│   └── process/                 # PID ancestry (darwin/linux)\n├── go.mod\n├── Makefile\n└── .goreleaser.yaml\n```\n\n## Shim Logic (when invoked as shimmed command)\n\n1. Get original path: argv[0] + \".ribbin-original\"\n2. Check RIBBIN_BYPASS=1 → passthrough\n3. Load registry, check if active:\n   - global_on=true → active\n   - ancestor PID in activations → active\n   - otherwise → passthrough\n4. If active, find nearest ribbin.json\n5. If command listed with action=block → show message, exit 1\n6. Otherwise → exec original\n\n## Dependencies\n\n- spf13/cobra - CLI framework\n- mitchellh/go-ps - Cross-platform process inspection (optional)\n\n## Performance Target\n\n\u003c3ms overhead per shimmed command invocation","status":"closed","priority":1,"issue_type":"epic","owner":"don@happycollision.com","created_at":"2026-01-17T22:00:19.657078-05:00","created_by":"Don Denton","updated_at":"2026-01-18T14:11:33.16183-05:00","closed_at":"2026-01-18T14:11:33.16183-05:00","close_reason":"All core implementation tasks completed. Only polish task (ribbin-48m) remains open as separate task."}
{"id":"ribbin-u13","title":"Phase 3: Rename internal/shim → internal/wrap","description":"# Phase 3: Rename internal/shim → internal/wrap\n\nRename the shim package to wrap package throughout the codebase.\n\n## Changes Required\n\n### 1. Rename directory\n\n```bash\ngit mv internal/shim internal/wrap\n```\n\n### 2. Update package declaration in all files\n\n- `internal/wrap/installer.go`\n- `internal/wrap/resolver.go`\n- `internal/wrap/runner.go`\n- `internal/wrap/sidecar.go` (if exists)\n- Any test files\n\nChange `package shim` to `package wrap`\n\n### 3. Update all imports\n\nSearch and replace in all Go files:\n```\n\"github.com/happycollision/ribbin/internal/shim\"\n→\n\"github.com/happycollision/ribbin/internal/wrap\"\n```\n\nFiles that import shim:\n- `cmd/ribbin/main.go`\n- `internal/cli/shim.go` (will be renamed in Phase 4)\n- `internal/cli/unshim.go` (will be renamed in Phase 4)\n- Any other CLI files\n\n### 4. Rename functions/types\n\n- `shim.Install()` → `wrap.Install()`\n- `shim.Uninstall()` → `wrap.Uninstall()`\n- `shim.Run()` → `wrap.Run()`\n- `shim.IsAlreadyShimmed()` → `wrap.IsAlreadyWrapped()`\n- etc.\n\n## Tests \u0026 Documentation\n\n- Update all test files in the renamed package\n- Update any documentation referencing the package path\n- Ensure all tests pass after rename\n\n## Verification\n\n- `go build ./...` succeeds\n- All tests pass\n- No references to \"shim\" package remain (except in comments/docs where historical context needed)","status":"closed","priority":2,"issue_type":"task","owner":"don@happycollision.com","created_at":"2026-01-20T11:21:20.101974-05:00","created_by":"Don Denton","updated_at":"2026-01-20T13:49:53.07042-05:00","closed_at":"2026-01-20T13:49:53.07042-05:00","close_reason":"Completed: Renamed internal/shim to internal/wrap","dependencies":[{"issue_id":"ribbin-u13","depends_on_id":"ribbin-is0","type":"blocks","created_at":"2026-01-20T11:23:26.50086-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-u13","depends_on_id":"ribbin-mz1","type":"blocks","created_at":"2026-01-20T11:24:11.762961-05:00","created_by":"Don Denton"}]}
{"id":"ribbin-up2","title":"Update documentation for ancestor-aware passthrough matching","description":"## Context\n\nPart of the ancestor-aware invocation matching feature. Documentation needs to be updated to explain the new ancestor matching behavior and `depth` option.\n\n## Files to Update\n\n### 1. `docs/how-to/passthrough-args.md`\n\nUpdate to explain:\n- Passthrough now checks ALL ancestors by default, not just immediate parent\n- Add section about `depth` option\n- Add example for nx/turborepo use case\n\n**New section to add:**\n\n```markdown\n## Ancestor Matching\n\nBy default, passthrough checks **all ancestor processes** in the process tree, not just the immediate parent. This handles task runners like nx, turborepo, and make that spawn intermediate processes.\n\n### Example: nx monorepo\n\nWhen you run `pnpm nx typecheck`, the process tree looks like:\n```\npnpm nx typecheck → nx → node worker → tsc\n```\n\nWith this config, tsc will pass through because \"pnpm nx\" is found in an ancestor:\n\n\\`\\`\\`jsonc\n{\n  \"passthrough\": {\n    \"invocation\": [\"pnpm nx\"]\n  }\n}\n\\`\\`\\`\n\n### Limiting Search Depth\n\nUse `depth` to limit how far up the tree to search:\n\n\\`\\`\\`jsonc\n{\n  \"passthrough\": {\n    \"invocation\": [\"pnpm run\"],\n    \"depth\": 1  // Only check immediate parent\n  }\n}\n\\`\\`\\`\n\n| depth | behavior |\n|-------|----------|\n| 0 or omitted | unlimited (check all ancestors) |\n| 1 | immediate parent only |\n| 2 | parent + grandparent |\n| N | up to N ancestors |\n```\n\n### 2. `docs/reference/config-schema.md`\n\nUpdate passthrough reference table (around line 124-127):\n\n```markdown\n| Property | Type | Description |\n|----------|------|-------------|\n| `invocation` | string[] | Substrings to match in ancestor commands |\n| `invocationRegexp` | string[] | Regex patterns to match ancestor commands |\n| `depth` | integer | How many ancestors to check (0 = unlimited) |\n```\n\n### 3. `README.md`\n\nThe example at line 138 should work as-is, but consider adding a note about ancestor matching in the passthrough explanation.\n\n## Dependencies\n\n- Depends on: `ribbin-k1q` (shouldPassthrough implementation) - docs should match implemented behavior\n\n## Acceptance Criteria\n\n- [ ] `docs/how-to/passthrough-args.md` updated with ancestor matching explanation\n- [ ] `docs/reference/config-schema.md` updated with depth property\n- [ ] Examples show nx/turborepo use case\n- [ ] Depth option documented with clear semantics","status":"closed","priority":3,"issue_type":"task","owner":"don.denton@trillianthealth.com","created_at":"2026-01-22T00:33:56.514641-05:00","created_by":"Don Denton","updated_at":"2026-01-22T09:43:54.117243-05:00","closed_at":"2026-01-22T09:43:54.117243-05:00","close_reason":"Closed","dependencies":[{"issue_id":"ribbin-up2","depends_on_id":"ribbin-k1q","type":"blocks","created_at":"2026-01-22T00:34:04.605376-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-up2","depends_on_id":"ribbin-9r5","type":"parent-child","created_at":"2026-01-22T09:35:41.079108-05:00","created_by":"Don Denton"}]}
{"id":"ribbin-v8p","title":"Test issue for sync","status":"tombstone","priority":4,"issue_type":"task","owner":"don@happycollision.com","created_at":"2026-01-17T22:31:43.486738-05:00","created_by":"Don Denton","updated_at":"2026-01-17T22:32:49.349419-05:00","deleted_at":"2026-01-17T22:32:49.349419-05:00","deleted_by":"Don Denton","delete_reason":"delete","original_type":"task"}
{"id":"ribbin-vcv","title":"Add verbose logging mode for shim execution","description":"Add a verbose logging mode that can be enabled at the system or shell level (caller chooses). When enabled, verbose logging will print logs when shims are called, explaining the path of whether a shim blocks, passes, or redirects.\n\n## Requirements\n- Caller can enable verbose mode (environment variable or flag)\n- Log output when shims are invoked\n- Explain the decision path: block, pass, or redirect\n- Include relevant context (shim name, matched config, reason)\n\n## Example output\n```\n[ribbin] tsc -\u003e BLOCKED: Use 'pnpm run typecheck' instead\n[ribbin] node -\u003e PASS: no shim configured\n[ribbin] cat -\u003e REDIRECT: bat (syntax highlighting)\n```","status":"closed","priority":2,"issue_type":"feature","owner":"don@happycollision.com","created_at":"2026-01-19T13:55:14.418887-05:00","created_by":"Don Denton","updated_at":"2026-01-19T22:58:39.830513-05:00","closed_at":"2026-01-19T22:58:39.830513-05:00","close_reason":"Implemented verbose logging via RIBBIN_VERBOSE=1 env var"}
{"id":"ribbin-vo3","title":"extends should allow ANY well-formatted JSONC or JSON file","description":"Currently, files referenced in `extends` must be named `ribbin.jsonc` or `ribbin.local.jsonc`. This is unnecessarily restrictive.\n\n## Current behavior\n\n```jsonc\n{\n  \"scopes\": {\n    \"main\": {\n      \"extends\": [\"./base.jsonc\"]  // ERROR: must be named ribbin.jsonc\n    }\n  }\n}\n```\n\nError: `invalid config path: config must be named ribbin.jsonc or ribbin.local.jsonc, got: base.jsonc`\n\n## Expected behavior\n\nAny well-formatted JSONC or JSON file should be valid as an extends target. This enables:\n\n- Shared mixin files with descriptive names (e.g., `hardened.jsonc`, `team-defaults.jsonc`)\n- Cleaner project structures without needing nested directories just for naming conventions\n- Better compatibility with monorepo setups where shared configs might live in common locations\n\n## Workaround\n\nCurrently requires placing extended configs in subdirectories:\n```\nproject/\n├── ribbin.jsonc\n└── base/\n    └── ribbin.jsonc   # workaround: must use this naming\n```","status":"open","priority":2,"issue_type":"feature","owner":"don.denton@trillianthealth.com","created_at":"2026-01-22T00:06:23.854532-05:00","created_by":"Don Denton","updated_at":"2026-01-22T00:06:23.854532-05:00"}
{"id":"ribbin-w7k","title":"Implement PID ancestry checking (macOS and Linux)","description":"# PID Ancestry Implementation\n\nCheck if the current process is a descendant of a given PID.\n\n## Files to Create\n\n### internal/process/ancestry.go\n\n```go\npackage process\n\n// IsDescendantOf checks if the current process is a descendant of targetPID\n// by walking up the process tree via parent PIDs.\nfunc IsDescendantOf(targetPID int) (bool, error)\n\n// ProcessExists checks if a process with the given PID exists\nfunc ProcessExists(pid int) bool\n```\n\n### internal/process/ancestry_darwin.go\n\n```go\n//go:build darwin\n\npackage process\n\nimport (\n    \"os\"\n    \"syscall\"\n    \"unsafe\"\n)\n\nfunc IsDescendantOf(targetPID int) (bool, error) {\n    currentPID := os.Getpid()\n    \n    for currentPID \u003e 1 {\n        if currentPID == targetPID {\n            return true, nil\n        }\n        ppid, err := getParentPID(currentPID)\n        if err != nil {\n            return false, err\n        }\n        currentPID = ppid\n    }\n    return false, nil\n}\n\nfunc getParentPID(pid int) (int, error) {\n    // Use sysctl to get process info on macOS\n    // CTL_KERN, KERN_PROC, KERN_PROC_PID, pid\n    var info struct {\n        // kinfo_proc structure (simplified)\n        // We only need kp_eproc.e_ppid\n        _ [unsafe.Sizeof(syscall.Timeval{})*2]byte // kp_proc padding\n        // ... more fields\n        PPID int32\n        // ... rest of structure\n    }\n    \n    // Alternatively, use external package or exec \"ps -o ppid= -p \u003cpid\u003e\"\n    // For simplicity, let's use exec approach first:\n    \n    out, err := exec.Command(\"ps\", \"-o\", \"ppid=\", \"-p\", strconv.Itoa(pid)).Output()\n    if err != nil {\n        return 0, err\n    }\n    ppid, err := strconv.Atoi(strings.TrimSpace(string(out)))\n    if err != nil {\n        return 0, err\n    }\n    return ppid, nil\n}\n\nfunc ProcessExists(pid int) bool {\n    // On Unix, sending signal 0 checks if process exists\n    err := syscall.Kill(pid, 0)\n    return err == nil\n}\n```\n\n### internal/process/ancestry_linux.go\n\n```go\n//go:build linux\n\npackage process\n\nimport (\n    \"os\"\n    \"strconv\"\n    \"strings\"\n    \"syscall\"\n)\n\nfunc IsDescendantOf(targetPID int) (bool, error) {\n    currentPID := os.Getpid()\n    \n    for currentPID \u003e 1 {\n        if currentPID == targetPID {\n            return true, nil\n        }\n        ppid, err := getParentPID(currentPID)\n        if err != nil {\n            return false, err\n        }\n        currentPID = ppid\n    }\n    return false, nil\n}\n\nfunc getParentPID(pid int) (int, error) {\n    // Read /proc/\u003cpid\u003e/stat\n    data, err := os.ReadFile(fmt.Sprintf(\"/proc/%d/stat\", pid))\n    if err != nil {\n        return 0, err\n    }\n    \n    // Format: pid (comm) state ppid ...\n    // Find the closing paren (comm can contain spaces/parens)\n    s := string(data)\n    end := strings.LastIndex(s, \")\")\n    if end == -1 {\n        return 0, fmt.Errorf(\"invalid /proc/%d/stat format\", pid)\n    }\n    \n    fields := strings.Fields(s[end+2:]) // Skip \") \"\n    if len(fields) \u003c 2 {\n        return 0, fmt.Errorf(\"invalid /proc/%d/stat format\", pid)\n    }\n    \n    // fields[0] is state, fields[1] is ppid\n    ppid, err := strconv.Atoi(fields[1])\n    if err != nil {\n        return 0, err\n    }\n    \n    return ppid, nil\n}\n\nfunc ProcessExists(pid int) bool {\n    err := syscall.Kill(pid, 0)\n    return err == nil\n}\n```\n\n## Alternative: Use go-ps library\n\nIf implementing from scratch is too complex, use mitchellh/go-ps:\n\n```go\nimport \"github.com/mitchellh/go-ps\"\n\nfunc IsDescendantOf(targetPID int) (bool, error) {\n    currentPID := os.Getpid()\n    \n    for currentPID \u003e 1 {\n        if currentPID == targetPID {\n            return true, nil\n        }\n        proc, err := ps.FindProcess(currentPID)\n        if err != nil || proc == nil {\n            return false, err\n        }\n        currentPID = proc.PPid()\n    }\n    return false, nil\n}\n```\n\n## Tests\n\n- Test self-PID returns true (process is descendant of itself? Depends on definition)\n- Test PPID returns true\n- Test unrelated PID returns false\n- Test PID 1 (init) handling\n- Test non-existent PID\n\n## Acceptance Criteria\n\n- Works on macOS\n- Works on Linux\n- Handles process not found gracefully\n- Performance: \u003c1ms for typical tree depth (~5-10 levels)","status":"closed","priority":1,"issue_type":"task","owner":"don@happycollision.com","created_at":"2026-01-17T22:06:59.791425-05:00","created_by":"Don Denton","updated_at":"2026-01-17T22:56:39.469486-05:00","closed_at":"2026-01-17T22:56:39.469486-05:00","close_reason":"Closed","dependencies":[{"issue_id":"ribbin-w7k","depends_on_id":"ribbin-skj","type":"parent-child","created_at":"2026-01-17T22:11:19.96242-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-w7k","depends_on_id":"ribbin-8n3","type":"blocks","created_at":"2026-01-17T22:12:46.350086-05:00","created_by":"Don Denton"}]}
{"id":"ribbin-x2z","title":"Implement file locking to prevent TOCTOU race conditions","description":"# File Locking Module (CRITICAL)\n\nCreate `internal/security/filelock.go` to provide advisory file locking and prevent Time-Of-Check-Time-Of-Use (TOCTOU) race conditions.\n\n## Current Vulnerability\n\n**Location**: `internal/shim/installer.go:25-50`\n\n**TOCTOU Race Condition**:\n```go\n// Check if already shimmed (line 25)\nif _, err := os.Stat(sidecarPath); err == nil {\n    return fmt.Errorf(\"binary %s is already shimmed\")\n}\n// \u003c\u003c\u003c TIME GAP - Attacker can create malicious sidecar here \u003e\u003e\u003e\n// Rename original to sidecar (line 31)\nif err := os.Rename(binaryPath, sidecarPath); err != nil {\n    // ...\n}\n```\n\n**Attack Scenario**:\n1. Ribbin checks if sidecar exists (it doesn't)\n2. Attacker creates malicious sidecar between check and rename\n3. Ribbin renames original, but malicious sidecar is already there\n4. Attacker controls execution\n\n**Risk**: File system race conditions allow attackers to inject malicious code into shim installation process.\n\n## Implementation Requirements\n\n### Platform-Specific Locking\n\n```go\npackage security\n\nimport (\n    \"fmt\"\n    \"os\"\n    \"time\"\n    \"syscall\"\n)\n\n// Lock represents an advisory file lock\ntype Lock struct {\n    file     *os.File\n    path     string\n    released bool\n}\n\n// AcquireLock acquires an exclusive advisory lock on a file\n// Creates lock file if it doesn't exist\n// Times out after specified duration to prevent deadlocks\nfunc AcquireLock(path string, timeout time.Duration) (*Lock, error) {\n    lockPath := path + \".lock\"\n    \n    // Create lock file if doesn't exist\n    file, err := os.OpenFile(lockPath, os.O_CREATE|os.O_RDWR, 0600)\n    if err != nil {\n        return nil, fmt.Errorf(\"cannot create lock file: %w\", err)\n    }\n    \n    // Try to acquire lock with timeout\n    deadline := time.Now().Add(timeout)\n    for {\n        // Try exclusive lock (LOCK_EX | LOCK_NB for non-blocking)\n        err = syscall.Flock(int(file.Fd()), syscall.LOCK_EX|syscall.LOCK_NB)\n        if err == nil {\n            // Lock acquired\n            return \u0026Lock{\n                file:     file,\n                path:     lockPath,\n                released: false,\n            }, nil\n        }\n        \n        // Check if timeout\n        if time.Now().After(deadline) {\n            file.Close()\n            return nil, fmt.Errorf(\"timeout acquiring lock on %s after %v\", path, timeout)\n        }\n        \n        // Wait a bit and retry\n        time.Sleep(100 * time.Millisecond)\n    }\n}\n\n// Release releases the file lock\nfunc (l *Lock) Release() error {\n    if l.released {\n        return fmt.Errorf(\"lock already released\")\n    }\n    \n    // Release lock\n    err := syscall.Flock(int(l.file.Fd()), syscall.LOCK_UN)\n    if err != nil {\n        return fmt.Errorf(\"cannot release lock: %w\", err)\n    }\n    \n    // Close file\n    if err := l.file.Close(); err != nil {\n        return fmt.Errorf(\"cannot close lock file: %w\", err)\n    }\n    \n    // Remove lock file\n    if err := os.Remove(l.path); err != nil \u0026\u0026 !os.IsNotExist(err) {\n        return fmt.Errorf(\"cannot remove lock file: %w\", err)\n    }\n    \n    l.released = true\n    return nil\n}\n\n// WithLock executes a function while holding a lock\n// Automatically releases lock when function returns\nfunc WithLock(path string, timeout time.Duration, fn func() error) error {\n    lock, err := AcquireLock(path, timeout)\n    if err != nil {\n        return err\n    }\n    defer lock.Release()\n    \n    return fn()\n}\n```\n\n### Enhanced File Operations\n\n```go\n// FileInfo stores file metadata for validation\ntype FileInfo struct {\n    Mode    os.FileMode\n    Size    int64\n    ModTime time.Time\n}\n\n// GetFileInfo safely gets file info without following symlinks\nfunc GetFileInfo(path string) (*FileInfo, error) {\n    info, err := os.Lstat(path)\n    if err != nil {\n        return nil, err\n    }\n    \n    return \u0026FileInfo{\n        Mode:    info.Mode(),\n        Size:    info.Size(),\n        ModTime: info.ModTime(),\n    }, nil\n}\n\n// VerifyFileUnchanged checks if file hasn't changed since last check\nfunc VerifyFileUnchanged(path string, expected *FileInfo) error {\n    current, err := GetFileInfo(path)\n    if err != nil {\n        return fmt.Errorf(\"file changed: %w\", err)\n    }\n    \n    if current.Mode != expected.Mode {\n        return fmt.Errorf(\"file mode changed: %o -\u003e %o\", expected.Mode, current.Mode)\n    }\n    if current.Size != expected.Size {\n        return fmt.Errorf(\"file size changed: %d -\u003e %d\", expected.Size, current.Size)\n    }\n    if !current.ModTime.Equal(expected.ModTime) {\n        return fmt.Errorf(\"file modified: %v -\u003e %v\", expected.ModTime, current.ModTime)\n    }\n    \n    return nil\n}\n\n// AtomicRename renames a file atomically (same filesystem only)\n// Uses O_EXCL to ensure destination doesn't exist\nfunc AtomicRename(oldPath, newPath string) error {\n    // Check that destination doesn't exist (with O_EXCL)\n    // This is atomic - prevents TOCTOU\n    f, err := os.OpenFile(newPath, os.O_CREATE|os.O_EXCL, 0600)\n    if err != nil {\n        if os.IsExist(err) {\n            return fmt.Errorf(\"destination already exists: %s\", newPath)\n        }\n        return fmt.Errorf(\"cannot create destination: %w\", err)\n    }\n    f.Close()\n    os.Remove(newPath) // Clean up test file\n    \n    // Now safe to rename\n    return os.Rename(oldPath, newPath)\n}\n```\n\n## Integration with Installer\n\nUpdate `internal/shim/installer.go`:\n\n```go\nfunc Install(binaryPath, ribbinPath string, allowSystemDir bool) error {\n    // 1. ACQUIRE LOCK FIRST (prevents concurrent modifications)\n    lock, err := security.AcquireLock(binaryPath, 10*time.Second)\n    if err != nil {\n        return fmt.Errorf(\"cannot acquire lock: %w\", err)\n    }\n    defer lock.Release()\n    \n    // 2. VALIDATE PATHS (within lock)\n    if err := security.ValidateBinaryPath(binaryPath); err != nil {\n        return fmt.Errorf(\"invalid binary path: %w\", err)\n    }\n    if err := security.ValidateBinaryForShim(binaryPath, allowSystemDir); err != nil {\n        return err\n    }\n    \n    sidecarPath := SidecarPath(binaryPath)\n    \n    // 3. GET FILE INFO (for later verification)\n    binaryInfo, err := security.GetFileInfo(binaryPath)\n    if err != nil {\n        return fmt.Errorf(\"cannot stat binary: %w\", err)\n    }\n    \n    // 4. CHECK IF ALREADY SHIMMED (within lock)\n    if _, err := os.Lstat(sidecarPath); err == nil {\n        return fmt.Errorf(\"binary %s is already shimmed (sidecar exists at %s)\", \n            binaryPath, sidecarPath)\n    }\n    \n    // 5. VERIFY BINARY UNCHANGED (prevent race)\n    if err := security.VerifyFileUnchanged(binaryPath, binaryInfo); err != nil {\n        return fmt.Errorf(\"binary changed during operation: %w\", err)\n    }\n    \n    // 6. ATOMIC RENAME (using O_EXCL)\n    if err := security.AtomicRename(binaryPath, sidecarPath); err != nil {\n        return fmt.Errorf(\"cannot rename binary to sidecar: %w\", err)\n    }\n    \n    // 7. CREATE SYMLINK (rollback on failure)\n    if err := os.Symlink(ribbinPath, binaryPath); err != nil {\n        // ROLLBACK: restore original\n        if rollbackErr := os.Rename(sidecarPath, binaryPath); rollbackErr != nil {\n            return fmt.Errorf(\"cannot create symlink (and rollback failed: %v): %w\", \n                rollbackErr, err)\n        }\n        return fmt.Errorf(\"cannot create symlink: %w\", err)\n    }\n    \n    // 8. UPDATE REGISTRY (within lock)\n    if err := UpdateShimRegistry(binaryPath, ribbinPath); err != nil {\n        // ROLLBACK: remove symlink and restore original\n        os.Remove(binaryPath)\n        os.Rename(sidecarPath, binaryPath)\n        return fmt.Errorf(\"cannot update registry: %w\", err)\n    }\n    \n    // Lock automatically released by defer\n    return nil\n}\n\nfunc Uninstall(binaryPath string) error {\n    // ACQUIRE LOCK\n    lock, err := security.AcquireLock(binaryPath, 10*time.Second)\n    if err != nil {\n        return fmt.Errorf(\"cannot acquire lock: %w\", err)\n    }\n    defer lock.Release()\n    \n    sidecarPath := SidecarPath(binaryPath)\n    \n    // Verify it's a shim (check symlink)\n    info, err := os.Lstat(binaryPath)\n    if err != nil {\n        return fmt.Errorf(\"cannot stat binary: %w\", err)\n    }\n    if info.Mode()\u0026os.ModeSymlink == 0 {\n        return fmt.Errorf(\"%s is not a shim (not a symlink)\", binaryPath)\n    }\n    \n    // Verify sidecar exists\n    if _, err := os.Stat(sidecarPath); err != nil {\n        return fmt.Errorf(\"sidecar not found: %s\", sidecarPath)\n    }\n    \n    // Remove symlink\n    if err := os.Remove(binaryPath); err != nil {\n        return fmt.Errorf(\"cannot remove symlink: %w\", err)\n    }\n    \n    // ATOMIC RENAME sidecar back to original\n    if err := security.AtomicRename(sidecarPath, binaryPath); err != nil {\n        return fmt.Errorf(\"cannot restore original binary: %w\", err)\n    }\n    \n    // Update registry\n    if err := RemoveFromShimRegistry(binaryPath); err != nil {\n        return fmt.Errorf(\"cannot update registry: %w\", err)\n    }\n    \n    return nil\n}\n```\n\n## Registry Locking\n\nUpdate `internal/config/registry.go`:\n\n```go\nfunc SaveRegistry(registry *ShimRegistry) error {\n    registryPath := getRegistryPath()\n    \n    // LOCK REGISTRY FILE\n    lock, err := security.AcquireLock(registryPath, 5*time.Second)\n    if err != nil {\n        return fmt.Errorf(\"cannot lock registry: %w\", err)\n    }\n    defer lock.Release()\n    \n    // Write to temp file first\n    tmpPath := registryPath + \".tmp\"\n    data, err := json.MarshalIndent(registry, \"\", \"  \")\n    if err != nil {\n        return fmt.Errorf(\"cannot marshal registry: %w\", err)\n    }\n    \n    if err := os.WriteFile(tmpPath, data, 0644); err != nil {\n        return fmt.Errorf(\"cannot write temp registry: %w\", err)\n    }\n    \n    // ATOMIC RENAME\n    if err := security.AtomicRename(tmpPath, registryPath); err != nil {\n        os.Remove(tmpPath) // Cleanup\n        return fmt.Errorf(\"cannot save registry: %w\", err)\n    }\n    \n    return nil\n}\n\nfunc LoadRegistry() (*ShimRegistry, error) {\n    registryPath := getRegistryPath()\n    \n    // SHARED LOCK for reading\n    lock, err := security.AcquireSharedLock(registryPath, 5*time.Second)\n    if err != nil {\n        // Registry might not exist yet\n        if os.IsNotExist(err) {\n            return \u0026ShimRegistry{\n                Shims:       make(map[string]*ShimEntry),\n                Activations: make(map[int]*ActivationEntry),\n            }, nil\n        }\n        return nil, fmt.Errorf(\"cannot lock registry: %w\", err)\n    }\n    defer lock.Release()\n    \n    // Read registry\n    data, err := os.ReadFile(registryPath)\n    if err != nil {\n        return nil, fmt.Errorf(\"cannot read registry: %w\", err)\n    }\n    \n    var registry ShimRegistry\n    if err := json.Unmarshal(data, \u0026registry); err != nil {\n        return nil, fmt.Errorf(\"cannot parse registry: %w\", err)\n    }\n    \n    return \u0026registry, nil\n}\n```\n\n### Shared Lock Support\n\nAdd to `filelock.go`:\n\n```go\n// AcquireSharedLock acquires a shared (read) lock\nfunc AcquireSharedLock(path string, timeout time.Duration) (*Lock, error) {\n    lockPath := path + \".lock\"\n    \n    file, err := os.OpenFile(lockPath, os.O_CREATE|os.O_RDWR, 0600)\n    if err != nil {\n        return nil, fmt.Errorf(\"cannot create lock file: %w\", err)\n    }\n    \n    deadline := time.Now().Add(timeout)\n    for {\n        // Try shared lock (LOCK_SH | LOCK_NB)\n        err = syscall.Flock(int(file.Fd()), syscall.LOCK_SH|syscall.LOCK_NB)\n        if err == nil {\n            return \u0026Lock{\n                file:     file,\n                path:     lockPath,\n                released: false,\n            }, nil\n        }\n        \n        if time.Now().After(deadline) {\n            file.Close()\n            return nil, fmt.Errorf(\"timeout acquiring shared lock on %s\", path)\n        }\n        \n        time.Sleep(100 * time.Millisecond)\n    }\n}\n```\n\n## Test Cases\n\nCreate `internal/security/filelock_test.go`:\n\n```go\nfunc TestAcquireLock_Exclusive(t *testing.T) {\n    tmpDir := t.TempDir()\n    testFile := filepath.Join(tmpDir, \"test\")\n    os.WriteFile(testFile, []byte(\"test\"), 0644)\n    \n    // First lock succeeds\n    lock1, err := AcquireLock(testFile, 1*time.Second)\n    assert.NoError(t, err)\n    defer lock1.Release()\n    \n    // Second lock times out\n    lock2, err := AcquireLock(testFile, 500*time.Millisecond)\n    assert.Error(t, err)\n    assert.Nil(t, lock2)\n    assert.Contains(t, err.Error(), \"timeout\")\n}\n\nfunc TestLock_Release(t *testing.T) {\n    tmpDir := t.TempDir()\n    testFile := filepath.Join(tmpDir, \"test\")\n    os.WriteFile(testFile, []byte(\"test\"), 0644)\n    \n    lock1, err := AcquireLock(testFile, 1*time.Second)\n    assert.NoError(t, err)\n    \n    // Release lock\n    err = lock1.Release()\n    assert.NoError(t, err)\n    \n    // Now second lock succeeds\n    lock2, err := AcquireLock(testFile, 1*time.Second)\n    assert.NoError(t, err)\n    defer lock2.Release()\n}\n\nfunc TestWithLock(t *testing.T) {\n    tmpDir := t.TempDir()\n    testFile := filepath.Join(tmpDir, \"test\")\n    os.WriteFile(testFile, []byte(\"test\"), 0644)\n    \n    executed := false\n    err := WithLock(testFile, 1*time.Second, func() error {\n        executed = true\n        return nil\n    })\n    \n    assert.NoError(t, err)\n    assert.True(t, executed)\n}\n\nfunc TestAtomicRename_DestExists(t *testing.T) {\n    tmpDir := t.TempDir()\n    src := filepath.Join(tmpDir, \"src\")\n    dst := filepath.Join(tmpDir, \"dst\")\n    \n    os.WriteFile(src, []byte(\"source\"), 0644)\n    os.WriteFile(dst, []byte(\"dest\"), 0644)\n    \n    // Should fail - dest exists\n    err := AtomicRename(src, dst)\n    assert.Error(t, err)\n    assert.Contains(t, err.Error(), \"already exists\")\n}\n\nfunc TestVerifyFileUnchanged(t *testing.T) {\n    tmpDir := t.TempDir()\n    testFile := filepath.Join(tmpDir, \"test\")\n    os.WriteFile(testFile, []byte(\"original\"), 0644)\n    \n    // Get initial info\n    info, err := GetFileInfo(testFile)\n    assert.NoError(t, err)\n    \n    // Verify unchanged\n    err = VerifyFileUnchanged(testFile, info)\n    assert.NoError(t, err)\n    \n    // Modify file\n    time.Sleep(10 * time.Millisecond) // Ensure mod time changes\n    os.WriteFile(testFile, []byte(\"modified\"), 0644)\n    \n    // Verify changed\n    err = VerifyFileUnchanged(testFile, info)\n    assert.Error(t, err)\n    assert.Contains(t, err.Error(), \"changed\")\n}\n```\n\n### Race Condition Tests\n\n```go\nfunc TestConcurrentInstall_Prevented(t *testing.T) {\n    tmpDir := t.TempDir()\n    binary := filepath.Join(tmpDir, \"test-binary\")\n    ribbin := filepath.Join(tmpDir, \"ribbin\")\n    \n    // Create test binaries\n    os.WriteFile(binary, []byte(\"#!/bin/sh\\necho original\"), 0755)\n    os.WriteFile(ribbin, []byte(\"#!/bin/sh\\necho ribbin\"), 0755)\n    \n    // Try concurrent installations\n    var wg sync.WaitGroup\n    errors := make(chan error, 2)\n    \n    for i := 0; i \u003c 2; i++ {\n        wg.Add(1)\n        go func() {\n            defer wg.Done()\n            err := Install(binary, ribbin, false)\n            errors \u003c- err\n        }()\n    }\n    \n    wg.Wait()\n    close(errors)\n    \n    // One should succeed, one should fail (locked or already shimmed)\n    var succeeded, failed int\n    for err := range errors {\n        if err == nil {\n            succeeded++\n        } else {\n            failed++\n        }\n    }\n    \n    assert.Equal(t, 1, succeeded, \"exactly one install should succeed\")\n    assert.Equal(t, 1, failed, \"exactly one install should fail\")\n}\n```\n\n## Success Criteria\n\n- [ ] Advisory file locking implemented with timeout\n- [ ] Exclusive and shared lock modes supported\n- [ ] AtomicRename uses O_EXCL to prevent TOCTOU\n- [ ] File verification detects changes between check and use\n- [ ] Lock automatically released via defer\n- [ ] All installer operations protected by locks\n- [ ] Registry operations use locking\n- [ ] Test coverage \u003e90% including race condition tests\n- [ ] Manual testing with concurrent operations confirms safety\n\n## Dependencies\n\n- Requires: Path sanitization, allowlist (called within locked operations)\n- Blocks: Atomic installation task\n\n## Estimated Complexity\n\nHigh - Critical concurrency primitive with platform-specific syscalls","status":"closed","priority":0,"issue_type":"task","owner":"don@happycollision.com","created_at":"2026-01-18T13:30:56.861237-05:00","created_by":"Don Denton","updated_at":"2026-01-18T14:45:53.914696-05:00","closed_at":"2026-01-18T14:45:53.914696-05:00","close_reason":"All three P0 security modules implemented and tested successfully. Directory allowlist prevents critical binary shimming, path sanitization blocks traversal attacks, and file locking eliminates TOCTOU race conditions.","dependencies":[{"issue_id":"ribbin-x2z","depends_on_id":"ribbin-pu4","type":"blocks","created_at":"2026-01-18T13:33:37.0139-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-x2z","depends_on_id":"ribbin-rrg","type":"blocks","created_at":"2026-01-18T13:33:42.242924-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-x2z","depends_on_id":"ribbin-rx1","type":"parent-child","created_at":"2026-01-18T13:39:40.173109-05:00","created_by":"Don Denton"}]}
{"id":"ribbin-xot","title":"Implement shim resolver with inheritance","description":"**Read epic ribbin-3gj for full context.**\n\nCreate new file internal/config/resolver.go:\n\n```go\ntype Resolver struct {\n    cache map[string]*ProjectConfig  // loaded external files\n}\n\nfunc (r *Resolver) ResolveEffectiveShims(\n    config *ProjectConfig,\n    configDir string,\n    scope *ScopeConfig,\n    visited map[string]bool,  // cycle detection\n) (map[string]ShimConfig, error)\n```\n\nResolution algorithm:\n1. Start with empty shim map\n2. For each entry in extends (in order):\n   - Parse the reference using ParseExtendsRef\n   - Load external file if needed (with caching)\n   - Recursively resolve that target's extends\n   - Merge shims (later overrides earlier)\n3. Merge scope's own shims (overrides all extends)\n\nMust handle:\n- Recursive extends (scope A extends scope B which extends root)\n- Cycle detection (error if A extends B extends A)\n- External file caching to avoid re-parsing\n- Provenance tracking (which file/scope each shim came from)\n\nTests: Create internal/config/resolver_test.go with:\n- Isolated scope (no extends) → only own shims\n- extends = [\"root\"] → root + own, own wins\n- extends = [\"root\", \"root.strict\"] → root \u003c strict \u003c own\n- External file without fragment → entire file merged\n- Cycle detection → error","status":"closed","priority":2,"issue_type":"task","owner":"don@happycollision.com","created_at":"2026-01-19T13:38:06.389665-05:00","created_by":"Don Denton","updated_at":"2026-01-19T20:28:37.205907-05:00","closed_at":"2026-01-19T20:28:37.205907-05:00","close_reason":"Implemented Resolver with recursive extends resolution, cycle detection, external file caching, and comprehensive tests","dependencies":[{"issue_id":"ribbin-xot","depends_on_id":"ribbin-3gj","type":"parent-child","created_at":"2026-01-19T13:38:52.398393-05:00","created_by":"Don Denton"},{"issue_id":"ribbin-xot","depends_on_id":"ribbin-0ct","type":"blocks","created_at":"2026-01-19T13:39:22.736435-05:00","created_by":"Don Denton"}]}
